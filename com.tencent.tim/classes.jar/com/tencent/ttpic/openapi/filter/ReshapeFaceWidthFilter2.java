package com.tencent.ttpic.openapi.filter;

import android.graphics.PointF;
import com.tencent.aekit.openrender.AEOpenRenderConfig.DRAW_MODE;
import com.tencent.aekit.openrender.UniformParam.FloatParam;
import com.tencent.aekit.openrender.UniformParam.FloatsParam;
import com.tencent.aekit.openrender.internal.VideoFilterBase;
import com.tencent.ttpic.openapi.util.VideoMaterialUtil;
import java.util.List;
import java.util.Map;

public class ReshapeFaceWidthFilter2
  extends VideoFilterBase
{
  public static final String FRAGMENT_SHADER_NORMAL = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n    //gl_FragColor = vec4(inputTextureCoordinate.xy, vec2(0.0, 1.0));\n\n    //vec4 color = vec4(textureCoordinate.x*8.0+0.5, textureCoordinate.y*8.0+0.5, 0.5, 1.0);\n    //gl_FragColor = color;\n\n    //gl_FragColor = vec4(textureCoordinate, textureCoordinate.x, 1.0);\n\n    gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n}";
  public static final String FRAGMENT_SHADER_VTF = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n\n    //vec2 diffPosition = textureCoordinate;\n    //float ddx = (diffPosition.x + 1.0) / 2.0;\n    //float ddy = (diffPosition.y + 1.0) / 2.0;\n    //diffPosition = vec2(ddx,ddy);\n    //vec2 a = fract(diffPosition * 255.0 / 256.0);\n    //vec2 b = fract(diffPosition * 255.0 * 255.0 / 256.0);\n    //gl_FragColor = vec4(a,b);\n\n    // 新版的 shader 颜色通道中记录的是位移偏移量，只有在最后 combinedFilter 才最终将所有 filter 的位移量叠加，去图上取点。这样的好处是：\n    // 1. 只有 128 * 128 个点\n    // 2. smoothstep 会更平滑，128 * 128 个点取插值，原来的处理方法会使像素点变模糊\n    // 3. 两个矩形交叠的地方，位移处理的先后顺序不影响结果（不能说这是好还是坏，因为 PS 的液化是作用在原图上的）\n\n    // 至于此处要改为 * 255 再 / 255 是为了提升精度（浮点纹理 iOS 不支持，而一个字节只能表示 256 个不同值）\n    // 本来小奇使用了浮点纹理，但是发现有机型不支持，不用浮点纹理又精度不够，所以采用这个方法，变成2个字节表示一个值，提升了精度。\n    vec2 diffPosition = textureCoordinate;\n    diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;  // 0.5 * (diffPosition + 1.0) 是将(-1, 1)间的值转换到(0, 1)，\n    vec2 a = floor(diffPosition) / 255.0;\n    vec2 b = fract(diffPosition);\n    gl_FragColor = vec4(a, b);\n\n\n    //vec2 diffPosition = textureCoordinate;\n    //diffPosition = 0.5 * (diffPosition + 1.0) * 256.0;\n    //vec2 a = floor(diffPosition) / 256.0;\n    //vec2 b = fract(diffPosition);\n    //gl_FragColor = vec4(a, b);\n}\n";
  public static final String VERTEX_SHADER_NORMAL = "precision highp float;\n//uniform mat4 projection;\n//uniform mat4 faceFrame;\n//uniform mat4 stableToImage;\nuniform vec2 leftEyePlainSize;\nuniform vec3 leftEyeCenter;\nuniform vec2 rightEyePlainSize;\nuniform vec3 rightEyeCenter;\n\nuniform vec2 leftEyebrowPlainSize;\nuniform vec3 leftEyebrowCenter;\nuniform vec2 rightEyebrowPlainSize;\nuniform vec3 rightEyebrowCenter;\n\nuniform vec3 lipsCenter;\nuniform vec2 lipsPlainSize;\nuniform vec3 nose3DCenter; // 鼻子中心\nuniform vec2 nosePlainSize; //\nuniform vec2 facePlainSize;\nuniform vec3 faceCenter;\n\nuniform vec2 facePlainSizeLeft2;\nuniform vec3 faceCenterLeft2;\nuniform float leftAngle2;\nuniform vec2 facePlainSizeRight2;\nuniform vec3 faceCenterRight2;\nuniform float rightAngle2;\nuniform vec3 faceMoveCenter2;\n\nuniform float faceWidth;\nuniform float faceWidth2;\nattribute vec4 position;\n//attribute float faceIndex;\n//attribute float depthValue;\nvarying vec2 textureCoordinate;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\n\nuniform sampler2D inputImageTexture;\n\nfloat my_smoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(angles.z);\n    float sin_t = sin(angles.z);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - my_smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - my_smoothstep(a1, a2, d2);\n}\n\nfloat getLeftEyeMask() {\n    const vec2 sigmaScaling = vec2(1.5, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, leftEyeCenter.xy, leftEyePlainSize, 0.5, 1.2);\n}\nfloat getRightEyeMask() {\n    const vec2 sigmaScaling = vec2(1.5, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, rightEyeCenter.xy, rightEyePlainSize, 0.5, 1.2);\n}\nfloat getLeftEyebrowMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, leftEyebrowCenter.xy, leftEyebrowPlainSize, 0.5, 1.0);\n}\nfloat getRightEyebrowMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, rightEyebrowCenter.xy, rightEyebrowPlainSize, 0.5, 1.0);\n}\nhighp float getLipsMask() {\n    const highp vec2 sigmaScaling = vec2(1.5, 1.5);\n    return getEllipseMask(sigmaScaling, position.xy, lipsCenter.xy, lipsPlainSize, 0.5, 1.2);\n}\nfloat getNoseMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, nose3DCenter.xy, nosePlainSize, 0.5, 1.2);\n}\nfloat getFaceMask() {\n    const vec2 sigmaScaling = vec2(1.5, 1.2);\n    return getEllipseMask(sigmaScaling, position.xy, faceCenter.xy, facePlainSize, 0.7, 0.9);\n}\nfloat getFaceMaskLeft2(vec2 point) {\n    const vec2 sigmaScaling = vec2(3.5, 1.4);\n    return getEllipseMask2(sigmaScaling, point, faceCenterLeft2.xy, facePlainSizeLeft2, 0.5, 1.3, leftAngle2);\n}\n\nfloat getFaceMaskRight2(vec2 point) {\n    const vec2 sigmaScaling = vec2(3.5, 1.4);\n    return getEllipseMask2(sigmaScaling, point, faceCenterRight2.xy, facePlainSizeRight2, 0.5, 1.3, rightAngle2);\n}\n\nvec3 getScaledFacePoint2(vec3 originalPoint, float scalingFactor, float theta, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    float sin_t = sin(theta);\n    float cos_t = cos(theta);\n    vec2 v = (originalPoint - faceCenter).xy;\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return vec3(originalPoint.xy+sc, originalPoint.z);\n}\n\nvoid main() {\n    const float pi = 3.1415926;\n\n    float faceNegativeRegionsMask = (1.0 - 0.8*getLeftEyeMask()) * (1.0 - 0.8*getRightEyeMask()) * (1.0 - 0.8*getLeftEyebrowMask()) * (1.0 - 0.8*getRightEyebrowMask()) * (1.0 - 0.6*getLipsMask()) * (1.0 - 0.9*getNoseMask());\n    //float faceNegativeRegionsMask = (1.0 - getFaceInnerMask());\n    float faceCoarseMask   = getFaceMask();\n    float faceCoarseMaskLeft2   = getFaceMaskLeft2(position.xy);\n    float faceCoarseMaskRight2   = getFaceMaskRight2(position.xy);\n    vec3 displacedFacePoint   = position.xyz;\n\n    // width\n    displacedFacePoint = getScaledFacePoint2(displacedFacePoint, faceWidth, angles.z, faceCoarseMask*faceNegativeRegionsMask);\n\n    //displacedFacePoint = getScaledFacePoint2(displacedFacePoint, faceWidth2, angles.z, faceCoarseMask2*faceNegativeRegionsMask);\n    vec3 leftPush2 = displacedFacePoint - (faceMoveCenter2 - displacedFacePoint) * 0.0 - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    vec3 rightPush2 = displacedFacePoint - (faceMoveCenter2 - displacedFacePoint) * 0.0 - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    vec2 originalPosition = (vec4(position.xyz, 1.0)).xy;\n    vec2 displacedPosition = (vec4(displacedFacePoint, 1.0)).xy;\n\n    textureCoordinate = displacedPosition;\n    gl_Position = vec4(originalPosition.x*2.0-1.0, originalPosition.y*2.0-1.0, 0.0, 1.0);\n\n    //if(faceCoarseMaskLeft2 + faceCoarseMaskRight2 > 0.0) {\n    //    textureCoordinate = vec2(1.0, 0.0);\n    //} else {\n    //    textureCoordinate = vec2(0.0, 0.0);\n    //}\n}";
  public static final String VERTEX_SHADER_VTF = "precision highp float;\n//uniform mat4 projection;\n//uniform mat4 faceFrame;\n//uniform mat4 stableToImage;\nuniform vec2 leftEyePlainSize;\nuniform vec3 leftEyeCenter;\nuniform vec2 rightEyePlainSize;\nuniform vec3 rightEyeCenter;\n\nuniform vec2 leftEyebrowPlainSize;\nuniform vec3 leftEyebrowCenter;\nuniform vec2 rightEyebrowPlainSize;\nuniform vec3 rightEyebrowCenter;\n\nuniform vec3 lipsCenter;\nuniform vec2 lipsPlainSize;\nuniform vec3 nose3DCenter; // 鼻子中心\nuniform vec2 nosePlainSize; //\nuniform vec2 facePlainSize;\nuniform vec3 faceCenter;\n\nuniform vec2 facePlainSizeLeft2;\nuniform vec3 faceCenterLeft2;\nuniform float leftAngle2;\nuniform vec2 facePlainSizeRight2;\nuniform vec3 faceCenterRight2;\nuniform float rightAngle2;\nuniform vec3 faceMoveCenter2;\n\nuniform float faceWidth;\nuniform float faceWidth2;\nattribute vec4 position;\n//attribute float faceIndex;\n//attribute float depthValue;\nvarying vec2 textureCoordinate;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\n\nuniform sampler2D inputImageTexture;\n\nfloat my_smoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(angles.z);\n    float sin_t = sin(angles.z);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - my_smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - my_smoothstep(a1, a2, d2);\n}\n\nfloat getLeftEyeMask() {\n    const vec2 sigmaScaling = vec2(1.5, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, leftEyeCenter.xy, leftEyePlainSize, 0.5, 1.2);\n}\nfloat getRightEyeMask() {\n    const vec2 sigmaScaling = vec2(1.5, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, rightEyeCenter.xy, rightEyePlainSize, 0.5, 1.2);\n}\nfloat getLeftEyebrowMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, leftEyebrowCenter.xy, leftEyebrowPlainSize, 0.5, 1.0);\n}\nfloat getRightEyebrowMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, rightEyebrowCenter.xy, rightEyebrowPlainSize, 0.5, 1.0);\n}\nhighp float getLipsMask() {\n    const highp vec2 sigmaScaling = vec2(1.5, 1.5);\n    return getEllipseMask(sigmaScaling, position.xy, lipsCenter.xy, lipsPlainSize, 0.5, 1.2);\n}\nfloat getNoseMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, nose3DCenter.xy, nosePlainSize, 0.5, 1.2);\n}\nfloat getFaceMask() {\n    const vec2 sigmaScaling = vec2(1.5, 1.2);\n    return getEllipseMask(sigmaScaling, position.xy, faceCenter.xy, facePlainSize, 0.7, 0.9);\n}\nfloat getFaceMaskLeft2(vec2 point) {\n    const vec2 sigmaScaling = vec2(3.5, 1.4);\n    return getEllipseMask2(sigmaScaling, point, faceCenterLeft2.xy, facePlainSizeLeft2, 0.5, 1.3, leftAngle2);\n}\n\nfloat getFaceMaskRight2(vec2 point) {\n    const vec2 sigmaScaling = vec2(3.5, 1.4);\n    return getEllipseMask2(sigmaScaling, point, faceCenterRight2.xy, facePlainSizeRight2, 0.5, 1.3, rightAngle2);\n}\n\nvec3 getScaledFacePoint2(vec3 originalPoint, float scalingFactor, float theta, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    float sin_t = sin(theta);\n    float cos_t = cos(theta);\n    vec2 v = (originalPoint - faceCenter).xy;\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return vec3(originalPoint.xy+sc, originalPoint.z);\n}\n\nvoid main() {\n    const float pi = 3.1415926;\n\n    float faceNegativeRegionsMask = (1.0 - 0.8*getLeftEyeMask()) * (1.0 - 0.8*getRightEyeMask()) * (1.0 - 0.8*getLeftEyebrowMask()) * (1.0 - 0.8*getRightEyebrowMask()) * (1.0 - 0.6*getLipsMask()) * (1.0 - 0.9*getNoseMask());\n    //float faceNegativeRegionsMask = (1.0 - getFaceInnerMask());\n    float faceCoarseMask   = getFaceMask();\n    float faceCoarseMaskLeft2   = getFaceMaskLeft2(position.xy);\n    float faceCoarseMaskRight2   = getFaceMaskRight2(position.xy);\n    vec3 displacedFacePoint   = position.xyz;\n\n    // width\n    displacedFacePoint = getScaledFacePoint2(displacedFacePoint, faceWidth, angles.z, faceCoarseMask*faceNegativeRegionsMask);\n\n    //displacedFacePoint = getScaledFacePoint2(displacedFacePoint, faceWidth2, angles.z, faceCoarseMask2*faceNegativeRegionsMask);\n    vec3 leftPush2 = displacedFacePoint - (faceMoveCenter2 - displacedFacePoint) * 0.0 - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    vec3 rightPush2 = displacedFacePoint - (faceMoveCenter2 - displacedFacePoint) * 0.0 - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    vec2 originalPosition = (vec4(position.xyz, 1.0)).xy;\n    vec2 displacedPosition = (vec4(displacedFacePoint, 1.0)).xy;\n    highp vec4 color = texture2D(inputImageTexture, position.xy);\n    highp vec2 offset = (color.xy * 255.0 + color.zw) / 127.5 - 1.0;\n    textureCoordinate = offset + displacedPosition - originalPosition;\n\n    gl_Position = vec4(originalPosition.x*2.0-1.0, originalPosition.y*2.0-1.0, 0.0, 1.0);\n\n    //if(faceCoarseMaskLeft2 + faceCoarseMaskRight2 > 0.0) {\n    //    textureCoordinate = vec2(1.0, 0.0);\n    //} else {\n    //    textureCoordinate = vec2(0.0, 0.0);\n    //}\n}";
  private static final int XCOORD_NUM = 128;
  private static final int YCOORD_NUM = 128;
  private static List<PointF> mFullscreenVerticesPortrait = VideoMaterialUtil.genFullScreenVertices(128, 128, 0.0F, 1.0F, 0.0F, 1.0F);
  private static List<PointF> mInitTextureCoordinatesPortrait = VideoMaterialUtil.genFullScreenVertices(128, 128, 0.0F, 1.0F, 0.0F, 1.0F);
  private float[] angles = { 0.0F, 0.0F, 0.0F };
  private float[] faceCenter = { 0.0F, 0.0F, 0.0F };
  private float[] faceCenterLeft2 = { 0.0F, 0.0F, 0.0F };
  private float[] faceCenterRight2 = { 0.0F, 0.0F, 0.0F };
  private float[] faceMoveCenter2 = { 0.0F, 0.0F, 0.0F };
  private float[] facePlainSize = { 0.0F, 0.0F };
  private float[] facePlainSizeLeft2 = { 0.0F, 0.0F };
  private float[] facePlainSizeRight2 = { 0.0F, 0.0F };
  private float faceWidth = 1.0F;
  private float faceWidth2 = 1.0F;
  private float leftAngle2 = 0.0F;
  private float[] leftEyeCenter = { 0.0F, 0.0F, 0.0F };
  private float[] leftEyePlainSize = { 0.0F, 0.0F };
  private float[] leftEyebrowCenter = { 0.0F, 0.0F, 0.0F };
  private float[] leftEyebrowPlainSize = { 0.0F, 0.0F };
  private float[] lipsCenter = { 0.0F, 0.0F, 0.0F };
  private float[] lipsPlainSize = { 0.0F, 0.0F };
  private float meshType = 0.0F;
  private float[] nose3DCenter = { 0.0F, 0.0F, 0.0F };
  private float[] nosePlainSize = { 0.0F, 0.0F };
  private float rightAngle2 = 0.0F;
  private float[] rightEyeCenter = { 0.0F, 0.0F, 0.0F };
  private float[] rightEyePlainSize = { 0.0F, 0.0F };
  private float[] rightEyebrowCenter = { 0.0F, 0.0F, 0.0F };
  private float[] rightEyebrowPlainSize = { 0.0F, 0.0F };
  private float[] size = { 1.0F, 1.0F };
  
  public ReshapeFaceWidthFilter2(ReshapeType paramReshapeType)
  {
    super("precision highp float;\n//uniform mat4 projection;\n//uniform mat4 faceFrame;\n//uniform mat4 stableToImage;\nuniform vec2 leftEyePlainSize;\nuniform vec3 leftEyeCenter;\nuniform vec2 rightEyePlainSize;\nuniform vec3 rightEyeCenter;\n\nuniform vec2 leftEyebrowPlainSize;\nuniform vec3 leftEyebrowCenter;\nuniform vec2 rightEyebrowPlainSize;\nuniform vec3 rightEyebrowCenter;\n\nuniform vec3 lipsCenter;\nuniform vec2 lipsPlainSize;\nuniform vec3 nose3DCenter; // 鼻子中心\nuniform vec2 nosePlainSize; //\nuniform vec2 facePlainSize;\nuniform vec3 faceCenter;\n\nuniform vec2 facePlainSizeLeft2;\nuniform vec3 faceCenterLeft2;\nuniform float leftAngle2;\nuniform vec2 facePlainSizeRight2;\nuniform vec3 faceCenterRight2;\nuniform float rightAngle2;\nuniform vec3 faceMoveCenter2;\n\nuniform float faceWidth;\nuniform float faceWidth2;\nattribute vec4 position;\n//attribute float faceIndex;\n//attribute float depthValue;\nvarying vec2 textureCoordinate;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\n\nuniform sampler2D inputImageTexture;\n\nfloat my_smoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(angles.z);\n    float sin_t = sin(angles.z);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - my_smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - my_smoothstep(a1, a2, d2);\n}\n\nfloat getLeftEyeMask() {\n    const vec2 sigmaScaling = vec2(1.5, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, leftEyeCenter.xy, leftEyePlainSize, 0.5, 1.2);\n}\nfloat getRightEyeMask() {\n    const vec2 sigmaScaling = vec2(1.5, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, rightEyeCenter.xy, rightEyePlainSize, 0.5, 1.2);\n}\nfloat getLeftEyebrowMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, leftEyebrowCenter.xy, leftEyebrowPlainSize, 0.5, 1.0);\n}\nfloat getRightEyebrowMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, rightEyebrowCenter.xy, rightEyebrowPlainSize, 0.5, 1.0);\n}\nhighp float getLipsMask() {\n    const highp vec2 sigmaScaling = vec2(1.5, 1.5);\n    return getEllipseMask(sigmaScaling, position.xy, lipsCenter.xy, lipsPlainSize, 0.5, 1.2);\n}\nfloat getNoseMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, nose3DCenter.xy, nosePlainSize, 0.5, 1.2);\n}\nfloat getFaceMask() {\n    const vec2 sigmaScaling = vec2(1.5, 1.2);\n    return getEllipseMask(sigmaScaling, position.xy, faceCenter.xy, facePlainSize, 0.7, 0.9);\n}\nfloat getFaceMaskLeft2(vec2 point) {\n    const vec2 sigmaScaling = vec2(3.5, 1.4);\n    return getEllipseMask2(sigmaScaling, point, faceCenterLeft2.xy, facePlainSizeLeft2, 0.5, 1.3, leftAngle2);\n}\n\nfloat getFaceMaskRight2(vec2 point) {\n    const vec2 sigmaScaling = vec2(3.5, 1.4);\n    return getEllipseMask2(sigmaScaling, point, faceCenterRight2.xy, facePlainSizeRight2, 0.5, 1.3, rightAngle2);\n}\n\nvec3 getScaledFacePoint2(vec3 originalPoint, float scalingFactor, float theta, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    float sin_t = sin(theta);\n    float cos_t = cos(theta);\n    vec2 v = (originalPoint - faceCenter).xy;\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return vec3(originalPoint.xy+sc, originalPoint.z);\n}\n\nvoid main() {\n    const float pi = 3.1415926;\n\n    float faceNegativeRegionsMask = (1.0 - 0.8*getLeftEyeMask()) * (1.0 - 0.8*getRightEyeMask()) * (1.0 - 0.8*getLeftEyebrowMask()) * (1.0 - 0.8*getRightEyebrowMask()) * (1.0 - 0.6*getLipsMask()) * (1.0 - 0.9*getNoseMask());\n    //float faceNegativeRegionsMask = (1.0 - getFaceInnerMask());\n    float faceCoarseMask   = getFaceMask();\n    float faceCoarseMaskLeft2   = getFaceMaskLeft2(position.xy);\n    float faceCoarseMaskRight2   = getFaceMaskRight2(position.xy);\n    vec3 displacedFacePoint   = position.xyz;\n\n    // width\n    displacedFacePoint = getScaledFacePoint2(displacedFacePoint, faceWidth, angles.z, faceCoarseMask*faceNegativeRegionsMask);\n\n    //displacedFacePoint = getScaledFacePoint2(displacedFacePoint, faceWidth2, angles.z, faceCoarseMask2*faceNegativeRegionsMask);\n    vec3 leftPush2 = displacedFacePoint - (faceMoveCenter2 - displacedFacePoint) * 0.0 - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    vec3 rightPush2 = displacedFacePoint - (faceMoveCenter2 - displacedFacePoint) * 0.0 - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    vec2 originalPosition = (vec4(position.xyz, 1.0)).xy;\n    vec2 displacedPosition = (vec4(displacedFacePoint, 1.0)).xy;\n\n    textureCoordinate = displacedPosition;\n    gl_Position = vec4(originalPosition.x*2.0-1.0, originalPosition.y*2.0-1.0, 0.0, 1.0);\n\n    //if(faceCoarseMaskLeft2 + faceCoarseMaskRight2 > 0.0) {\n    //    textureCoordinate = vec2(1.0, 0.0);\n    //} else {\n    //    textureCoordinate = vec2(0.0, 0.0);\n    //}\n}", "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n    //gl_FragColor = vec4(inputTextureCoordinate.xy, vec2(0.0, 1.0));\n\n    //vec4 color = vec4(textureCoordinate.x*8.0+0.5, textureCoordinate.y*8.0+0.5, 0.5, 1.0);\n    //gl_FragColor = color;\n\n    //gl_FragColor = vec4(textureCoordinate, textureCoordinate.x, 1.0);\n\n    gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n}");
    if (paramReshapeType == ReshapeType.VTF) {
      updateFilterShader("precision highp float;\n//uniform mat4 projection;\n//uniform mat4 faceFrame;\n//uniform mat4 stableToImage;\nuniform vec2 leftEyePlainSize;\nuniform vec3 leftEyeCenter;\nuniform vec2 rightEyePlainSize;\nuniform vec3 rightEyeCenter;\n\nuniform vec2 leftEyebrowPlainSize;\nuniform vec3 leftEyebrowCenter;\nuniform vec2 rightEyebrowPlainSize;\nuniform vec3 rightEyebrowCenter;\n\nuniform vec3 lipsCenter;\nuniform vec2 lipsPlainSize;\nuniform vec3 nose3DCenter; // 鼻子中心\nuniform vec2 nosePlainSize; //\nuniform vec2 facePlainSize;\nuniform vec3 faceCenter;\n\nuniform vec2 facePlainSizeLeft2;\nuniform vec3 faceCenterLeft2;\nuniform float leftAngle2;\nuniform vec2 facePlainSizeRight2;\nuniform vec3 faceCenterRight2;\nuniform float rightAngle2;\nuniform vec3 faceMoveCenter2;\n\nuniform float faceWidth;\nuniform float faceWidth2;\nattribute vec4 position;\n//attribute float faceIndex;\n//attribute float depthValue;\nvarying vec2 textureCoordinate;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\n\nuniform sampler2D inputImageTexture;\n\nfloat my_smoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(angles.z);\n    float sin_t = sin(angles.z);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - my_smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - my_smoothstep(a1, a2, d2);\n}\n\nfloat getLeftEyeMask() {\n    const vec2 sigmaScaling = vec2(1.5, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, leftEyeCenter.xy, leftEyePlainSize, 0.5, 1.2);\n}\nfloat getRightEyeMask() {\n    const vec2 sigmaScaling = vec2(1.5, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, rightEyeCenter.xy, rightEyePlainSize, 0.5, 1.2);\n}\nfloat getLeftEyebrowMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, leftEyebrowCenter.xy, leftEyebrowPlainSize, 0.5, 1.0);\n}\nfloat getRightEyebrowMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, rightEyebrowCenter.xy, rightEyebrowPlainSize, 0.5, 1.0);\n}\nhighp float getLipsMask() {\n    const highp vec2 sigmaScaling = vec2(1.5, 1.5);\n    return getEllipseMask(sigmaScaling, position.xy, lipsCenter.xy, lipsPlainSize, 0.5, 1.2);\n}\nfloat getNoseMask() {\n    const vec2 sigmaScaling = vec2(1.1, 1.0);\n    return getEllipseMask(sigmaScaling, position.xy, nose3DCenter.xy, nosePlainSize, 0.5, 1.2);\n}\nfloat getFaceMask() {\n    const vec2 sigmaScaling = vec2(1.5, 1.2);\n    return getEllipseMask(sigmaScaling, position.xy, faceCenter.xy, facePlainSize, 0.7, 0.9);\n}\nfloat getFaceMaskLeft2(vec2 point) {\n    const vec2 sigmaScaling = vec2(3.5, 1.4);\n    return getEllipseMask2(sigmaScaling, point, faceCenterLeft2.xy, facePlainSizeLeft2, 0.5, 1.3, leftAngle2);\n}\n\nfloat getFaceMaskRight2(vec2 point) {\n    const vec2 sigmaScaling = vec2(3.5, 1.4);\n    return getEllipseMask2(sigmaScaling, point, faceCenterRight2.xy, facePlainSizeRight2, 0.5, 1.3, rightAngle2);\n}\n\nvec3 getScaledFacePoint2(vec3 originalPoint, float scalingFactor, float theta, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    float sin_t = sin(theta);\n    float cos_t = cos(theta);\n    vec2 v = (originalPoint - faceCenter).xy;\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return vec3(originalPoint.xy+sc, originalPoint.z);\n}\n\nvoid main() {\n    const float pi = 3.1415926;\n\n    float faceNegativeRegionsMask = (1.0 - 0.8*getLeftEyeMask()) * (1.0 - 0.8*getRightEyeMask()) * (1.0 - 0.8*getLeftEyebrowMask()) * (1.0 - 0.8*getRightEyebrowMask()) * (1.0 - 0.6*getLipsMask()) * (1.0 - 0.9*getNoseMask());\n    //float faceNegativeRegionsMask = (1.0 - getFaceInnerMask());\n    float faceCoarseMask   = getFaceMask();\n    float faceCoarseMaskLeft2   = getFaceMaskLeft2(position.xy);\n    float faceCoarseMaskRight2   = getFaceMaskRight2(position.xy);\n    vec3 displacedFacePoint   = position.xyz;\n\n    // width\n    displacedFacePoint = getScaledFacePoint2(displacedFacePoint, faceWidth, angles.z, faceCoarseMask*faceNegativeRegionsMask);\n\n    //displacedFacePoint = getScaledFacePoint2(displacedFacePoint, faceWidth2, angles.z, faceCoarseMask2*faceNegativeRegionsMask);\n    vec3 leftPush2 = displacedFacePoint - (faceMoveCenter2 - displacedFacePoint) * 0.0 - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    vec3 rightPush2 = displacedFacePoint - (faceMoveCenter2 - displacedFacePoint) * 0.0 - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    faceCoarseMaskLeft2   = getFaceMaskLeft2(displacedFacePoint.xy);\n    faceCoarseMaskRight2   = getFaceMaskRight2(displacedFacePoint.xy);\n    leftPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterLeft2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, leftPush2, faceCoarseMaskLeft2 * faceWidth2);\n    rightPush2 = displacedFacePoint - (faceMoveCenter2 - faceCenterRight2)* 0.1;\n    displacedFacePoint = mix(displacedFacePoint, rightPush2, faceCoarseMaskRight2 * faceWidth2);\n\n    vec2 originalPosition = (vec4(position.xyz, 1.0)).xy;\n    vec2 displacedPosition = (vec4(displacedFacePoint, 1.0)).xy;\n    highp vec4 color = texture2D(inputImageTexture, position.xy);\n    highp vec2 offset = (color.xy * 255.0 + color.zw) / 127.5 - 1.0;\n    textureCoordinate = offset + displacedPosition - originalPosition;\n\n    gl_Position = vec4(originalPosition.x*2.0-1.0, originalPosition.y*2.0-1.0, 0.0, 1.0);\n\n    //if(faceCoarseMaskLeft2 + faceCoarseMaskRight2 > 0.0) {\n    //    textureCoordinate = vec2(1.0, 0.0);\n    //} else {\n    //    textureCoordinate = vec2(0.0, 0.0);\n    //}\n}", "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n\n    //vec2 diffPosition = textureCoordinate;\n    //float ddx = (diffPosition.x + 1.0) / 2.0;\n    //float ddy = (diffPosition.y + 1.0) / 2.0;\n    //diffPosition = vec2(ddx,ddy);\n    //vec2 a = fract(diffPosition * 255.0 / 256.0);\n    //vec2 b = fract(diffPosition * 255.0 * 255.0 / 256.0);\n    //gl_FragColor = vec4(a,b);\n\n    // 新版的 shader 颜色通道中记录的是位移偏移量，只有在最后 combinedFilter 才最终将所有 filter 的位移量叠加，去图上取点。这样的好处是：\n    // 1. 只有 128 * 128 个点\n    // 2. smoothstep 会更平滑，128 * 128 个点取插值，原来的处理方法会使像素点变模糊\n    // 3. 两个矩形交叠的地方，位移处理的先后顺序不影响结果（不能说这是好还是坏，因为 PS 的液化是作用在原图上的）\n\n    // 至于此处要改为 * 255 再 / 255 是为了提升精度（浮点纹理 iOS 不支持，而一个字节只能表示 256 个不同值）\n    // 本来小奇使用了浮点纹理，但是发现有机型不支持，不用浮点纹理又精度不够，所以采用这个方法，变成2个字节表示一个值，提升了精度。\n    vec2 diffPosition = textureCoordinate;\n    diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;  // 0.5 * (diffPosition + 1.0) 是将(-1, 1)间的值转换到(0, 1)，\n    vec2 a = floor(diffPosition) / 255.0;\n    vec2 b = fract(diffPosition);\n    gl_FragColor = vec4(a, b);\n\n\n    //vec2 diffPosition = textureCoordinate;\n    //diffPosition = 0.5 * (diffPosition + 1.0) * 256.0;\n    //vec2 a = floor(diffPosition) / 256.0;\n    //vec2 b = fract(diffPosition);\n    //gl_FragColor = vec4(a, b);\n}\n");
    }
    if (paramReshapeType == ReshapeType.NORMAL) {
      f = 0.5F;
    }
    this.meshType = f;
    initParams();
  }
  
  public void ApplyGLSLFilter()
  {
    initParams();
    super.ApplyGLSLFilter();
    setDrawMode(AEOpenRenderConfig.DRAW_MODE.TRIANGLE_STRIP);
  }
  
  public void initAttribParams()
  {
    setPositions(VideoMaterialUtil.toFlatArray((PointF[])mFullscreenVerticesPortrait.toArray(new PointF[0])), false);
    setTexCords(VideoMaterialUtil.toFlatArray((PointF[])mInitTextureCoordinatesPortrait.toArray(new PointF[0])), false);
    setCoordNum(32897);
  }
  
  public void initParams()
  {
    addParam(new UniformParam.FloatsParam("leftEyePlainSize", this.leftEyePlainSize));
    addParam(new UniformParam.FloatsParam("leftEyeCenter", this.leftEyeCenter));
    addParam(new UniformParam.FloatsParam("rightEyePlainSize", this.rightEyePlainSize));
    addParam(new UniformParam.FloatsParam("rightEyeCenter", this.rightEyeCenter));
    addParam(new UniformParam.FloatsParam("leftEyebrowPlainSize", this.leftEyebrowPlainSize));
    addParam(new UniformParam.FloatsParam("leftEyebrowCenter", this.leftEyebrowCenter));
    addParam(new UniformParam.FloatsParam("rightEyebrowPlainSize", this.rightEyebrowPlainSize));
    addParam(new UniformParam.FloatsParam("rightEyebrowCenter", this.rightEyebrowCenter));
    addParam(new UniformParam.FloatsParam("nose3DCenter", this.nose3DCenter));
    addParam(new UniformParam.FloatsParam("nosePlainSize", this.nosePlainSize));
    addParam(new UniformParam.FloatsParam("lipsCenter", this.lipsCenter));
    addParam(new UniformParam.FloatsParam("lipsPlainSize", this.lipsPlainSize));
    addParam(new UniformParam.FloatsParam("facePlainSize", this.facePlainSize));
    addParam(new UniformParam.FloatsParam("faceCenter", this.faceCenter));
    addParam(new UniformParam.FloatsParam("facePlainSizeLeft2", this.facePlainSizeLeft2));
    addParam(new UniformParam.FloatsParam("faceCenterLeft2", this.faceCenterLeft2));
    addParam(new UniformParam.FloatParam("leftAngle2", this.leftAngle2));
    addParam(new UniformParam.FloatsParam("facePlainSizeRight2", this.facePlainSizeRight2));
    addParam(new UniformParam.FloatsParam("faceCenterRight2", this.faceCenterRight2));
    addParam(new UniformParam.FloatParam("rightAngle2", this.rightAngle2));
    addParam(new UniformParam.FloatsParam("faceMoveCenter2", this.faceMoveCenter2));
    addParam(new UniformParam.FloatParam("faceWidth", this.faceWidth));
    addParam(new UniformParam.FloatParam("faceWidth2", this.faceWidth2));
    addParam(new UniformParam.FloatsParam("angles", this.angles));
    addParam(new UniformParam.FloatsParam("size", this.size));
    addParam(new UniformParam.FloatParam("meshType", this.meshType));
  }
  
  public void setParam(Map<String, Object> paramMap)
  {
    if (paramMap.containsKey("leftEyePlainSize")) {
      this.leftEyePlainSize = ((float[])paramMap.get("leftEyePlainSize"));
    }
    if (paramMap.containsKey("leftEyeCenter")) {
      this.leftEyeCenter = ((float[])paramMap.get("leftEyeCenter"));
    }
    if (paramMap.containsKey("rightEyePlainSize")) {
      this.rightEyePlainSize = ((float[])paramMap.get("rightEyePlainSize"));
    }
    if (paramMap.containsKey("rightEyeCenter")) {
      this.rightEyeCenter = ((float[])paramMap.get("rightEyeCenter"));
    }
    if (paramMap.containsKey("leftEyebrowPlainSize")) {
      this.leftEyebrowPlainSize = ((float[])paramMap.get("leftEyebrowPlainSize"));
    }
    if (paramMap.containsKey("leftEyebrowCenter")) {
      this.leftEyebrowCenter = ((float[])paramMap.get("leftEyebrowCenter"));
    }
    if (paramMap.containsKey("rightEyebrowPlainSize")) {
      this.rightEyebrowPlainSize = ((float[])paramMap.get("rightEyebrowPlainSize"));
    }
    if (paramMap.containsKey("rightEyebrowCenter")) {
      this.rightEyebrowCenter = ((float[])paramMap.get("rightEyebrowCenter"));
    }
    if (paramMap.containsKey("nose3DCenter")) {
      this.nose3DCenter = ((float[])paramMap.get("nose3DCenter"));
    }
    if (paramMap.containsKey("nosePlainSize")) {
      this.nosePlainSize = ((float[])paramMap.get("nosePlainSize"));
    }
    if (paramMap.containsKey("lipsCenter")) {
      this.lipsCenter = ((float[])paramMap.get("lipsCenter"));
    }
    if (paramMap.containsKey("lipsPlainSize")) {
      this.lipsPlainSize = ((float[])paramMap.get("lipsPlainSize"));
    }
    if (paramMap.containsKey("facePlainSize")) {
      this.facePlainSize = ((float[])paramMap.get("facePlainSize"));
    }
    if (paramMap.containsKey("faceCenter")) {
      this.faceCenter = ((float[])paramMap.get("faceCenter"));
    }
    if (paramMap.containsKey("facePlainSizeLeft2")) {
      this.facePlainSizeLeft2 = ((float[])paramMap.get("facePlainSizeLeft2"));
    }
    if (paramMap.containsKey("faceCenterLeft2")) {
      this.faceCenterLeft2 = ((float[])paramMap.get("faceCenterLeft2"));
    }
    if (paramMap.containsKey("leftAngle2")) {
      this.leftAngle2 = ((Float)paramMap.get("leftAngle2")).floatValue();
    }
    if (paramMap.containsKey("facePlainSizeRight2")) {
      this.facePlainSizeRight2 = ((float[])paramMap.get("facePlainSizeRight2"));
    }
    if (paramMap.containsKey("faceCenterRight2")) {
      this.faceCenterRight2 = ((float[])paramMap.get("faceCenterRight2"));
    }
    if (paramMap.containsKey("rightAngle2")) {
      this.rightAngle2 = ((Float)paramMap.get("rightAngle2")).floatValue();
    }
    if (paramMap.containsKey("faceMoveCenter2")) {
      this.faceMoveCenter2 = ((float[])paramMap.get("faceMoveCenter2"));
    }
    if (paramMap.containsKey("faceWidth"))
    {
      this.faceWidth = (((Float)paramMap.get("faceWidth")).floatValue() * 0.0012F);
      if (this.faceWidth > 0.0F) {
        this.faceWidth *= 1.15F;
      }
    }
    if (paramMap.containsKey("faceWidth2"))
    {
      this.faceWidth2 = (((Float)paramMap.get("faceWidth2")).floatValue() * 0.0017F);
      if (this.faceWidth2 > 0.0F) {
        this.faceWidth2 *= 1.15F;
      }
    }
    if (paramMap.containsKey("angles")) {
      this.angles = ((float[])paramMap.get("angles"));
    }
    if (paramMap.containsKey("size")) {
      this.size = ((float[])paramMap.get("size"));
    }
    initParams();
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.tim\classes12.jar
 * Qualified Name:     com.tencent.ttpic.openapi.filter.ReshapeFaceWidthFilter2
 * JD-Core Version:    0.7.0.1
 */