package com.tencent.ttpic.openapi.filter;

import com.tencent.aekit.openrender.UniformParam.Float2fParam;
import com.tencent.aekit.openrender.UniformParam.FloatParam;
import com.tencent.aekit.openrender.internal.Frame;
import com.tencent.filter.BaseFilter;

public class HighPassSharpenFilter
  extends BaseFilter
{
  private static final String FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n varying highp vec2 textureCoordsLU;\n varying highp vec2 textureCoordsU;\n varying highp vec2 textureCoordsRU;\n varying highp vec2 textureCoordsL;\n varying highp vec2 textureCoordsR;\n varying highp vec2 textureCoordsLD;\n varying highp vec2 textureCoordsD;\n varying highp vec2 textureCoordsRD;\n \n uniform sampler2D inputImageTexture;\n uniform highp vec2 canvasSize;\n uniform lowp float alpha;\n \n lowp vec3 sharpenColor(lowp vec3 mixColor, lowp vec3 iColor, highp float mixAlpha) {\n     highp vec2 stepX_1 = vec2(1.0 / canvasSize.x, 0.0);\n     highp vec2 stepY_1 = vec2(0.0, 1.0 / canvasSize.y);\n     highp vec2 stepX_2 = vec2(2.0 / canvasSize.x, 0.0);\n     highp vec2 stepY_2 = vec2(0.0, 2.0 / canvasSize.y);\n     \n     highp vec3 mean = vec3(0.0);//iColor.rgb;\n     mean += texture2D(inputImageTexture, textureCoordsU).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsL).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsR).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsD).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsLU).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsRU).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsLD).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsRD).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_2+stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_1+stepY_2).rgb;\n     mean += texture2D(inputImageTexture, textureCoordinate+stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_1+stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_2+stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_2+stepY_1).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_2+stepY_1).rgb;\n     mean += texture2D(inputImageTexture, textureCoordinate-stepX_2).rgb;\n     mean += texture2D(inputImageTexture, textureCoordinate+stepX_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_2-stepY_1).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_2-stepY_1).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_2-stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_1-stepY_2).rgb;\n     mean += texture2D(inputImageTexture, textureCoordinate-stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_1-stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_2-stepY_2).rgb;\n     mean /= 12.0;\n     \n     highp vec3 hPass = iColor.rgb - mean;\n     highp vec3 sColor = clamp((mixColor + hPass * mixAlpha), vec3(0.0), vec3(1.0));\n     return sColor;\n }\n \n void main() {\n     lowp vec4 iColor = texture2D(inputImageTexture, textureCoordinate);\n     \n     lowp vec3 sColor = sharpenColor(iColor.rgb, iColor.rgb, alpha);\n     \n     gl_FragColor = vec4(sColor.rgb, iColor.a);\n }\n";
  private static final String VERTEX_SHADER = "attribute vec4 position;\n attribute vec4 inputTextureCoordinate;\n \n uniform vec2 canvasSize;\n \n varying vec2 textureCoordinate;\n varying vec2 textureCoordsLU;\n varying vec2 textureCoordsU;\n varying vec2 textureCoordsRU;\n varying vec2 textureCoordsL;\n varying vec2 textureCoordsR;\n varying vec2 textureCoordsLD;\n varying vec2 textureCoordsD;\n varying vec2 textureCoordsRD;\n \n void main()\n {\n     highp float stepX = 1.0 / canvasSize.x;\n     highp float stepY = 1.0 / canvasSize.y;\n     \n     gl_Position = position;\n     textureCoordinate = inputTextureCoordinate.xy;\n     textureCoordsLU = vec2(textureCoordinate.x-stepX, textureCoordinate.y+stepY);\n     textureCoordsU = vec2(textureCoordinate.x, textureCoordinate.y+stepY);\n     textureCoordsRU = vec2(textureCoordinate.x+stepX, textureCoordinate.y+stepY);\n     textureCoordsL = vec2(textureCoordinate.x-stepX, textureCoordinate.y);\n     textureCoordsR = vec2(textureCoordinate.x+stepX, textureCoordinate.y);\n     textureCoordsLD = vec2(textureCoordinate.x-stepX, textureCoordinate.y-stepY);\n     textureCoordsD = vec2(textureCoordinate.x, textureCoordinate.y-stepY);\n     textureCoordsRD = vec2(textureCoordinate.x+stepX, textureCoordinate.y-stepY);\n }\n";
  private float mAlpha = 0.0F;
  
  public HighPassSharpenFilter()
  {
    super("attribute vec4 position;\n attribute vec4 inputTextureCoordinate;\n \n uniform vec2 canvasSize;\n \n varying vec2 textureCoordinate;\n varying vec2 textureCoordsLU;\n varying vec2 textureCoordsU;\n varying vec2 textureCoordsRU;\n varying vec2 textureCoordsL;\n varying vec2 textureCoordsR;\n varying vec2 textureCoordsLD;\n varying vec2 textureCoordsD;\n varying vec2 textureCoordsRD;\n \n void main()\n {\n     highp float stepX = 1.0 / canvasSize.x;\n     highp float stepY = 1.0 / canvasSize.y;\n     \n     gl_Position = position;\n     textureCoordinate = inputTextureCoordinate.xy;\n     textureCoordsLU = vec2(textureCoordinate.x-stepX, textureCoordinate.y+stepY);\n     textureCoordsU = vec2(textureCoordinate.x, textureCoordinate.y+stepY);\n     textureCoordsRU = vec2(textureCoordinate.x+stepX, textureCoordinate.y+stepY);\n     textureCoordsL = vec2(textureCoordinate.x-stepX, textureCoordinate.y);\n     textureCoordsR = vec2(textureCoordinate.x+stepX, textureCoordinate.y);\n     textureCoordsLD = vec2(textureCoordinate.x-stepX, textureCoordinate.y-stepY);\n     textureCoordsD = vec2(textureCoordinate.x, textureCoordinate.y-stepY);\n     textureCoordsRD = vec2(textureCoordinate.x+stepX, textureCoordinate.y-stepY);\n }\n", "varying highp vec2 textureCoordinate;\n varying highp vec2 textureCoordsLU;\n varying highp vec2 textureCoordsU;\n varying highp vec2 textureCoordsRU;\n varying highp vec2 textureCoordsL;\n varying highp vec2 textureCoordsR;\n varying highp vec2 textureCoordsLD;\n varying highp vec2 textureCoordsD;\n varying highp vec2 textureCoordsRD;\n \n uniform sampler2D inputImageTexture;\n uniform highp vec2 canvasSize;\n uniform lowp float alpha;\n \n lowp vec3 sharpenColor(lowp vec3 mixColor, lowp vec3 iColor, highp float mixAlpha) {\n     highp vec2 stepX_1 = vec2(1.0 / canvasSize.x, 0.0);\n     highp vec2 stepY_1 = vec2(0.0, 1.0 / canvasSize.y);\n     highp vec2 stepX_2 = vec2(2.0 / canvasSize.x, 0.0);\n     highp vec2 stepY_2 = vec2(0.0, 2.0 / canvasSize.y);\n     \n     highp vec3 mean = vec3(0.0);//iColor.rgb;\n     mean += texture2D(inputImageTexture, textureCoordsU).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsL).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsR).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsD).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsLU).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsRU).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsLD).rgb;\n     mean += texture2D(inputImageTexture, textureCoordsRD).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_2+stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_1+stepY_2).rgb;\n     mean += texture2D(inputImageTexture, textureCoordinate+stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_1+stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_2+stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_2+stepY_1).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_2+stepY_1).rgb;\n     mean += texture2D(inputImageTexture, textureCoordinate-stepX_2).rgb;\n     mean += texture2D(inputImageTexture, textureCoordinate+stepX_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_2-stepY_1).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_2-stepY_1).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_2-stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate-stepX_1-stepY_2).rgb;\n     mean += texture2D(inputImageTexture, textureCoordinate-stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_1-stepY_2).rgb;\n     //mean += texture2D(inputImageTexture, textureCoordinate+stepX_2-stepY_2).rgb;\n     mean /= 12.0;\n     \n     highp vec3 hPass = iColor.rgb - mean;\n     highp vec3 sColor = clamp((mixColor + hPass * mixAlpha), vec3(0.0), vec3(1.0));\n     return sColor;\n }\n \n void main() {\n     lowp vec4 iColor = texture2D(inputImageTexture, textureCoordinate);\n     \n     lowp vec3 sColor = sharpenColor(iColor.rgb, iColor.rgb, alpha);\n     \n     gl_FragColor = vec4(sColor.rgb, iColor.a);\n }\n");
    initParams();
  }
  
  private void initParams()
  {
    addParam(new UniformParam.Float2fParam("canvasSize", 720.0F, 960.0F));
    addParam(new UniformParam.FloatParam("alpha", 0.0F));
  }
  
  public Frame render(Frame paramFrame)
  {
    if (this.mAlpha == 0.0F) {
      return paramFrame;
    }
    return super.RenderProcess(paramFrame.getTextureId(), paramFrame.width, paramFrame.height);
  }
  
  public void setAlpha(float paramFloat)
  {
    addParam(new UniformParam.FloatParam("alpha", paramFloat * 2.0F));
    this.mAlpha = (paramFloat * 2.0F);
  }
  
  public void setCanvasSize(int paramInt1, int paramInt2)
  {
    addParam(new UniformParam.Float2fParam("canvasSize", paramInt1, paramInt2));
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.tim\classes12.jar
 * Qualified Name:     com.tencent.ttpic.openapi.filter.HighPassSharpenFilter
 * JD-Core Version:    0.7.0.1
 */