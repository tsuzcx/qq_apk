package com.tencent.ttpic.filter.shader;

public abstract interface ShaderContentConstans
{
  public static final String ALPHA_FRAME_SHADER_DAT = "precision highp float;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform float alpha;\n\nvoid main()\n{\n    vec4 color = texture2D (inputImageTexture, textureCoordinate);\n    gl_FragColor = vec4 (color.rgb * color.a * alpha, color.a * alpha);\n}";
  public static final String ALPHA_VERTEX_SHADER_DAT = "precision highp float;\nattribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 textureCoordinate;\n\nuniform float texScale;\nuniform float texRotate;\nuniform vec2 anchor;\nuniform vec2 translate;\nuniform vec2 canvasSize;\n\nconst float PI = 3.14159;\n\nmat4 texMatScale = mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatRotate = mat4(1.0, 0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0, 1.0);\n\nmat4 mat4RotationYXZ(mat4 m, float xRadians, float yRadians, float zRadians) {\n    /*\n     |  cycz + sxsysz   czsxsy - cysz   cxsy  0 |\n M = |  cxsz            cxcz           -sx    0 |\n     |  cysxsz - czsy   cyczsx + sysz   cxcy  0 |\n     |  0               0               0     1 |\n\n     where cA = cos(A), sA = sin(A) for A = x,y,z\n     */\n\n    float cx = cos(xRadians);\n    float sx = sin(xRadians);\n    float cy = cos(yRadians);\n    float sy = sin(yRadians);\n    float cz = cos(zRadians);\n    float sz = sin(zRadians);\n\n    m[0][0] = (cy * cz) + (sx * sy * sz);\n    m[0][1] = cx * sz;\n    m[0][2] = (cy * sx * sz) - (cz * sy);\n    m[0][3] = 0.0;\n\n    m[1][0] = (cz * sx * sy) - (cy * sz);\n    m[1][1] = cx * cz;\n    m[1][2] = (cy * cz * sx) + (sy * sz);\n    m[1][3] = 0.0;\n\n    m[2][0] = cx * sy;\n    m[2][1] = -sx;\n    m[2][2] = cx * cy;\n    m[2][3] = 0.0;\n\n    m[3][0] = 0.0;\n    m[3][1] = 0.0;\n    m[3][2] = 0.0;\n    m[3][3] = 1.0;\n\n    return m;\n}\n\nvoid main(){\n    vec4 framePos = position;\n    framePos.xy = framePos.xy - anchor;\n\n    framePos.x *= canvasSize.x;\n    framePos.y *= canvasSize.y;\n\n    texMatScale[0][0] = texScale;\n    texMatScale[1][1] = texScale;\n\n    texMatRotate = mat4RotationYXZ(texMatRotate, 0.0, 0.0, texRotate);\n\n    framePos = texMatRotate * texMatScale * framePos;\n\n    framePos.x /= canvasSize.x;\n    framePos.y /= canvasSize.y;\n\n    framePos.xy = framePos.xy + anchor + translate;\n\n    gl_Position = framePos;\n    textureCoordinate = inputTextureCoordinate;\n}";
  public static final String CFFACE_OFF_FRAGMENT_SHADER_DAT = " precision mediump float;\n varying highp vec2 textureCoordinate;\n varying highp vec2 textureCoordinate2;\n varying highp vec2 textureCoordinate3;\n uniform sampler2D inputImageTexture;\n uniform sampler2D inputImageTexture2;\n uniform sampler2D inputImageTexture3;\n\n uniform int drawTypeFragment;\n uniform float alphaBlend;\n\n uniform vec3 userColor1;\n uniform vec3 userColor2;\n uniform vec3 modelColor1;\n uniform vec3 modelColor2;\n\n vec3 refineColorOld(vec3 userColor) {\n     float resR;\n     float resG;\n     float resB;\n     if (userColor.r <= userColor1.r) {\n         resR = userColor.r + (modelColor1.r - userColor1.r) * (userColor.r / userColor1.r);\n     } else {\n         resR = userColor.r + (modelColor1.r - userColor1.r) * ((1.0 - userColor.r) / (1.0 - userColor1.r));\n     }\n     if (userColor.g <= userColor1.g) {\n         resG = userColor.g + (modelColor1.g - userColor1.g) * (userColor.g / userColor1.g);\n     } else {\n         resG = userColor.g + (modelColor1.g - userColor1.g) * ((1.0 - userColor.g) / (1.0 - userColor1.g));\n     }\n     if (userColor.b <= userColor1.b) {\n         resB = userColor.b + (modelColor1.b - userColor1.b) * (userColor.b / userColor1.b);\n     } else {\n         resB = userColor.b + (modelColor1.b - userColor1.b) * ((1.0 - userColor.b) / (1.0 - userColor1.b));\n     }\n     return vec3(resR,resG,resB);\n }\n vec3 refineColorNew(vec3 userColor) {\n     float resR;\n     float resG;\n     float resB;\n     if (userColor.r <= userColor1.r) {\n         resR = modelColor1.r * userColor.r / userColor1.r;\n     } else {\n         resR = modelColor1.r + (modelColor2.r - modelColor1.r) * (userColor.r - userColor1.r) / (userColor2.r - userColor1.r);\n     }\n     if (userColor.g <= userColor1.g) {\n         resG = modelColor1.g * userColor.g / userColor1.g;\n     } else {\n         resG = modelColor1.g + (modelColor2.g - modelColor1.g) * (userColor.g - userColor1.g) / (userColor2.g - userColor1.g);\n     }\n     if (userColor.b <= userColor1.b) {\n         resB = modelColor1.b * userColor.b / userColor1.b;\n     } else {\n         resB = modelColor1.b + (modelColor2.b - modelColor1.b) * (userColor.b - userColor1.b) / (userColor2.b - userColor1.b);\n     }\n     return vec3(resR,resG,resB);\n }\n void main(void) {\n     if (drawTypeFragment == 0){\n         gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n         return;\n     }\n\n     vec4 modelColor = texture2D(inputImageTexture, textureCoordinate);\n     vec4 userColor = texture2D(inputImageTexture2, textureCoordinate2);\n\n     vec3 uColor = userColor.rgb;\n     if (drawTypeFragment == 1) {\n         uColor = refineColorOld(userColor.rgb);\n     } else if (drawTypeFragment == 2) {\n         uColor = refineColorNew(userColor.rgb);\n     }\n     userColor = vec4(clamp(uColor, 0.0, 1.0), 1.0);\n\n     vec4 grayColor = texture2D(inputImageTexture3, textureCoordinate3);\n\n     float xAlpha = alphaBlend + (1.0 - alphaBlend) * grayColor.r;\n     vec3 resultColor = mix(userColor.rgb, modelColor.rgb, xAlpha);\n\n     gl_FragColor = vec4(resultColor, modelColor.a);\n }";
  public static final String CFFACE_OFF_VERTEX_SHADER_DAT = " attribute vec4 position;\n attribute vec4 inputTextureCoordinate;\n varying vec2 textureCoordinate;\n\n attribute vec4 inputTextureCoordinate2;\n varying vec2 textureCoordinate2;\n\n attribute vec4 inputTextureCoordinate3;\n varying vec2 textureCoordinate3;\n\n void main(void) {\n     gl_Position = position;\n     textureCoordinate = inputTextureCoordinate.xy;\n     textureCoordinate2 = inputTextureCoordinate2.xy;\n     textureCoordinate3 = inputTextureCoordinate3.xy;\n }";
  public static final String CFTRANSFORM_FRAGMENT_SHADER_DAT = "precision highp float;\n varying vec2 textureCoordinate;\n varying vec2 textureCoordinate2;\n uniform lowp sampler2D inputImageTexture;\n uniform lowp sampler2D inputImageTexture2;\n\n uniform lowp float alphaBlend;\n\n void main()\n {\n     vec4 color1 = vec4(0.0, 0.0, 0.0, 1.0);\n     vec4 color2 = vec4(0.0, 0.0, 0.0, 1.0);\n     if (textureCoordinate.x >= 0.0 && textureCoordinate.x <= 1.0 && textureCoordinate.y >= 0.0 && textureCoordinate.y <= 1.0) {\n         color1 = texture2D(inputImageTexture,textureCoordinate);\n     }\n     if (textureCoordinate2.x >= 0.0 && textureCoordinate2.x <= 1.0 && textureCoordinate2.y >= 0.0 && textureCoordinate2.y <= 1.0) {\n         color2 = texture2D(inputImageTexture2,textureCoordinate2);\n     }\n\n     gl_FragColor = color1 * (1.0 - alphaBlend) + color2 * alphaBlend;\n }";
  public static final String CFTRANSFORM_VERTEX_SHADER_DAT = " precision highp float;\n attribute vec4 position;\n attribute vec2 inputTextureCoordinate;\n attribute vec2 inputTextureCoordinate2;\n varying vec2 textureCoordinate;\n varying vec2 textureCoordinate2;\n void main(){\n     gl_Position = position;\n     textureCoordinate = inputTextureCoordinate;\n     textureCoordinate2 = inputTextureCoordinate2;\n }";
  public static final String CFXFACE_OFF_FRAGMENT_SHADER_DAT = " precision mediump float;\n varying highp vec2 textureCoordinate;\n varying highp vec2 textureCoordinate2;\n varying highp vec2 textureCoordinate3;\n uniform sampler2D inputImageTexture;\n uniform sampler2D inputImageTexture2;\n uniform sampler2D inputImageTexture3;\n uniform sampler2D inputImageTexture4;\n uniform sampler2D inputImageTexture5;\n uniform sampler2D inputImageTexture6;\n\n uniform int refineType;\n uniform float alphaBlend;\n uniform vec4 optType;\n uniform int outputType;\n\n uniform vec3 userColor1;\n uniform vec3 userColor2;\n uniform vec3 modelColor1;\n uniform vec3 modelColor2;\n\n vec3 refineColorOld(vec3 userColor) {\n     float resR;\n     float resG;\n     float resB;\n     if (userColor.r <= userColor1.r) {\n         resR = userColor.r + (modelColor1.r - userColor1.r) * (userColor.r / userColor1.r);\n     } else {\n         resR = userColor.r + (modelColor1.r - userColor1.r) * ((1.0 - userColor.r) / (1.0 - userColor1.r));\n     }\n     if (userColor.g <= userColor1.g) {\n         resG = userColor.g + (modelColor1.g - userColor1.g) * (userColor.g / userColor1.g);\n     } else {\n         resG = userColor.g + (modelColor1.g - userColor1.g) * ((1.0 - userColor.g) / (1.0 - userColor1.g));\n     }\n     if (userColor.b <= userColor1.b) {\n         resB = userColor.b + (modelColor1.b - userColor1.b) * (userColor.b / userColor1.b);\n     } else {\n         resB = userColor.b + (modelColor1.b - userColor1.b) * ((1.0 - userColor.b) / (1.0 - userColor1.b));\n     }\n     return vec3(resR,resG,resB);\n }\n vec3 refineColorNew(vec3 userColor) {\n     float resR;\n     float resG;\n     float resB;\n     if (userColor.r <= userColor1.r) {\n         resR = modelColor1.r * userColor.r / userColor1.r;\n     } else {\n         resR = modelColor1.r + (modelColor2.r - modelColor1.r) * (userColor.r - userColor1.r) / (userColor2.r - userColor1.r);\n     }\n     if (userColor.g <= userColor1.g) {\n         resG = modelColor1.g * userColor.g / userColor1.g;\n     } else {\n         resG = modelColor1.g + (modelColor2.g - modelColor1.g) * (userColor.g - userColor1.g) / (userColor2.g - userColor1.g);\n     }\n     if (userColor.b <= userColor1.b) {\n         resB = modelColor1.b * userColor.b / userColor1.b;\n     } else {\n         resB = modelColor1.b + (modelColor2.b - modelColor1.b) * (userColor.b - userColor1.b) / (userColor2.b - userColor1.b);\n     }\n     return vec3(resR,resG,resB);\n }\n void main(void) {\n     vec4 modelColor = texture2D(inputImageTexture, textureCoordinate);\n     if (outputType == 0){\n         gl_FragColor = modelColor;\n         return;\n     }\n     vec4 userColor = texture2D(inputImageTexture2, textureCoordinate2);\n     vec4 grayColor = texture2D(inputImageTexture3, textureCoordinate3);\n     vec4 irisColor = texture2D(inputImageTexture4, textureCoordinate3);\n     vec4 skinColor = texture2D(inputImageTexture5, textureCoordinate3);\n     vec4 protectColor = texture2D(inputImageTexture6, textureCoordinate3);\n\n     vec3 uColor = userColor.rgb;\n     if (refineType == 1) {\n         uColor = refineColorOld(userColor.rgb);\n     } else if (refineType == 2) {\n         uColor = refineColorNew(userColor.rgb);\n     }\n     userColor = vec4(clamp(uColor, 0.0, 1.0), 1.0);\n\n     float xAlpha = (1.0 - alphaBlend) * grayColor.r;   //模版的部分alpha\n     if (optType.r > 0.5 && optType.r < 1.5) {  //需要瞳孔优化\n         xAlpha += alphaBlend * irisColor.r;\n     } else {\n         xAlpha += alphaBlend;\n     }\n     if (optType.g > 0.5 && optType.g < 1.5) {  //需要去刘海\n         float distR = uColor.r - modelColor.r;\n         float distG = uColor.g - modelColor.g;\n         float distB = uColor.b - modelColor.b;\n\n         float distSrcDst = (distR * distR + distG * distG + distB * distB) / 3.0;\n         distSrcDst = ttpicsqrt(distSrcDst);\n         distSrcDst = smoothstep(0.1, 0.55, distSrcDst);\n         xAlpha = 1.0 - (1.0 - xAlpha) * (1.0 - distSrcDst * protectColor.r);\n         if (skinColor.r > 0.5 && grayColor.r < 0.5) {\n             xAlpha = 2.2 * xAlpha;\n             if (xAlpha > 0.9) xAlpha = 0.9;\n         }\n         if (irisColor.r < 0.95) {  //瞳孔保护\n             xAlpha = 0.0;\n         }\n     }\n     if (outputType == 2){\n         gl_FragColor = vec4(xAlpha, xAlpha, xAlpha, 1.0);\n     } else {\n         vec3 resultColor = userColor.rgb * (1.0 - xAlpha) + modelColor.rgb * xAlpha;\n         gl_FragColor = vec4(resultColor, modelColor.a);\n     }\n }";
  public static final String DOODLE_FRAGMENT_SHADER_DAT = " precision highp float;\n varying vec2 TexCoordOut;\n\n void main(void) {\n     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n }";
  public static final String DOODLE_VERTEX_SHADER_DAT = "attribute vec4 position;\nvarying vec2 TexCoordOut;\n\nvoid main() {\n    gl_Position = position;\n    TexCoordOut = position.xy;\n}\n";
  public static final String EMOJI_VERTEX_SHADER_DAT = "precision highp float;\nattribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 textureCoordinate;\n\nuniform vec2 canvasSize;\nuniform vec2 texAnchor;\nuniform vec2 texOffset;\nuniform float texScale;\nuniform float texXAdjustScale;\nuniform float texYAdjustScale;\n\nmat4 texMatTranslateBefore = mat4(1.0, 0.0, 0.0, 0.0,\n                                  0.0, 1.0, 0.0, 0.0,\n                                  0.0, 0.0, 1.0, 0.0,\n                                  0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatScale = mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatTranslateAfter = mat4(1.0, 0.0, 0.0, 0.0,\n                                 0.0, 1.0, 0.0, 0.0,\n                                 0.0, 0.0, 1.0, 0.0,\n                                 0.0, 0.0, 0.0, 1.0);\n\nvoid main(){\n    vec4 framePos = position;\n    framePos.x = framePos.x * canvasSize.x * 0.5;\n    framePos.y = framePos.y * canvasSize.y * 0.5;\n\n    texMatTranslateBefore[3][0] = -texAnchor.x;\n    texMatTranslateBefore[3][1] = -texAnchor.y;\n\n    texMatScale[0][0] = texScale * texXAdjustScale;\n    texMatScale[1][1] = texScale * texYAdjustScale;\n\n    texMatTranslateAfter[3][0] = texAnchor.x + texOffset.x;\n    texMatTranslateAfter[3][1] = texAnchor.y + texOffset.y;\n\n    framePos = texMatTranslateAfter * texMatScale * texMatTranslateBefore * framePos;\n\n    framePos.x = framePos.x * 2.0 / canvasSize.x;\n    framePos.y = framePos.y * 2.0 / canvasSize.y;\n\n    gl_Position = framePos;\n    textureCoordinate = inputTextureCoordinate;\n}";
  public static final String FACE_SWITCH_FRAGMENT_SHADER_DAT = "//Need Sync FaceOffFragmentShaderExt.dat\nprecision highp float;\nvarying vec2 canvasCoordinate;\nvarying vec2 textureCoordinate;\nvarying vec2 grayTextureCoordinate;\n\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform sampler2D inputImageTexture3;\nuniform sampler2D inputImageTexture4;\nuniform sampler2D inputImageTexture5;\n\nuniform float alpha;\nuniform int enableFaceOff;\nuniform float enableAlphaFromGray;\nuniform float enableAlphaFromGrayNew;\nuniform int blendMode;\nuniform int blendIris;\nuniform float level1;\nuniform float level2;\n\nuniform vec2 size;\nuniform vec2 center1;\nuniform vec2 center2;\nuniform float radius1;\nuniform float radius2;\n\nuniform int leftEyeClosed; // deprecated\nuniform int rightEyeClosed; // deprecated\nuniform float leftEyeCloseAlpha;\nuniform float rightEyeCloseAlpha;\n\nvec3 blendColorWithMode(vec4 texColor, vec4 canvasColor, int colorBlendMode)\n{\n    vec3 vOne = vec3(1.0, 1.0, 1.0);\n    vec3 vZero = vec3(0.0, 0.0, 0.0);\n    vec3 resultFore = texColor.rgb;\n    if (colorBlendMode <= 1){ //default, since used most, put on top\n\n    } else if (colorBlendMode == 2) {  //multiply\n        resultFore = canvasColor.rgb * texColor.rgb;\n    } else if (colorBlendMode == 3){    //screen\n        resultFore = vOne - (vOne - canvasColor.rgb) * (vOne - texColor.rgb);\n    } else if (colorBlendMode == 4){    //overlay\n        resultFore = 2.0 * canvasColor.rgb * texColor.rgb;\n        if (canvasColor.r >= 0.5) {\n            resultFore.r = 1.0 - 2.0 * (1.0 - canvasColor.r) * (1.0 - texColor.r);\n        }\n        if (canvasColor.g >= 0.5) {\n            resultFore.g = 1.0 - 2.0 * (1.0 - canvasColor.g) * (1.0 - texColor.g);\n        }\n        if (canvasColor.b >= 0.5) {\n            resultFore.b = 1.0 - 2.0 * (1.0 - canvasColor.b) * (1.0 - texColor.b);\n        }\n    } else if (colorBlendMode == 5){    //hardlight\n        resultFore = 2.0 * canvasColor.rgb * texColor.rgb;\n        if (texColor.r >= 0.5) {\n            resultFore.r = 1.0 - 2.0 * (1.0 - canvasColor.r) * (1.0 - texColor.r);\n        }\n        if (texColor.g >= 0.5) {\n            resultFore.g = 1.0 - 2.0 * (1.0 - canvasColor.g) * (1.0 - texColor.g);\n        }\n        if (texColor.b >= 0.5) {\n            resultFore.b = 1.0 - 2.0 * (1.0 - canvasColor.b) * (1.0 - texColor.b);\n        }\n    } else if (colorBlendMode == 6){    //softlight\n        resultFore = 2.0 * canvasColor.rgb * texColor.rgb + canvasColor.rgb * canvasColor.rgb * (vOne - 2.0 * texColor.rgb);\n        if (texColor.r >= 0.5) {\n            resultFore.r = 2.0 * canvasColor.r * (1.0 - texColor.r) + (2.0 * texColor.r - 1.0) * sqrt(canvasColor.r);\n        }\n        if (texColor.g >= 0.5) {\n            resultFore.g = 2.0 * canvasColor.g * (1.0 - texColor.g) + (2.0 * texColor.g - 1.0) * sqrt(canvasColor.g);\n        }\n        if (texColor.b >= 0.5) {\n            resultFore.b = 2.0 * canvasColor.b * (1.0 - texColor.b) + (2.0 * texColor.b - 1.0) * sqrt(canvasColor.b);\n        }\n    } else if (colorBlendMode == 7){    //divide\n        resultFore = vOne;\n        if (texColor.r > 0.0) {\n            resultFore.r = canvasColor.r / texColor.r;\n        }\n        if (texColor.g > 0.0) {\n            resultFore.g = canvasColor.g / texColor.g;\n        }\n        if (texColor.b > 0.0) {\n            resultFore.b = canvasColor.b / texColor.b;\n        }\n        resultFore = min(vOne, resultFore);\n    } else if (colorBlendMode == 8){    //add\n        resultFore = canvasColor.rgb + texColor.rgb;\n        resultFore = min(vOne, resultFore);\n    } else if (colorBlendMode == 9){    //substract\n        resultFore = canvasColor.rgb - texColor.rgb;\n        resultFore = max(vZero, resultFore);\n    } else if (colorBlendMode == 10){   //diff\n        resultFore = abs(canvasColor.rgb - texColor.rgb);\n    } else if (colorBlendMode == 11){   //darken\n        resultFore = min(canvasColor.rgb, texColor.rgb);\n    } else if (blendMode == 12){   //lighten\n        resultFore = max(canvasColor.rgb, texColor.rgb);\n    }\n    return resultFore;\n}\n\nvec4 blendColor(vec4 texColor, vec4 canvasColor) {\n    vec3 vOne = vec3(1.0, 1.0, 1.0);\n    vec3 vZero = vec3(0.0, 0.0, 0.0);\n    //revert pre multiply\n    if(texColor.a > 0.0){\n       texColor.rgb = texColor.rgb / texColor.a;\n    }\n    vec3 resultFore = texColor.rgb;\n    if (blendMode <= 12) {\n        resultFore = blendColorWithMode(texColor, canvasColor, blendMode);\n    } else if (blendMode == 13){   //highlight for lips\n        if (texColor.a > 0.0001) {\n            if(canvasColor.r >= level1) {\n                texColor.rgb = vec3(1.0, 1.0, 1.0);\n                //if(canvasColor.r < 0.6) {\n                   canvasColor.rgb = canvasColor.rgb + (vOne - canvasColor.rgb) * 0.05;\n                //}\n            } else if (canvasColor.r >= level2) {\n               if (level1 > level2) {\n                   float f = (canvasColor.r - level2) / (level1 - level2);\n                   texColor.rgb = texColor.rgb + (vOne - texColor.rgb) * f;\n                   canvasColor.rgb = canvasColor.rgb + (vOne - canvasColor.rgb) * 0.05 * f;\n               }\n            }\n        }\n        resultFore = canvasColor.rgb * texColor.rgb;\n        resultFore = clamp(resultFore, 0.0001, 0.9999);\n    } else if (blendMode == 14){   // iris\n         vec2 curPos = vec2(canvasCoordinate.x * size.x, canvasCoordinate.y * size.y);\n         float dist1 = sqrt((curPos.x - center1.x) * (curPos.x - center1.x) + (curPos.y - center1.y) * (curPos.y - center1.y));\n         float dist2 = sqrt((curPos.x - center2.x) * (curPos.x - center2.x) + (curPos.y - center2.y) * (curPos.y - center2.y));\n         if (dist1 < radius1 && leftEyeCloseAlpha >= 0.01) {\n             float _x = (curPos.x - center1.x) / radius1 / 2.0;\n             float _y = (curPos.y - center1.y) / radius1 / 2.0;\n             vec4 irisColor = texture2D(inputImageTexture4, vec2(_x * 0.72 + 0.5, _y * 0.72 + 0.5));\n             if (irisColor.a > 0.0) {\n                 irisColor = irisColor / vec4(irisColor.a, irisColor.a, irisColor.a, 1.0);\n             }\n             resultFore = blendColorWithMode(irisColor, canvasColor, blendIris);\n             texColor.a = texColor.a * irisColor.a * leftEyeCloseAlpha;\n         } else if (dist2 < radius2 && rightEyeCloseAlpha >= 0.01) {\n             float _x = (curPos.x - center2.x) / radius2 / 2.0;\n             float _y = (curPos.y - center2.y) / radius2 / 2.0;\n             vec4 irisColor = texture2D(inputImageTexture4, vec2(_x * 0.72 + 0.5, _y * 0.72 + 0.5));\n             if (irisColor.a > 0.0) {\n                 irisColor = irisColor / vec4(irisColor.a, irisColor.a, irisColor.a, 1.0);\n             }\n             resultFore = blendColorWithMode(irisColor, canvasColor, blendIris);\n             texColor.a = texColor.a * irisColor.a * rightEyeCloseAlpha;\n         } else {\n            texColor.a = 0.0;\n         }\n         //resultFore = texColor.rgb;\n         //texColor.a = 1.0;\n    }\n    //pre multiply for glBlendFunc\n    vec4 resultColor = vec4(resultFore * texColor.a, texColor.a);\n    return resultColor;\n}\n\nvoid main(void) {\n    vec4 canvasColor = texture2D(inputImageTexture, canvasCoordinate);\n    vec4 texColor = texture2D(inputImageTexture2, textureCoordinate);\n    vec4 grayColor = texture2D(inputImageTexture3, grayTextureCoordinate);\n    vec4 maskColor = texture2D(inputImageTexture5, grayTextureCoordinate);\n\n    if (enableFaceOff == 1) {\n        if (texColor.a > 0.0) {\n            texColor = texColor / vec4(texColor.a, texColor.a, texColor.a, 1.0);\n        }\n        if(enableAlphaFromGray > 0.0){\n            float grayAlpha = (1.0 - mix(maskColor.r, grayColor.r, enableAlphaFromGray));\n            texColor.a = texColor.a * grayAlpha * alpha;\n        } else {\n            texColor.a = texColor.a * alpha;\n        }\n    }\n\n    texColor.rgb = texColor.rgb * texColor.a;\n\n    gl_FragColor = blendColor(texColor, canvasColor);\n }\n";
  public static final String FLIP_FRAGMENT_SHADER_DAT = "\nvarying highp vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\n\nuniform highp float x;\nuniform highp float y;\n\nvoid main()\n{\n    highp float h = textureCoordinate.x+x;\n    if (h > 1.0) {\n        h = h-1.0;\n    }\n    if (h < 0.0) {\n        h = h+1.0;\n    }\n\n    highp float v = textureCoordinate.y+y;\n    if (v > 1.0) {\n        v = v-1.0;\n    }\n    if (v < 0.0) {\n        v = v+1.0;\n    }\n\n    gl_FragColor = texture2D(inputImageTexture, vec2(h, v));\n}\n";
  public static final String FUR_FRAGMENT_SHADER_GLSL = "precision lowp float;\n\nvarying vec3 normalOut;\nvarying vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;    //image\n\nvec3 vecLightDir = vec3(0.8, 0.8, 1);\n\nvoid main()\n{\n    vec4 FurColour = texture2D(inputImageTexture, textureCoordinate);\n    vec4 FinalColour = FurColour;\n\n    //--------------------------\n\n    //Basic Directional Lighting\n    vec4 ambient = vec4(0.3, 0.3, 0.3, 0.0);\n    ambient = ambient * FinalColour;\n    vec4 diffuse = FinalColour;\n    FinalColour = ambient + diffuse * dot(vecLightDir, normalOut);\n    //End Basic Lighting Code\n\n    //--------------------------\n\n    FinalColour.a = FurColour.a;\n    //return FinalColour;      // fur colour only!\n    gl_FragColor = FinalColour;// Use texture colour\n\n}";
  public static final String FUR_VERTEX_SHADER_GLSL = "precision mediump float;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 inputTextureCoordinate;\n\nuniform float FurLength;\nuniform float Layer;\nuniform float UVScale;\nuniform vec3 vGravity;\n\n// transformations\nuniform mat4 worldViewProj;\nuniform mat4 matWorld;\n\nvarying vec3 normalOut;\nvarying vec2 textureCoordinate;\n\n\nvoid main(){\n    //This single line is responsible for creating the layers!  This is it! Nothing\n    //more nothing less!\n    vec3 P = position.xyz + (normal * FurLength);\n\n    //Modify our normal so it faces the correct direction for lighting if we\n    //want any lighting\n    normalOut = normalize((matWorld * vec4(normal, 1.0)).xyz);    // Output Normal\n\n    // Couple of lines to give a swaying effect!\n    // Additional Gravit/Force Code\n    vec3 gravity = (matWorld * vec4(vGravity, 1.0)).xyz;\n    float k =  pow(Layer, 3.0);  // We use the pow function, so that only the tips of the hairs bend\n    // As layer goes from 0 to 1, so by using pow(..) function is still\n    // goes form 0 to 1, but it increases faster! exponentially\n    P = P + gravity * k;\n    // End Gravity Force Addit Code\n\n    textureCoordinate = inputTextureCoordinate * UVScale; // Pass long texture data\n    // UVScale??  Well we scale the fur texture alpha coords so this effects the fur thickness\n    // thinness, sort of stretches or shrinks the fur over the object!\n\n    gl_Position = worldViewProj * vec4(P, 1.0); // Output Vertice Position Data\n}";
  public static final String GIF_FRAME_VERTEX_SHADER_DAT = "precision highp float;\nattribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 textureCoordinate;\n\nuniform vec2 canvasSize;\nuniform vec2 texOffset;\n\nmat4 texMatTranslate = mat4(1.0, 0.0, 0.0, 0.0,\n                                 0.0, 1.0, 0.0, 0.0,\n                                 0.0, 0.0, 1.0, 0.0,\n                                 0.0, 0.0, 0.0, 1.0);\n\nvoid main(){\n    vec4 framePos = position;\n    framePos.x = framePos.x * canvasSize.x * 0.5;\n    framePos.y = framePos.y * canvasSize.y * 0.5;\n\n    texMatTranslate[3][0] = texOffset.x;\n    texMatTranslate[3][1] = texOffset.y;\n\n    framePos = texMatTranslate * framePos;\n\n    framePos.x = framePos.x * 2.0 / canvasSize.x;\n    framePos.y = framePos.y * 2.0 / canvasSize.y;\n\n    gl_Position = framePos;\n    textureCoordinate = inputTextureCoordinate;\n}";
  public static final String HEAD_CROP_FRAGMENT_SHADER_DAT = "mee516x1667592816x1869181801x1701650542x1836411236x1818632304x997482863x1918989834x1735289209x1667593760x1702109234x1920300152x1869562725x1852400754x996504673x1918989834x1735289209x1667593760x1919361074x1700034913x1920300152x1869562725x1852400754x996504673x1853164042x1919903337x1634934893x1701605485x541340274x1970302569x1634552180x1700029799x1920300152x1963604837x1868982638x1931505010x1819307361x1144156773x1886284064x1833530485x1415931745x1970567269x993158514x1853164042x1919903337x1852383341x1852121204x1701601889x1701011782x996566607x1870006794x1830839401x678324577x1684631414x175841321x538976288x878929270x2019914784x1869377347x540876914x1954047348x845509237x1852385348x1232369008x1701273965x1954047316x744845941x2019914784x1701999988x1919905603x1634625892x992568692x538976266x1667593760x1919361076x1866692961x544370540x1702109245x1920300152x675557989x1970302569x1634552180x1700029799x1920300152x539767397x2036429415x1954047316x1130721909x1685221231x1952542313x171649381x538976266x543582496x1634624808x1181052002x1332044641x1025533542x691085373x537557792x538976288x1702109216x1819231096x1630433903x824196384x757084206x1634887456x1819231097x1647211119x538970683x175972384x538976266x2019914784x1869377347x1735536242x540876898x1131963764x1919904879x1650946606x1948264992x1866692709x779251564x168442721x538976288x1180658791x1130848626x1919904879x1948269856x1866692709x997355372x175972362x";
  public static final String HEAD_CROP_VERTEX_SHADER_DAT = "mee333x1953784096x1969383794x1981834612x540304229x1769172848x1852795252x1981811259x1769566817x1981835118x540173157x1954047348x1130721909x1685221231x1952542313x168442725x1953784096x1969383794x1981834612x540304229x1970302569x1634879348x2019906681x1701999988x1919905603x1634625892x171664756x1918989856x1735289209x1667593760x1919361074x1700034913x1920300152x1869562725x1852400754x996504673x1981811210x543451503x1852399981x1768912424x2065705316x538976266x1818697760x1936674911x1869182057x540876910x1769172848x1852795252x538970683x1948262432x1970567269x1866687858x1768190575x1702125934x540876832x845374838x1936683048x1869182057x544747118x774905898x539697205x741682736x1936683040x1869182057x544812654x774905898x539697205x691351088x538970683x1730158624x1417240946x1970567269x1866687858x1768190575x1702125934x540876832x1970302569x1634879348x2019906681x1701999988x1919905603x1634625892x2016306548x537541497x125x";
  public static final String HORIZONTAL_SKEW_FRAGMENT_SHADER_DAT = "precision highp float;\nvarying highp vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform float adjust;\n\nvoid main() {\n    float pi = 3.1415926;\n    float delta = 0.0;\n    vec2 coord = textureCoordinate;\n\n    float value1 = -0.08;\n    float middle1 = 0.09;\n    float span1 = 0.05;\n\n    float value2 = 0.04;\n    float middle2 = 0.18;\n    float span2 = 0.04;\n\n    float value3 = 0.09;\n    float middle3 = 0.29;\n    float span3 = 0.07;\n\n    float value4 = -0.03;\n    float middle4 = 0.49;\n    float span4 = 0.1;\n\n    float value5 = -0.08;\n    float middle5 = 0.72;\n    float span5 = 0.1;\n\n    float value6 = 0.02;\n    float middle6 = 0.87;\n    float span6 = 0.05;\n\n    if (abs(textureCoordinate.y - middle1) < span1) {\n        float f = (coord.y - middle1) / span1 * pi;\n        delta = (cos(f) + 1.0) * value1;\n    } else if (abs(textureCoordinate.y - middle2) < span2) {\n        float f = (coord.y - middle2) / span2 * pi;\n        delta = (cos(f) + 1.0) * value2;\n    } else if (abs(textureCoordinate.y - middle3) < span3) {\n        float f = (coord.y - middle3) / span3 * pi;\n        delta = (cos(f) + 1.0) * value3;\n    } else if (abs(textureCoordinate.y - middle4) < span4) {\n        float f = (coord.y - middle4) / span4 * pi;\n        delta = (cos(f) + 1.0) * value4;\n    } else if (abs(textureCoordinate.y - middle5) < span5) {\n        float f = (coord.y - middle5) / span5 * pi;\n        delta = (cos(f) + 1.0) * value5;\n    } else if (abs(textureCoordinate.y - middle6) < span6) {\n        float f = (coord.y - middle6) / span6 * pi;\n        delta = (cos(f) + 1.0) * value6;\n    }\n\n    coord.x = coord.x + delta * adjust;\n    vec4 textureColor = texture2D(inputImageTexture, coord);\n    gl_FragColor = textureColor;\n}";
  public static final String LOOKUP_ALPHA_FRAGMENT_SHADER_DAT = "varying highp vec2 textureCoordinate;\nvarying highp vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform lowp float alpha;\nvoid main() {\nhighp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\nhighp float blueColor = textureColor.b * 63.0;\nhighp vec2 quad1; quad1.y = floor(floor(blueColor) / 8.0);\nquad1.x = floor(blueColor) - (quad1.y * 8.0);\nhighp vec2 quad2;\nquad2.y = floor(ceil(blueColor) / 8.0);\nquad2.x = ceil(blueColor) - (quad2.y * 8.0);\nhighp vec2 texPos1;\ntexPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\ntexPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\nhighp vec2 texPos2;\ntexPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\ntexPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\nlowp vec4 newColor1 = texture2D(inputImageTexture2, texPos1);\nlowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2);\nlowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\nnewColor = mix(newColor, textureColor, alpha);\ngl_FragColor = vec4(newColor.rgb, textureColor.w);\n}\n";
  public static final String LOOKUP_FRAGMENT_SHADER_DAT = "varying highp vec2 textureCoordinate;\nvarying highp vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nvoid main() {\n    highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n    highp float blueColor = textureColor.b * 63.0;\n    highp vec2 quad1; quad1.y = floor(floor(blueColor) / 8.0);\n    quad1.x = floor(blueColor) - (quad1.y * 8.0);\n    highp vec2 quad2;\n    quad2.y = floor(ceil(blueColor) / 8.0);\n    quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n    highp vec2 texPos1;\n    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n    highp vec2 texPos2;\n    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n    lowp vec4 newColor1 = texture2D(inputImageTexture2, texPos1);\n    lowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2);\n    lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n    gl_FragColor = vec4(newColor.rgb, textureColor.w);\n}\n";
  public static final String LOOKUP_VERTEX_SHADER_DAT = "attribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 textureCoordinate;\n\nvoid main() {\n    gl_Position = position;\n    textureCoordinate = inputTextureCoordinate;\n}";
  public static final String MCCOMMON_VERTEX_SHADER_DAT = "precision highp float;\nattribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 canvasCoordinate;\nvarying vec2 textureCoordinate;\nvarying float oneOverZ;\n\nuniform int texNeedTransform;\nuniform vec2 canvasSize;\nuniform vec2 texAnchor;\nuniform float texScale;\nuniform float texScaleX;\nuniform float texScaleY;\nuniform vec3 texRotate;\n\nconst float PI = 3.14159;\n\nuniform mat4 u_MVPMatrix;\n\nmat4 texMatTranslateBefore = mat4(1.0, 0.0, 0.0, 0.0,\n                                  0.0, 1.0, 0.0, 0.0,\n                                  0.0, 0.0, 1.0, 0.0,\n                                  0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatScale = mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatRotate = mat4(1.0, 0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatRotateXY = mat4(1.0, 0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatTranslateAfter = mat4(1.0, 0.0, 0.0, 0.0,\n                                 0.0, 1.0, 0.0, 0.0,\n                                 0.0, 0.0, 1.0, 0.0,\n                                 0.0, 0.0, 0.0, 1.0);\n\nmat4 mat4RotationYXZ(mat4 m, float xRadians, float yRadians, float zRadians) {\n    /*\n     |  cycz + sxsysz   czsxsy - cysz   cxsy  0 |\n M = |  cxsz            cxcz           -sx    0 |\n     |  cysxsz - czsy   cyczsx + sysz   cxcy  0 |\n     |  0               0               0     1 |\n\n     where cA = cos(A), sA = sin(A) for A = x,y,z\n     */\n\n    float cx = cos(xRadians);\n    float sx = sin(xRadians);\n    float cy = cos(yRadians);\n    float sy = sin(yRadians);\n    float cz = cos(zRadians);\n    float sz = sin(zRadians);\n\n    m[0][0] = (cy * cz) + (sx * sy * sz);\n    m[0][1] = cx * sz;\n    m[0][2] = (cy * sx * sz) - (cz * sy);\n    m[0][3] = 0.0;\n\n    m[1][0] = (cz * sx * sy) - (cy * sz);\n    m[1][1] = cx * cz;\n    m[1][2] = (cy * cz * sx) + (sy * sz);\n    m[1][3] = 0.0;\n\n    m[2][0] = cx * sy;\n    m[2][1] = -sx;\n    m[2][2] = cx * cy;\n    m[2][3] = 0.0;\n\n    m[3][0] = 0.0;\n    m[3][1] = 0.0;\n    m[3][2] = 0.0;\n    m[3][3] = 1.0;\n\n    return m;\n}\n\nvoid main(){\n    vec4 framePos = position;\n    if (texNeedTransform > 0) {\n        framePos.x = framePos.x * canvasSize.x * 0.5;\n        framePos.y = framePos.y * canvasSize.y * 0.5;\n\n        texMatTranslateBefore[3][0] = -texAnchor.x;\n        texMatTranslateBefore[3][1] = -texAnchor.y;\n\n        texMatScale[0][0] = texScaleX * texScale;\n        texMatScale[1][1] = texScaleY * texScale;\n\n        texMatRotate = mat4RotationYXZ(texMatRotate, 0.0, 0.0, texRotate.z);\n        texMatRotateXY = mat4RotationYXZ(texMatRotateXY, texRotate.x, texRotate.y, 0.0);\n\n        texMatTranslateAfter[3][0] = texAnchor.x;\n        texMatTranslateAfter[3][1] = texAnchor.y;\n\n        framePos = texMatRotate * texMatScale * texMatTranslateBefore * framePos;\n\n        framePos.x = framePos.x * 2.0 / canvasSize.x;\n        framePos.y = framePos.y * 2.0 / canvasSize.y;\n\n        framePos = texMatRotateXY * framePos;\n\n        framePos.x = framePos.x * canvasSize.x * 0.5;\n        framePos.y = framePos.y * canvasSize.y * 0.5;\n\n        framePos = texMatTranslateAfter * framePos;\n\n        framePos.x = framePos.x * 2.0 / canvasSize.x;\n        framePos.y = framePos.y * 2.0 / canvasSize.y;\n\n        framePos.x = framePos.x * 1.5 ;\n        framePos.y = framePos.y * 1.5 ;\n\n        framePos = u_MVPMatrix * framePos;\n    }\n    gl_Position = framePos / framePos.w;\n    canvasCoordinate = vec2(framePos.x / framePos.w * 0.5 + 0.5, framePos.y / framePos.w * 0.5 + 0.5);\n    oneOverZ = 1.0 / framePos.w;\n    textureCoordinate = inputTextureCoordinate / framePos.w;\n}\n";
  public static final String MC_COMMON_LR_VERTEX_SHADER_CONTENT = "precision highp float;\nattribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 textureCoordinate;\nvarying vec2 alphaCoordinate;\n\nuniform int texNeedTransform;\nuniform vec2 canvasSize;\nuniform vec2 texAnchor;\nuniform float texScale;\nuniform vec3 texRotate;\n\nconst float PI = 3.14159;\n\nuniform mat4 u_MVPMatrix;\n\nmat4 texMatTranslateBefore = mat4(1.0, 0.0, 0.0, 0.0,\n                                  0.0, 1.0, 0.0, 0.0,\n                                  0.0, 0.0, 1.0, 0.0,\n                                  0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatScale = mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatRotate = mat4(1.0, 0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatRotateXY = mat4(1.0, 0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatTranslateAfter = mat4(1.0, 0.0, 0.0, 0.0,\n                                 0.0, 1.0, 0.0, 0.0,\n                                 0.0, 0.0, 1.0, 0.0,\n                                 0.0, 0.0, 0.0, 1.0);\n\nmat4 mat4RotationYXZ(mat4 m, float xRadians, float yRadians, float zRadians) {\n    /*\n     |  cycz + sxsysz   czsxsy - cysz   cxsy  0 |\n M = |  cxsz            cxcz           -sx    0 |\n     |  cysxsz - czsy   cyczsx + sysz   cxcy  0 |\n     |  0               0               0     1 |\n\n     where cA = cos(A), sA = sin(A) for A = x,y,z\n     */\n\n    float cx = cos(xRadians);\n    float sx = sin(xRadians);\n    float cy = cos(yRadians);\n    float sy = sin(yRadians);\n    float cz = cos(zRadians);\n    float sz = sin(zRadians);\n\n    m[0][0] = (cy * cz) + (sx * sy * sz);\n    m[0][1] = cx * sz;\n    m[0][2] = (cy * sx * sz) - (cz * sy);\n    m[0][3] = 0.0;\n\n    m[1][0] = (cz * sx * sy) - (cy * sz);\n    m[1][1] = cx * cz;\n    m[1][2] = (cy * cz * sx) + (sy * sz);\n    m[1][3] = 0.0;\n\n    m[2][0] = cx * sy;\n    m[2][1] = -sx;\n    m[2][2] = cx * cy;\n    m[2][3] = 0.0;\n\n    m[3][0] = 0.0;\n    m[3][1] = 0.0;\n    m[3][2] = 0.0;\n    m[3][3] = 1.0;\n\n    return m;\n}\n\nvoid main(){\n    vec4 framePos = position;\n    if (texNeedTransform > 0) {\n        framePos.x = framePos.x * canvasSize.x * 0.5;\n        framePos.y = framePos.y * canvasSize.y * 0.5;\n\n        texMatTranslateBefore[3][0] = -texAnchor.x;\n        texMatTranslateBefore[3][1] = -texAnchor.y;\n\n        texMatScale[0][0] = texScale;\n        texMatScale[1][1] = texScale;\n\n        texMatRotate = mat4RotationYXZ(texMatRotate, 0.0, 0.0, texRotate.z);\n        texMatRotateXY = mat4RotationYXZ(texMatRotateXY, texRotate.x, texRotate.y, 0.0);\n\n        texMatTranslateAfter[3][0] = texAnchor.x;\n        texMatTranslateAfter[3][1] = texAnchor.y;\n\n        framePos = texMatRotate * texMatScale * texMatTranslateBefore * framePos;\n\n        framePos.x = framePos.x * 2.0 / canvasSize.x;\n        framePos.y = framePos.y * 2.0 / canvasSize.y;\n\n        framePos = texMatRotateXY * framePos;\n\n        framePos.x = framePos.x * canvasSize.x * 0.5;\n        framePos.y = framePos.y * canvasSize.y * 0.5;\n\n        framePos = texMatTranslateAfter * framePos;\n\n        framePos.x = framePos.x * 2.0 / canvasSize.x;\n        framePos.y = framePos.y * 2.0 / canvasSize.y;\n\n        framePos.x = framePos.x * 1.5 ;\n        framePos.y = framePos.y * 1.5 ;\n\n        framePos = u_MVPMatrix * framePos;\n\n    }\n    gl_Position = framePos;\n    textureCoordinate = vec2(inputTextureCoordinate.x / 2., inputTextureCoordinate.y);\n    alphaCoordinate = vec2(inputTextureCoordinate.x / 2. + 0.5, inputTextureCoordinate.y);\n}";
  public static final String MC_COMMON_UD_VERTEX_SHADER_CONTENT = "precision highp float;\nattribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 textureCoordinate;\nvarying vec2 alphaCoordinate;\n\nuniform int texNeedTransform;\nuniform vec2 canvasSize;\nuniform vec2 texAnchor;\nuniform float texScale;\nuniform vec3 texRotate;\n\nconst float PI = 3.14159;\n\nuniform mat4 u_MVPMatrix;\n\nmat4 texMatTranslateBefore = mat4(1.0, 0.0, 0.0, 0.0,\n                                  0.0, 1.0, 0.0, 0.0,\n                                  0.0, 0.0, 1.0, 0.0,\n                                  0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatScale = mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatRotate = mat4(1.0, 0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatRotateXY = mat4(1.0, 0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatTranslateAfter = mat4(1.0, 0.0, 0.0, 0.0,\n                                 0.0, 1.0, 0.0, 0.0,\n                                 0.0, 0.0, 1.0, 0.0,\n                                 0.0, 0.0, 0.0, 1.0);\n\nmat4 mat4RotationYXZ(mat4 m, float xRadians, float yRadians, float zRadians) {\n    /*\n     |  cycz + sxsysz   czsxsy - cysz   cxsy  0 |\n M = |  cxsz            cxcz           -sx    0 |\n     |  cysxsz - czsy   cyczsx + sysz   cxcy  0 |\n     |  0               0               0     1 |\n\n     where cA = cos(A), sA = sin(A) for A = x,y,z\n     */\n\n    float cx = cos(xRadians);\n    float sx = sin(xRadians);\n    float cy = cos(yRadians);\n    float sy = sin(yRadians);\n    float cz = cos(zRadians);\n    float sz = sin(zRadians);\n\n    m[0][0] = (cy * cz) + (sx * sy * sz);\n    m[0][1] = cx * sz;\n    m[0][2] = (cy * sx * sz) - (cz * sy);\n    m[0][3] = 0.0;\n\n    m[1][0] = (cz * sx * sy) - (cy * sz);\n    m[1][1] = cx * cz;\n    m[1][2] = (cy * cz * sx) + (sy * sz);\n    m[1][3] = 0.0;\n\n    m[2][0] = cx * sy;\n    m[2][1] = -sx;\n    m[2][2] = cx * cy;\n    m[2][3] = 0.0;\n\n    m[3][0] = 0.0;\n    m[3][1] = 0.0;\n    m[3][2] = 0.0;\n    m[3][3] = 1.0;\n\n    return m;\n}\n\nvoid main(){\n    vec4 framePos = position;\n    if (texNeedTransform > 0) {\n        framePos.x = framePos.x * canvasSize.x * 0.5;\n        framePos.y = framePos.y * canvasSize.y * 0.5;\n\n        texMatTranslateBefore[3][0] = -texAnchor.x;\n        texMatTranslateBefore[3][1] = -texAnchor.y;\n\n        texMatScale[0][0] = texScale;\n        texMatScale[1][1] = texScale;\n\n        texMatRotate = mat4RotationYXZ(texMatRotate, 0.0, 0.0, texRotate.z);\n        texMatRotateXY = mat4RotationYXZ(texMatRotateXY, texRotate.x, texRotate.y, 0.0);\n\n        texMatTranslateAfter[3][0] = texAnchor.x;\n        texMatTranslateAfter[3][1] = texAnchor.y;\n\n        framePos = texMatRotate * texMatScale * texMatTranslateBefore * framePos;\n\n        framePos.x = framePos.x * 2.0 / canvasSize.x;\n        framePos.y = framePos.y * 2.0 / canvasSize.y;\n\n        framePos = texMatRotateXY * framePos;\n\n        framePos.x = framePos.x * canvasSize.x * 0.5;\n        framePos.y = framePos.y * canvasSize.y * 0.5;\n\n        framePos = texMatTranslateAfter * framePos;\n\n        framePos.x = framePos.x * 2.0 / canvasSize.x;\n        framePos.y = framePos.y * 2.0 / canvasSize.y;\n\n        framePos.x = framePos.x * 1.5 ;\n        framePos.y = framePos.y * 1.5 ;\n\n        framePos = u_MVPMatrix * framePos;\n\n    }\n    gl_Position = framePos;\n    textureCoordinate = vec2(inputTextureCoordinate.x, inputTextureCoordinate.y / 2.);\n    alphaCoordinate = vec2(inputTextureCoordinate.x, inputTextureCoordinate.y / 2. + 0.5);\n}";
  public static final String NINE_TILE_FRAGMENT_SHADER_DAT = "\nvarying highp vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\n\nuniform lowp float x_max;\nuniform lowp float x_min;\nuniform lowp float y_max;\nuniform lowp float y_min;\n\nvoid main()\n{\n    highp float new_x = textureCoordinate.x;\n    highp float new_y = textureCoordinate.y;\n\n    lowp float d_x_0 = x_min;\n    lowp float d_x_1 = x_max-x_min;\n    lowp float d_x_2 = 1.0-x_max;\n    lowp float d_y_0 = y_min;\n    lowp float d_y_1 = y_max-y_min;\n    lowp float d_y_2 = 1.0-y_max;\n    lowp float s_x = max(max(d_x_0,d_x_1),d_x_2);\n    lowp float s_y = max(max(d_y_0,d_y_1),d_y_2);\n    lowp float s = max(s_x,s_y);\n\n    if (new_x < x_min) {\n        new_x = 1.0-(x_min-new_x)/s;\n    }\n    else if (new_x < x_max) {\n        new_x = (new_x-x_min)/s;\n    }\n    else {\n        new_x = (new_x-x_max)/s;\n    }\n\n    if (new_y < y_min) {\n        new_y = 1.0-(y_min-new_y)/s;\n    }\n    else if (new_y < y_max) {\n        new_y = (new_y-y_min)/s;\n    }\n    else {\n        new_y = (new_y-y_max)/s;\n    }\n\n    highp vec2 newCorrdinate = vec2(new_x,new_y);\n    gl_FragColor = texture2D(inputImageTexture, newCorrdinate);\n}";
  public static final String NO_FUR_FRAGMENT_SHADER_GLSL = "precision lowp float;\n\nvarying vec3 normalOut;\nvarying vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;    //image\n\nvec3 vecLightDir = vec3(0.8, 0.8, 1);\n\nvoid main()\n{\n    vec4 FurColour = vec4(0, 0.5, 0.5, 1);\n    vec4 FinalColour = FurColour;\n\n    //--------------------------\n\n    //Basic Directional Lighting\n    vec4 ambient = vec4(0.3, 0.3, 0.3, 0.0);\n    ambient = ambient * FinalColour;\n    vec4 diffuse = FinalColour;\n    FinalColour = ambient + diffuse * dot(vecLightDir, normalOut);\n    //End Basic Lighting Code\n\n    //--------------------------\n\n    FinalColour.a = FurColour.a;\n    //return FinalColour;      // fur colour only!\n    gl_FragColor = FinalColour;// Use texture colour\n\n}";
  public static final String OFFSET_ALPHA_BLEND_FRAGMENT_SHADER_DAT = "precision mediump float;\nvarying vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\nuniform vec2 offset1;\nuniform vec2 offset2;\n\nvoid main(void) {\n     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n\n     mediump vec2 coordinate1 = textureCoordinate+offset1;\n     mediump vec2 coordinate2 = textureCoordinate+offset2;\n\n     mediump vec4 tex = base;\n\n     if (coordinate1.x >= 0.0 && coordinate1.x <= 1.0 && coordinate1.y >= 0.0 && coordinate1.y <= 1.0) {\n\n         mediump vec4 overlay = texture2D(inputImageTexture, coordinate1);\n\n         tex = vec4(mix(base.rgb, overlay.rgb, overlay.a * 0.5), base.a);\n     }\n\n     if (coordinate2.x >= 0.0 && coordinate2.x <= 1.0 && coordinate2.y >= 0.0 && coordinate2.y <= 1.0) {\n\n        mediump vec4 overlay = texture2D(inputImageTexture, coordinate2);\n\n        tex = vec4(mix(base.rgb, overlay.rgb, overlay.a * 0.5), base.a);\n     }\n\n     gl_FragColor = tex;\n}";
  public static final String ROTATE_SCALE_FRAGMENT_SHADER_DAT = "precision highp float;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform float alpha;\n\nvoid main() \n{\n    vec4 color = texture2D (inputImageTexture, textureCoordinate);\n    gl_FragColor = vec4 (color.rgb * color.a * alpha, color.a * alpha);\n}";
  public static final String ROTATE_SCALE_VERTEX_SHADER_DAT = "precision highp float;\nattribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 textureCoordinate;\n\nuniform float texScale;\nuniform float texRotate;\nuniform vec2 anchor;\nuniform vec2 translate;\nuniform vec2 canvasSize;\n\nconst float PI = 3.14159;\n\nmat4 texMatScale = mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 1.0);\n\nmat4 texMatRotate = mat4(1.0, 0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0, 1.0);\n\nmat4 mat4RotationYXZ(mat4 m, float xRadians, float yRadians, float zRadians) {\n    /*\n     |  cycz + sxsysz   czsxsy - cysz   cxsy  0 |\n M = |  cxsz            cxcz           -sx    0 |\n     |  cysxsz - czsy   cyczsx + sysz   cxcy  0 |\n     |  0               0               0     1 |\n\n     where cA = cos(A), sA = sin(A) for A = x,y,z\n     */\n\n    float cx = cos(xRadians);\n    float sx = sin(xRadians);\n    float cy = cos(yRadians);\n    float sy = sin(yRadians);\n    float cz = cos(zRadians);\n    float sz = sin(zRadians);\n\n    m[0][0] = (cy * cz) + (sx * sy * sz);\n    m[0][1] = cx * sz;\n    m[0][2] = (cy * sx * sz) - (cz * sy);\n    m[0][3] = 0.0;\n\n    m[1][0] = (cz * sx * sy) - (cy * sz);\n    m[1][1] = cx * cz;\n    m[1][2] = (cy * cz * sx) + (sy * sz);\n    m[1][3] = 0.0;\n\n    m[2][0] = cx * sy;\n    m[2][1] = -sx;\n    m[2][2] = cx * cy;\n    m[2][3] = 0.0;\n\n    m[3][0] = 0.0;\n    m[3][1] = 0.0;\n    m[3][2] = 0.0;\n    m[3][3] = 1.0;\n\n    return m;\n}\n\nvoid main(){\n    vec4 framePos = position;\n    framePos.xy = framePos.xy - anchor;\n\n    framePos.x *= canvasSize.x;\n    framePos.y *= canvasSize.y;\n\n    texMatScale[0][0] = texScale;\n    texMatScale[1][1] = texScale;\n\n    texMatRotate = mat4RotationYXZ(texMatRotate, 0.0, 0.0, texRotate);\n\n    framePos = texMatRotate * texMatScale * framePos;\n\n    framePos.x /= canvasSize.x;\n    framePos.y /= canvasSize.y;\n\n    framePos.xy = framePos.xy + anchor + translate;\n\n    gl_Position = framePos;\n    textureCoordinate = inputTextureCoordinate;\n}";
  public static final String SHADOW_FRAGMENT_SHADER_GLSL = "precision lowp float;\n\nvarying vec3 normalOut;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate1;\n\nuniform sampler2D inputImageTexture;    //image\n\nvec3 vecLightDir = vec3(0.8, 0.8, 1);\n\nvoid main()\n{\n    vec4 furcolr = texture2D(inputImageTexture, textureCoordinate);\n    vec4 furcolr_offset = texture2D(inputImageTexture, textureCoordinate1);\n\n    vec4 color = furcolr_offset - furcolr;\n\n    vec4 fcolor = color;\n    fcolor.a = color.a;\n\n    vec4 Y = vec4(0.299, 0.587, 0.114, 0.0);\n    fcolor = vec4(dot(Y, fcolor)); // grey output\n\n    gl_FragColor = fcolor;\n}";
  public static final String SHADOW_VERTEX_SHADER_GLSL = "precision mediump float;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 inputTextureCoordinate;\n\nuniform float FurLength;\nuniform float Layer;\nuniform float UVScale;\nuniform vec3 vGravity;\n\n// transformations\nuniform mat4 worldViewProj;\nuniform mat4 matWorld;\n\nvarying vec3 normalOut;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate1;\n\n\nvoid main(){\n    //This single line is responsible for creating the layers!  This is it! Nothing\n    //more nothing less!\n    vec3 P = position.xyz + (normal * FurLength);\n\n    //Modify our normal so it faces the correct direction for lighting if we\n    //want any lighting\n    normalOut = normalize((matWorld * vec4(normal, 1.0)).xyz);    // Output Normal\n\n    // Couple of lines to give a swaying effect!\n    // Additional Gravit/Force Code\n    vec3 gravity = (matWorld * vec4(vGravity, 1.0)).xyz;\n    float k =  pow(Layer, 3.0);  // We use the pow function, so that only the tips of the hairs bend\n    // As layer goes from 0 to 1, so by using pow(..) function is still\n    // goes form 0 to 1, but it increases faster! exponentially\n    P = P + gravity * k;\n    // End Gravity Force Addit Code\n\n    float znormal = 1.0 - dot(normalOut, vec3(0, 0, 1.0));\n\n    textureCoordinate = inputTextureCoordinate * UVScale; // Pass long texture data\n    textureCoordinate1 = inputTextureCoordinate * UVScale + vec2(znormal * 0.0011);\n    // UVScale??  Well we scale the fur texture alpha coords so this effects the fur thickness\n    // thinness, sort of stretches or shrinks the fur over the object!\n\n    gl_Position = worldViewProj * vec4(P, 1.0); // Output Vertice Position Data\n}";
  public static final String SIMPLE_FRAGMENT_SHADER_EXT_DAT = "#extension GL_EXT_shader_framebuffer_fetch : require\n\nprecision highp float;\nvarying vec2 canvasCoordinate;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform int blendMode;\n\n vec4 blendColor(vec4 texColor, vec4 canvasColor)\n {\n     vec3 vOne = vec3(1.0, 1.0, 1.0);\n     vec3 vZero = vec3(0.0, 0.0, 0.0);\n     //revert pre multiply\n     if(texColor.a > 0.0){\n        texColor.rgb = texColor.rgb / texColor.a;\n     }\n     vec3 resultFore = texColor.rgb;\n     if (blendMode <= 1 || blendMode > 12){ //default, since used most, put on top\n\n     } else if (blendMode == 2) {  //multiply\n         resultFore = canvasColor.rgb * texColor.rgb;\n     } else if (blendMode == 3){    //screen\n         resultFore = vOne - (vOne - canvasColor.rgb) * (vOne - texColor.rgb);\n     } else if (blendMode == 4){    //overlay\n         resultFore = 2.0 * canvasColor.rgb * texColor.rgb;\n         if (canvasColor.r >= 0.5) {\n             resultFore.r = 1.0 - 2.0 * (1.0 - canvasColor.r) * (1.0 - texColor.r);\n         }\n         if (canvasColor.g >= 0.5) {\n             resultFore.g = 1.0 - 2.0 * (1.0 - canvasColor.g) * (1.0 - texColor.g);\n         }\n         if (canvasColor.b >= 0.5) {\n             resultFore.b = 1.0 - 2.0 * (1.0 - canvasColor.b) * (1.0 - texColor.b);\n         }\n     } else if (blendMode == 5){    //hardlight\n         resultFore = 2.0 * canvasColor.rgb * texColor.rgb;\n         if (texColor.r >= 0.5) {\n             resultFore.r = 1.0 - 2.0 * (1.0 - canvasColor.r) * (1.0 - texColor.r);\n         }\n         if (texColor.g >= 0.5) {\n             resultFore.g = 1.0 - 2.0 * (1.0 - canvasColor.g) * (1.0 - texColor.g);\n         }\n         if (texColor.b >= 0.5) {\n             resultFore.b = 1.0 - 2.0 * (1.0 - canvasColor.b) * (1.0 - texColor.b);\n         }\n     } else if (blendMode == 6){    //softlight\n         resultFore = 2.0 * canvasColor.rgb * texColor.rgb + canvasColor.rgb * canvasColor.rgb * (vOne - 2.0 * texColor.rgb);\n         if (texColor.r >= 0.5) {\n             resultFore.r = 2.0 * canvasColor.r * (1.0 - texColor.r) + (2.0 * texColor.r - 1.0) * sqrt(canvasColor.r);\n         }\n         if (texColor.g >= 0.5) {\n             resultFore.g = 2.0 * canvasColor.g * (1.0 - texColor.g) + (2.0 * texColor.g - 1.0) * sqrt(canvasColor.g);\n         }\n         if (texColor.b >= 0.5) {\n             resultFore.b = 2.0 * canvasColor.b * (1.0 - texColor.b) + (2.0 * texColor.b - 1.0) * sqrt(canvasColor.b);\n         }\n     } else if (blendMode == 7){    //divide\n         resultFore = vOne;\n         if (texColor.r > 0.0) {\n             resultFore.r = canvasColor.r / texColor.r;\n         }\n         if (texColor.g > 0.0) {\n             resultFore.g = canvasColor.g / texColor.g;\n         }\n         if (texColor.b > 0.0) {\n             resultFore.b = canvasColor.b / texColor.b;\n         }\n         resultFore = min(vOne, resultFore);\n     } else if (blendMode == 8){    //add\n         resultFore = canvasColor.rgb + texColor.rgb;\n         resultFore = min(vOne, resultFore);\n     } else if (blendMode == 9){    //substract\n         resultFore = canvasColor.rgb - texColor.rgb;\n         resultFore = max(vZero, resultFore);\n     } else if (blendMode == 10){   //diff\n         resultFore = abs(canvasColor.rgb - texColor.rgb);\n     } else if (blendMode == 11){   //darken\n         resultFore = min(canvasColor.rgb, texColor.rgb);\n     } else if (blendMode == 12){   //lighten\n         resultFore = max(canvasColor.rgb, texColor.rgb);\n     }\n     //pre multiply for glBlendFunc\n     vec4 resultColor = vec4(resultFore * texColor.a, texColor.a);\n     return resultColor;\n }\n\nvoid main(void)\n{\n    vec4 canvasColor = gl_LastFragData[0];\n    vec4 texColor = texture2D(inputImageTexture2, textureCoordinate);\n    gl_FragColor = blendColor(texColor, canvasColor);\n}\n";
  public static final String TEST_FILAMENT_FRAGMENT_SHADER_GLSL = "#version 300 es\nprecision highp float;\nlayout(location = 0) out vec4 fragColor;\n\n void main(void) {\n     const vec3 _347[2] = vec3[](vec3(1, 1, 1), vec3(1, 1, 1));\n\n     float _1025 = 0.0;\n     for (uint _1149 = 0u; _1149 < 2u; _1149++){\n         _1025 += _347[_1149].z;\n     }\n     fragColor = vec4(_1025 / 2.0);\n }";
  public static final String TRIPLE_FADE_TRANSFORM_FRAGMENT_SHADER_DAT = "precision mediump float;\nvarying vec2 textureCoordinate;\nuniform float scales[4];\nuniform float alphaRatios[4];\nuniform int layers;\nuniform sampler2D inputImageTexture;\n\n\nvoid main(void) {\n    vec4 result = vec4(0., 0., 0., 0.);\n    vec4 color;\n    for (int i = 0; i < 4; i++) {\n        if(i >= layers){\n            break;\n        }\n        vec2 v;\n        v.x = (textureCoordinate.x - 0.5) / scales[i] + 0.5;\n        v.y = (textureCoordinate.y - 0.5) / scales[i] + 0.5;\n\n        if(v.x < 0. || v.x > 1. || v.y < 0. || v.y > 1.){\n            color = vec4(0., 0., 0., 1.);\n        } else {\n            color = texture2D(inputImageTexture, v);\n        }\n\n        result += color * alphaRatios[i];\n    }\n    gl_FragColor = result;\n}";
  public static final String UNITY_FUR_BASE_FRAGMENT_SHADER_CONTENT = "precision mediump float;\n\nvarying vec4 uv;\nvarying vec4 lights;\nvarying vec3 Specular;\n\nuniform sampler2D inputImageTexture;    //image\n\nvec4 _BaseColor = vec4(1.0, 1.0, 1.0, 1.0);    // (\"Base Color (RGBA)\", Color)\n\nvec3 pow(vec3 color, float value){\n    return vec3(pow(color.r, value), pow(color.g, value), pow(color.b, value));\n}\n\nvoid main()\n{\n    //贴图计算\n    //fixed3 basecolor = lerp (_BaseColor,_Color*_BaseColor,1-FUR_OFFSET*_Color.a);\n    vec4 color = texture2D(inputImageTexture, uv.xy) ;//*_BaseColor; // base\n    color.rgb *=_BaseColor.rgb;\n    color.rgb *=color.rgb;\n    //贴图计算 END\n    vec3 Lights = lights.rgb ;\n    color.rgb *= Lights ;\n    //color.rgb =i.Specular;\n    color.rgb = pow(color.rgb, 1.0 / 2.2); //线性转伽马 误差无视\n    color.a = 1.0;\n    gl_FragColor = color;\n}";
  public static final String UNITY_FUR_FRAGMENT_SHADER_SIMPLE_CONTENT = "precision mediump float;\n\nvarying vec4 uv;\nvarying vec4 lights;\nvarying vec3 Specular;\n\nuniform float FUR_OFFSET;\n\nuniform sampler2D inputImageTexture;    //image\nuniform sampler2D _SubTex;    //image\n\nvec4 _BaseColor = vec4(1.0, 1.0, 1.0, 1.0);    // (\"Base Color (RGBA)\", Color)\nvec4 _SubTexUV = vec4(1.0, 1.0, 0.0, 0.0);  //XY=NoiseUV,W=flowLV\n\nfloat _tming = 1.0;   //(\"边缘柔和度\",  Range(0.5,3))\nfloat _dming = 1.0;   //(\"尖端透明度\",  Range(0,1))\n\nfloat saturate(float value){\n    if(value > 1.0){\n        return 1.0;\n    } else if(value < 0.0){\n        return 0.0;\n    } else {\n        return value;\n    }\n}\n\nvec3 pow(vec3 color, float value){\n    return vec3(pow(color.r, value), pow(color.g, value), pow(color.b, value));\n}\n\nvoid main()\n{\n    //贴图计算\n    vec3 Noise = texture2D(_SubTex, uv.zw).rgb;\n    //fixed3 basecolor = lerp (_BaseColor,_Color*_BaseColor,1-FUR_OFFSET*_Color.a);\n    vec4 color = texture2D(inputImageTexture, uv.xy) ;//*_BaseColor; // base\n    color.rgb *= _BaseColor.rgb;\n    color.rgb *= color.rgb;\n    //贴图计算 END\n    vec3 Lights = lights.rgb ;\n    float vcolormask = saturate(lights.a + _SubTexUV.z) ;\n\n\n    color.rgb =color.rgb * Lights + Specular;\n    color.rgb *= 1.0 + (1.0 - vcolormask) ;\n\n    float FurMask = 1.0 - _dming *  vcolormask ;//(FlowTex.z * _dming) ; //furmask控制毛发长度\n    float alpha = saturate(Noise.r * 2.0 - (FUR_OFFSET * FUR_OFFSET + (FUR_OFFSET * FurMask * 5.0))) * _tming  ;\n\n    color.a  = alpha;\n\n    color.rgb = pow(color.rgb, 1.0 / 2.2); //线性转伽马 误差无视\n\n    gl_FragColor = color;\n}";
  public static final String UNITY_FUR_VERTEX_SHADER_SIMPLE_CONTENT = "precision mediump float;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec4 color;\nattribute vec2 inputTextureCoordinate;\n\nuniform vec2 _Time;\nuniform float FUR_OFFSET;\nuniform float _Spacing; //扩张范围\n\nuniform vec3 _WorldSpaceCameraPos;\nuniform vec3 _SGameShadowParams;\n\n//uniform sampler2D _MainTex;    //image\n\n// transformations\nuniform mat4 worldViewProj;\nuniform mat4 matWorld;\n\nvarying vec4 uv;\nvarying vec4 lights;\nvarying vec3 Specular;\n\nstruct v2f {\n    vec4 pos;\n    vec4 uv;\n    vec4 lights;\n    vec3 Specular; //环境颜色 可以用单色替代\n};\n\nvec4 _Wind = vec4(5.0, 50.0, 50.0, 0.2);  //Wind（x=频率,yz=扰乱,w=强度）\nvec4 _Gravity = vec4(0.0, 0.0, 0.0, 0.3);   //顶点偏移,W=顶点色扩展强度\nvec4 _UVoffset = vec4(0, 0, 0.2, 0.2);  //UV偏移：XY=UV;ZW=UV扰动\nvec4 _SubTexUV = vec4(1.0, 1.0, 0, 0);  //XY=NoiseUV,W=flowLV\n\nfloat _FresnelLV = 1.0;   //菲涅尔系数\nvec4 _SPColor1 = vec4(0.0, 0.0, 0.0, 1.0);    // (\"SPColor1(RGBA)\", Color)\nvec4 _SPColor2 = vec4(0.0, 0.0, 0.0, 1.0);   // (\"SPColor2(RGBA)\", Color)\nfloat _SHExposure = 1.0;  //(\"环境光强度\", Range(0, 1))\nfloat _FurSHExposure = 1.0;   //环境光强度倍增\nvec4 _Color = vec4(0.5, 0.5, 0.5, 1.0);  // (\"Shadow Color (RGBA)\", Color)\nfloat _LightFilter = 0.0;   //(\"平行光毛发穿透\",  Range(-0.5,0.5))\nvec4 _DirLightColor = vec4(1.0, 1.0, 1.0, 1.0);    //(\"平行光Color (RGBA)\", Color)\nfloat _DirLightExposure = 1.0;    // (\"平行光亮度\", Range(0, 10))\nfloat _FurDirLightExposure = 1.0; //(\"平行光亮度倍增\", Range(0, 10))\nfloat _glossiness_1 = 2.0;    //(\"glossiness1_POW\",  Range(0.2,100.0))\nfloat _glossiness_2 = 55.0;   //(\"glossiness2_POW\",  Range(1.0,100.0))\nfloat _specOff = 0.0; // (\"高光偏移\",  Range(-2.0,2.0))\n\nvec4 UnityObjectToClipPos(vec4 pos){\n    return worldViewProj * pos;\n}\n\nvec3 pow(vec3 color, float value){\n    return vec3(pow(color.r, value), pow(color.g, value), pow(color.b, value));\n}\n\nvec3 lerp(vec3 a, vec3 b, float w) {\n    return a + w * (b-a);\n}\n\n\nfloat saturate(float value){\n    if(value > 1.0){\n        return 1.0;\n    } else if(value < 0.0){\n        return 0.0;\n    } else {\n        return value;\n    }\n}\n\nvec3 GammaToLinearSpace (vec3 sRGB)\n{\n    // Approximate version from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\n//vec3 CalcEnvDiffuseBrdf(vec3 normal)\n//{\n//    vec4 n = _envRot * vec4(normal, 1.0);\n//    vec3 envDiffuse = vec3(dot(n, _envSHR * n), dot(n, _envSHG * n), dot(n, _envSHB * n));\n//    //return (envDiffuse) * _EnvExposure;\n//    return GammaToLinearSpace( envDiffuse ) * _SHExposure * _FurSHExposure;\n//}\n\nfloat StrandSpecular(vec3 T, vec3 V, vec3 L, float exponent)\n{\n    vec3 H = normalize(L + V);\n    float dotTH = dot(T, H);\n    float sinTH = sqrt(1.0 - dotTH * dotTH);\n    float dirAtten = smoothstep(-1.0, 0.0, dotTH);\n    return dirAtten * pow(sinTH, exponent);\n}\n\nvec3 SH(vec3 ref_dir)\n{\n\n    mat4 sh_r = mat4(-0.033192723, -0.001821944, 0.207927387, 0.018505111,\n    0.000000000, 0.033192723, -0.116561720, 0.125891055,\n    0.000000000, 0.000000000, -0.004179386, -0.119403430,\n    0.000000000, 0.000000000, 0.000000000, 0.727640226);\n\n    mat4 sh_g = mat4(-0.040833838, -0.005019249, 0.209770154, 0.001172696,\n    0.000000000, 0.040833838, -0.119359312, 0.165181556,\n    0.000000000, 0.000000000, -0.010006203, -0.124774773,\n    0.000000000, 0.000000000, 0.000000000, 0.725567236);\n\n    mat4 sh_b = mat4(-0.051333459, 0.000662888, 0.191847408, -0.016157521,\n    0.000000000, 0.051333459, -0.120322257, 0.227566714,\n    0.000000000, 0.000000000, -0.024883129, -0.127375589,\n    0.000000000, 0.000000000, 0.000000000, 0.695387512);\n\n    float env_rot = 0.0;\n\n    float PIX2 = 6.283185307179586476925286766559;\n    float rot = env_rot * PIX2;\n\n    float cos_env_rot = cos(rot);\n    float sin_env_rot = sin(rot);\n\n    vec4 irrad_dir = vec4(normalize(vec3(cos_env_rot * ref_dir.x + sin_env_rot * ref_dir.z, ref_dir.y, -sin_env_rot * ref_dir.x + cos_env_rot * ref_dir.z)), 1.0);\n\n    float r = dot(irrad_dir, sh_r * irrad_dir);\n    float g = dot(irrad_dir, sh_g * irrad_dir);\n    float b = dot(irrad_dir, sh_b * irrad_dir);\n\n    return pow(vec3(r, g, b),1.33) * _SHExposure *_FurSHExposure;\n}\n\nvoid main(){\n    float spacing = _Spacing * 0.1;\n\n    v2f o;\n\n    vec3 forceDirection = vec3(0.0, 0.0, 0.0);\n\n    // Wind 低配可以去掉===============================================\n    forceDirection.x = sin(_Time.y* 1.5*_Wind.x + position.x * 0.5*_Wind.z) *_Wind.w;\n    forceDirection.y = cos(_Time.y * 0.5*_Wind.x + position.y * 0.4*_Wind.y) * _Wind.w;\n    forceDirection.z = sin(_Time.y * 0.7 *_Wind.x+ position.y * 0.3*_Wind.y) * _Wind.w;\n\n    // 顶点offset===============================================\n    vec3 displacement = forceDirection + _Gravity.xyz; //顶点方向\n    float displacementFactor = FUR_OFFSET * FUR_OFFSET ;\n\n    vec3 aNormal = normal.xyz;\n    aNormal.xyz += displacement * displacementFactor * normal.z;\n    vec3 n = (aNormal) * FUR_OFFSET * (spacing * saturate( color.w+_Gravity.w)); //spacing顶点色alpha通道控制毛发扩展长度\n\n    vec4 wpos =  (vec4(position.xyz + n.xyz, 1.0));\n    o.pos =  UnityObjectToClipPos(wpos);\n\n    // uv offuse===============================================\n    vec2 uvoffset= _UVoffset.xy  * FUR_OFFSET  + (forceDirection.xy * _UVoffset.zw * FUR_OFFSET) ;\n    uvoffset *=  0.1 ; //尺寸太小不好调整 缩小精度。\n    vec2 flowmap = (color.xy * vec2(2.0) - vec2(1.0)) * _SubTexUV.w * FUR_OFFSET * 0.1; //flowmap\n    //flowmap *= half2(1,1)/half2(_SubTexUV.w,_SubTexUV.w);\n\n    vec2 uv1= inputTextureCoordinate.xy + (uvoffset + flowmap) * (vec2(1.0, 1.0)/_SubTexUV.xy) ;\n    vec2 uv2= inputTextureCoordinate.xy *_SubTexUV.xy + uvoffset + flowmap;\n    o.uv = vec4(uv1,uv2);\n\n    //坐标===============================================\n    vec3 worldPos = (matWorld * position).xyz;\n    vec3 N = normalize((matWorld * vec4(normal, 0)).xyz);\n    vec3 T = (matWorld * vec4(tangent.xyz, 0)).xyz;\n    vec3 BT = normalize(cross(N,T));\n\n    vec3 V = normalize(_WorldSpaceCameraPos - worldPos);\n    vec3 L = normalize(-_SGameShadowParams.xyz);\n    vec3 R = vec3(normalize(V + L));\n\n    //灯光 ===============================================\n    float NoV = saturate(dot(N, V));\n    float NoL = dot(L, N);\n    float Occlusion = FUR_OFFSET * FUR_OFFSET;\n    //轮廓光------------------\n    float RimLight = (1.0 - NoV) ;//*_FresnelLV ;\n    RimLight *= Occlusion;\n    RimLight *= RimLight + (1.0 - NoV);\n    RimLight *= _FresnelLV ;\n    //环境光------------------\n    vec3 SHL = vec3(0.3, 0.3, 0.3);  //环境颜色 可以用单色替代\n    SHL = SH(N);\n    //SHL *= _SHExposure; //环境光转到线性空间 简易\n    SHL = lerp (SHL, _Color.xyz * SHL, 1.0 - Occlusion * _Color.a); //环境颜色与AO颜色\n    SHL += SHL * RimLight;\n    //平行光------------------\n    float FurFilter = (_Spacing * 0.5);\n    float DirLight = saturate(NoL * (1.0 + _LightFilter) + _LightFilter * 0.5 + Occlusion * FurFilter);//saturate(Occlusion *_LightFilter+(1-_LightFilter)*0.5);//丰富灯光细节\n    //DirLight= saturate (DirLight);\n    vec3 diffuseSum = SHL + DirLight * _FurDirLightExposure * _DirLightExposure * _DirLightColor.xyz  ; //灯光与环境合并\n    o.lights.rgb = diffuseSum ;\n    o.lights.a = color.a;\n\n    //Sp_Anisotropy\n    vec2 Roughness = vec2(_glossiness_1,_glossiness_2);\n    vec3 T1 = normalize(_specOff*N+BT);\n    float SPec1 = StrandSpecular (T1,V,L,Roughness.x);//*FUR_OFFSET;\n    float SPec2 = StrandSpecular (T1,V,L,Roughness.y) *FUR_OFFSET;\n    o.Specular = (SPec1 * _SPColor1.rgb + SPec2 * _SPColor2.rgb) * saturate(NoL);\n\n    gl_Position = o.pos;\n    uv = o.uv;\n    lights = o.lights;\n    Specular = o.Specular;\n}";
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.tim\classes12.jar
 * Qualified Name:     com.tencent.ttpic.filter.shader.ShaderContentConstans
 * JD-Core Version:    0.7.0.1
 */