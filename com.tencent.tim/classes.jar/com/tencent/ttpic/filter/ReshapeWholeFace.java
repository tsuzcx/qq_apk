package com.tencent.ttpic.filter;

import com.tencent.aekit.openrender.AEOpenRenderConfig.DRAW_MODE;
import com.tencent.aekit.openrender.UniformParam.FloatParam;
import com.tencent.aekit.openrender.UniformParam.FloatsParam;
import com.tencent.aekit.openrender.internal.VideoFilterBase;
import com.tencent.ttpic.openapi.filter.ReshapeType;
import java.util.Map;

public class ReshapeWholeFace
  extends VideoFilterBase
{
  public static final String FRAGMENT_SHADER_NORMAL = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n    //gl_FragColor = vec4(inputTextureCoordinate.xy, vec2(0.0, 1.0));\n\n    //vec4 color = vec4(textureCoordinate.x*8.0+0.5, textureCoordinate.y*8.0+0.5, 0.5, 1.0);\n    //gl_FragColor = color;\n\n    //gl_FragColor = vec4(textureCoordinate, textureCoordinate.x, 1.0);\n\n    gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n}";
  private static final String FRAGMENT_SHADER_VTF = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n\n    //vec2 diffPosition = textureCoordinate;\n    //float ddx = (diffPosition.x + 1.0) / 2.0;\n    //float ddy = (diffPosition.y + 1.0) / 2.0;\n    //diffPosition = vec2(ddx,ddy);\n    //vec2 a = fract(diffPosition * 255.0 / 256.0);\n    //vec2 b = fract(diffPosition * 255.0 * 255.0 / 256.0);\n    //gl_FragColor = vec4(a,b);\n\n    // 新版的 shader 颜色通道中记录的是位移偏移量，只有在最后 combinedFilter 才最终将所有 filter 的位移量叠加，去图上取点。这样的好处是：\n    // 1. 只有 128 * 128 个点\n    // 2. smoothstep 会更平滑，128 * 128 个点取插值，原来的处理方法会使像素点变模糊\n    // 3. 两个矩形交叠的地方，位移处理的先后顺序不影响结果（不能说这是好还是坏，因为 PS 的液化是作用在原图上的）\n\n    // 至于此处要改为 * 255 再 / 255 是为了提升精度（浮点纹理 iOS 不支持，而一个字节只能表示 256 个不同值）\n    // 本来小奇使用了浮点纹理，但是发现有机型不支持，不用浮点纹理又精度不够，所以采用这个方法，变成2个字节表示一个值，提升了精度。\n    vec2 diffPosition = textureCoordinate;\n    diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;  // 0.5 * (diffPosition + 1.0) 是将(-1, 1)间的值转换到(0, 1)，\n    vec2 a = floor(diffPosition) / 255.0;\n    vec2 b = fract(diffPosition);\n    gl_FragColor = vec4(a, b);\n\n\n    //vec2 diffPosition = textureCoordinate;\n    //diffPosition = 0.5 * (diffPosition + 1.0) * 256.0;\n    //vec2 a = floor(diffPosition) / 256.0;\n    //vec2 b = fract(diffPosition);\n    //gl_FragColor = vec4(a, b);\n}\n";
  public static final String VERTEX_SHADER_NORMAL = "precision highp float;\n\nattribute vec4 position;\n//common\nuniform float sin_t;\nuniform float cos_t;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\nvarying highp vec2 textureCoordinate;\n\n//eye\nuniform vec2 leftEyePlainSize;\nuniform vec2 leftEyeCenter;\nuniform vec2 rightEyePlainSize;\nuniform vec2 rightEyeCenter;\nuniform float eyesSize; // it is eye size adjust factor\nuniform float eyesWidth; // it is eye width adjust factor\nuniform float eyesHeight; // it is eye height adjust factor\nuniform float eyesTiltAngle; // rotate angle need to apply\nuniform float eyesDistance;\n\n//nose\nuniform vec2 nose3DCenter;\nuniform vec2 nosePlainSize;\nuniform vec2 nostrilsCenter;\nuniform vec2 nostrilsPlaneSize;\nuniform vec2 noseTipCenter;\nuniform vec2 noseTipPlaneSize;\nuniform vec2 noseBottomCenter;\nuniform float noseSize;\nuniform float noseOutlineWidth;\nuniform float noseBridgeWidth;\nuniform float nosePosition;\nuniform float noseTipSize;\n\n//lips\nuniform vec2 lipsCenter;\nuniform vec2 lipsPlainSize;\nuniform float lipsSize;\nuniform float lipsWidth;\nuniform float lipsHeight;\nuniform float lipsYPosition;\n\n//wrinkle\nuniform vec2 lipsLeftEdge;\nuniform vec2 lipsRightEdge;\nuniform float faceSmile;\n\n//jaw\nuniform vec2 jawCenterOfGravity;\nuniform vec2 jawSize;\nuniform float faceJaw;\n\n//eye brow\nuniform vec2 leftEyebrowPlainSize;\nuniform vec2 leftEyebrowCenter;\nuniform vec2 rightEyebrowPlainSize;\nuniform vec2 rightEyebrowCenter;\nuniform float eyebrowHeight; // eyebrow height adjust factor\nuniform float eyebrowDistance;\nuniform float eyebrowTiltAngle; // rotate angle need to apply\n\n//face width\nuniform vec2 facePlainSize;\nuniform vec2 faceCenter;\nuniform float faceWidth;\nuniform float faceWidth2;\n\nuniform vec2 facePlainSizeLeft2;\nuniform vec2 faceCenterLeft2;\nuniform float leftAngle2;\nuniform vec2 facePlainSizeRight2;\nuniform vec2 faceCenterRight2;\nuniform float rightAngle2;\nuniform vec2 faceMoveCenter2;\n\nuniform vec2 facePlainSizeUpLeft2;\nuniform vec2 faceCenterUpLeft2;\nuniform float upLeftAngle2;\nuniform vec2 facePlainSizeUpRight2;\nuniform vec2 faceCenterUpRight2;\nuniform float upRightAngle2;\n\n//forehead\nuniform vec2 foreheadSize;\nuniform vec2 foreheadCenter;\nuniform float foreheadHeight;\n\nconst float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\nconst float kPi = 3.14159265358979;\nconst float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\nuniform sampler2D inputImageTexture;\n\n//common func\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\nvec2 rotate2DPoint(vec2 point, float angle) {\n    return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n}\n\nfloat face_getLeftEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), position.xy, leftEyeCenter, leftEyePlainSize, 0.5, 1.2);\n}\nfloat face_getRightEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), position.xy, rightEyeCenter, rightEyePlainSize, 0.5, 1.2);\n}\nfloat face_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.5, 1.0);\n}\nfloat face_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.5, 1.0);\n}\nfloat face_getLipsMask() {\n    return getEllipseMask(vec2(1.5, 1.5), position.xy, lipsCenter, lipsPlainSize, 0.5, 1.2);\n}\nfloat face_getNoseMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n}\nfloat face_getFaceMask() {\n    return getEllipseMask(vec2(1.5, 1.2), position.xy, faceCenter, facePlainSize, 0.7, 0.9);\n}\nfloat face_getFaceMaskLeft2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, faceCenterLeft2, facePlainSizeLeft2, 0.5, 2.0, leftAngle2);\n}\nfloat face_getFaceMaskRight2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, faceCenterRight2, facePlainSizeRight2, 0.5, 2.0, rightAngle2);\n}\nfloat face_getFaceMaskUpLeft2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, faceCenterUpLeft2, facePlainSizeUpLeft2, 0.5, 0.8, upLeftAngle2);\n}\nfloat face_getFaceMaskUpRight2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, faceCenterUpRight2, facePlainSizeUpRight2, 0.5, 0.8, upRightAngle2);\n}\nvec2 face_getScaledFacePoint2(vec2 originalPoint, float scalingFactor, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    vec2 v = originalPoint - faceCenter;\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return originalPoint+sc;\n}\n\nvec2 getFaceWidthDiff() {\n     float faceNegativeRegionsMask = (1.0 - 0.8*face_getLeftEyeMask()) * (1.0 - 0.8*face_getRightEyeMask()) * (1.0 - 0.8*face_getLeftEyebrowMask()) * (1.0 - 0.8*face_getRightEyebrowMask()) * (1.0 - 0.6*face_getLipsMask()) * (1.0 - 0.9*face_getNoseMask());\n     float faceCoarseMask   = face_getFaceMask();\n     //width\n     vec2 displacedFacePoint   = face_getScaledFacePoint2(position.xy, faceWidth, faceCoarseMask*faceNegativeRegionsMask);\n\n     vec2 displacedFacePoint1 = displacedFacePoint;\n     for (int i = 0; i < 5; i++){   //4 times\n         float thres = 1.2;\n         if (i == 4) thres = 1.0;\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (faceMoveCenter2 - faceCenterLeft2)* 0.1, face_getFaceMaskLeft2(displacedFacePoint1) * faceWidth2 * thres);\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (faceMoveCenter2 - faceCenterRight2)* 0.1, face_getFaceMaskRight2(displacedFacePoint1) * faceWidth2 * thres);\n     }\n     vec2 displacedFacePoint2 = displacedFacePoint;\n     for (int i = 0; i < 3; i++){\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (faceMoveCenter2 - faceCenterUpLeft2)* 0.1, face_getFaceMaskUpLeft2(displacedFacePoint2) * faceWidth2);\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (faceMoveCenter2 - faceCenterUpRight2)* 0.1, face_getFaceMaskUpRight2(displacedFacePoint2) * faceWidth2);\n     }\n     vec2 diffPosition = displacedFacePoint1 - displacedFacePoint + displacedFacePoint2 - displacedFacePoint + displacedFacePoint - position.xy;\n\n     return diffPosition;\n }\n\n\nfloat jaw_getLipsMask() {\n    return getEllipseMask(vec2(1.4, 1.0), position.xy, lipsCenter, lipsPlainSize, 0.5, 1.2);\n}\nfloat jaw_getNoseMask() {\n    return getEllipseMask(vec2(1.0, 1.5), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n}\nfloat jaw_getJawMask() {\n    return getEllipseMask(vec2(1.8, 1.0), position.xy, jawCenterOfGravity, jawSize, 0.5, 1.2);\n}\nvec2 getJawDiff() {\n    float lipsMask = jaw_getLipsMask();\n    float noseMask = jaw_getNoseMask();\n    float jawMask = jaw_getJawMask() * (1.0 - 0.9 * lipsMask) * (1.0 - 0.9 * noseMask);\n\n    vec2 displacedPoint = position.xy;\n\n    const float kJawLiftingYRatio = 0.1;\n    vec2 jawLiftingVector = vec2(0.0, kJawLiftingYRatio * jawSize.y);\n    jawLiftingVector = vec2(dot(jawLiftingVector, vec2(cos_t, -sin_t)), dot(jawLiftingVector, vec2(sin_t, cos_t)));\n    vec2 jawPositionPoint = displacedPoint + jawLiftingVector;\n    vec2 displacedPoint2 = mix(displacedPoint, jawPositionPoint, faceJaw * jawMask);\n\n    const vec2 kScaleFactors = vec2(1.1, 1.1);\n    displacedPoint = jawCenterOfGravity + kScaleFactors * (position.xy - jawCenterOfGravity);\n    displacedPoint = mix(position.xy, displacedPoint, faceJaw * jawMask);\n\n    displacedPoint = displacedPoint * 0.65 + displacedPoint2 * 0.35;\n    vec2 diffPosition = displacedPoint - position.xy;\n    return diffPosition;\n}\n\nfloat head_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.6, 1.0);\n}\nfloat head_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.6, 1.0);\n}\nfloat head_getForeheadMask() {\n    return getEllipseMask(vec2(1.9, 1.6), position.xy, foreheadCenter, foreheadSize, 0.2, 1.4);\n}\n\nvec2 getForeHeadDiff() {\n    float foreheadMask    = head_getForeheadMask() * (1.0 - head_getLeftEyebrowMask()) * (1.0 - head_getRightEyebrowMask());\n    vec2 displacedForeheadPoint   = position.xy;\n\n    const float kForeheadLiftingYRatio = 0.05518821053;\n    vec2 foreheadLiftingVector = vec2(0.0, -kForeheadLiftingYRatio * foreheadSize.y);\n    foreheadLiftingVector = vec2(dot(foreheadLiftingVector, vec2(cos_t, -sin_t)), dot(foreheadLiftingVector, vec2(sin_t, cos_t)));\n    vec2 foreheadPositionPoint = displacedForeheadPoint + foreheadLiftingVector;\n    displacedForeheadPoint = mix(displacedForeheadPoint, foreheadPositionPoint, foreheadMask * foreheadHeight);\n\n    vec2 diffPosition = displacedForeheadPoint - position.xy;\n    return diffPosition;\n}\n\nvec2 wrinkle_rotate2DPointAroundCenter(in vec2 point, in vec2 center, in float angle) {\n    return center + rotate2DPoint(point - center, angle);\n}\nvec2 wrinkle_getRotatedLipsEdgeWrinkle(in vec2 originalPoint, in int isLeftSide) {\n    vec2 wrinkleSize = 1.1*vec2(kLipsEdgeWrinkleSizeToLipsSizeRatio * lipsPlainSize.x, 0.6*lipsPlainSize.y);\n    vec2 lipsEdge = isLeftSide == 1 ? lipsLeftEdge : lipsRightEdge;\n    float directionSign = isLeftSide == 1 ? 1.0 : -1.0;\n    vec2 wrinkleCenter = lipsEdge + directionSign * 0.055 * (lipsRightEdge - lipsLeftEdge);\n\n    float wrinkleMask = getEllipseMask(vec2(0.8, 0.5), position.xy, wrinkleCenter,wrinkleSize, 0.5, 1.2);\n    vec2 wrinkleRotationCenter = lipsEdge + directionSign * 0.2 * (lipsRightEdge - lipsLeftEdge);\n    vec2 rotated2DPoint = wrinkle_rotate2DPointAroundCenter(originalPoint, wrinkleRotationCenter, - directionSign * wrinkleMask * kLipsEdgeWrinklesRotationAngle);\n    return rotated2DPoint;\n}\nvec2 wrinkle_getRotatedLipsLeftEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 1);\n}\nvec2 wrinkle_getRotatedLipsRightEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 0);\n}\n\nfloat wrinkle_getNoseMask() {\n    return getEllipseMask(vec2(1.2, 1.5), position.xy, nose3DCenter.xy, nosePlainSize, 0.8, 1.0);\n}\nvec2 getWrinkleDiff() {\n    vec2 displacedPoint = position.xy;\n    float _noseMask = wrinkle_getNoseMask() * 0.8;\n    displacedPoint = mix(wrinkle_getRotatedLipsLeftEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    displacedPoint = mix(wrinkle_getRotatedLipsRightEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    vec2 displacedPosition = position.xy + faceSmile * (displacedPoint - position.xy);\n    vec2 diffPosition = displacedPosition - position.xy;\n    return diffPosition;\n}\n\nvoid main(){\n    vec2 diffPosition =  getJawDiff() + getFaceWidthDiff() + getForeHeadDiff() + getWrinkleDiff();\n    textureCoordinate = diffPosition + position.xy;\n    gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n}\n";
  public static final String VERTEX_SHADER_VTF = "precision highp float;\n\nattribute vec4 position;\n//common\nuniform float sin_t;\nuniform float cos_t;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\nvarying highp vec2 textureCoordinate;\n\n//eye\nuniform vec2 leftEyePlainSize;\nuniform vec2 leftEyeCenter;\nuniform vec2 rightEyePlainSize;\nuniform vec2 rightEyeCenter;\nuniform float eyesSize; // it is eye size adjust factor\nuniform float eyesWidth; // it is eye width adjust factor\nuniform float eyesHeight; // it is eye height adjust factor\nuniform float eyesTiltAngle; // rotate angle need to apply\nuniform float eyesDistance;\n\n//nose\nuniform vec2 nose3DCenter;\nuniform vec2 nosePlainSize;\nuniform vec2 nostrilsCenter;\nuniform vec2 nostrilsPlaneSize;\nuniform vec2 noseTipCenter;\nuniform vec2 noseTipPlaneSize;\nuniform vec2 noseBottomCenter;\nuniform float noseSize;\nuniform float noseOutlineWidth;\nuniform float noseBridgeWidth;\nuniform float nosePosition;\nuniform float noseTipSize;\n\n//lips\nuniform vec2 lipsCenter;\nuniform vec2 lipsPlainSize;\nuniform float lipsSize;\nuniform float lipsWidth;\nuniform float lipsHeight;\nuniform float lipsYPosition;\n\n//wrinkle\nuniform vec2 lipsLeftEdge;\nuniform vec2 lipsRightEdge;\nuniform float faceSmile;\n\n//jaw\nuniform vec2 jawCenterOfGravity;\nuniform vec2 jawSize;\nuniform float faceJaw;\n\n//eye brow\nuniform vec2 leftEyebrowPlainSize;\nuniform vec2 leftEyebrowCenter;\nuniform vec2 rightEyebrowPlainSize;\nuniform vec2 rightEyebrowCenter;\nuniform float eyebrowHeight; // eyebrow height adjust factor\nuniform float eyebrowDistance;\nuniform float eyebrowTiltAngle; // rotate angle need to apply\n\n//face width\nuniform vec2 facePlainSize;\nuniform vec2 faceCenter;\nuniform float faceWidth;\nuniform float faceWidth2;\n\nuniform vec2 facePlainSizeLeft2;\nuniform vec2 faceCenterLeft2;\nuniform float leftAngle2;\nuniform vec2 facePlainSizeRight2;\nuniform vec2 faceCenterRight2;\nuniform float rightAngle2;\nuniform vec2 faceMoveCenter2;\n\nuniform vec2 facePlainSizeUpLeft2;\nuniform vec2 faceCenterUpLeft2;\nuniform float upLeftAngle2;\nuniform vec2 facePlainSizeUpRight2;\nuniform vec2 faceCenterUpRight2;\nuniform float upRightAngle2;\n\n//forehead\nuniform vec2 foreheadSize;\nuniform vec2 foreheadCenter;\nuniform float foreheadHeight;\n\nconst float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\nconst float kPi = 3.14159265358979;\nconst float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\nuniform sampler2D inputImageTexture;\n\n//common func\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\nvec2 rotate2DPoint(vec2 point, float angle) {\n    return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n}\n\nfloat face_getLeftEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), position.xy, leftEyeCenter, leftEyePlainSize, 0.5, 1.2);\n}\nfloat face_getRightEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), position.xy, rightEyeCenter, rightEyePlainSize, 0.5, 1.2);\n}\nfloat face_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.5, 1.0);\n}\nfloat face_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.5, 1.0);\n}\nfloat face_getLipsMask() {\n    return getEllipseMask(vec2(1.5, 1.5), position.xy, lipsCenter, lipsPlainSize, 0.5, 1.2);\n}\nfloat face_getNoseMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n}\nfloat face_getFaceMask() {\n    return getEllipseMask(vec2(1.5, 1.2), position.xy, faceCenter, facePlainSize, 0.7, 0.9);\n}\nfloat face_getFaceMaskLeft2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, faceCenterLeft2, facePlainSizeLeft2, 0.5, 2.0, leftAngle2);\n}\nfloat face_getFaceMaskRight2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, faceCenterRight2, facePlainSizeRight2, 0.5, 2.0, rightAngle2);\n}\nfloat face_getFaceMaskUpLeft2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, faceCenterUpLeft2, facePlainSizeUpLeft2, 0.5, 0.8, upLeftAngle2);\n}\nfloat face_getFaceMaskUpRight2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, faceCenterUpRight2, facePlainSizeUpRight2, 0.5, 0.8, upRightAngle2);\n}\nvec2 face_getScaledFacePoint2(vec2 originalPoint, float scalingFactor, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    vec2 v = originalPoint - faceCenter;\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return originalPoint+sc;\n}\n\nvec2 getFaceWidthDiff() {\n     float faceNegativeRegionsMask = (1.0 - 0.8*face_getLeftEyeMask()) * (1.0 - 0.8*face_getRightEyeMask()) * (1.0 - 0.8*face_getLeftEyebrowMask()) * (1.0 - 0.8*face_getRightEyebrowMask()) * (1.0 - 0.6*face_getLipsMask()) * (1.0 - 0.9*face_getNoseMask());\n     float faceCoarseMask   = face_getFaceMask();\n     //width\n     vec2 displacedFacePoint   = face_getScaledFacePoint2(position.xy, faceWidth, faceCoarseMask*faceNegativeRegionsMask);\n\n     vec2 displacedFacePoint1 = displacedFacePoint;\n     for (int i = 0; i < 5; i++){   //4 times\n         float thres = 1.2;\n         if (i == 4) thres = 1.0;\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (faceMoveCenter2 - faceCenterLeft2)* 0.1, face_getFaceMaskLeft2(displacedFacePoint1) * faceWidth2 * thres);\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (faceMoveCenter2 - faceCenterRight2)* 0.1, face_getFaceMaskRight2(displacedFacePoint1) * faceWidth2 * thres);\n     }\n     vec2 displacedFacePoint2 = displacedFacePoint;\n     for (int i = 0; i < 3; i++){\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (faceMoveCenter2 - faceCenterUpLeft2)* 0.1, face_getFaceMaskUpLeft2(displacedFacePoint2) * faceWidth2);\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (faceMoveCenter2 - faceCenterUpRight2)* 0.1, face_getFaceMaskUpRight2(displacedFacePoint2) * faceWidth2);\n     }\n     vec2 diffPosition = displacedFacePoint1 - displacedFacePoint + displacedFacePoint2 - displacedFacePoint + displacedFacePoint - position.xy;\n\n     return diffPosition;\n }\n\n\nfloat jaw_getLipsMask() {\n    return getEllipseMask(vec2(1.4, 1.0), position.xy, lipsCenter, lipsPlainSize, 0.5, 1.2);\n}\nfloat jaw_getNoseMask() {\n    return getEllipseMask(vec2(1.0, 1.5), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n}\nfloat jaw_getJawMask() {\n    return getEllipseMask(vec2(1.8, 1.0), position.xy, jawCenterOfGravity, jawSize, 0.5, 1.2);\n}\nvec2 getJawDiff() {\n    float lipsMask = jaw_getLipsMask();\n    float noseMask = jaw_getNoseMask();\n    float jawMask = jaw_getJawMask() * (1.0 - 0.9 * lipsMask) * (1.0 - 0.9 * noseMask);\n\n    vec2 displacedPoint = position.xy;\n\n    const float kJawLiftingYRatio = 0.1;\n    vec2 jawLiftingVector = vec2(0.0, kJawLiftingYRatio * jawSize.y);\n    jawLiftingVector = vec2(dot(jawLiftingVector, vec2(cos_t, -sin_t)), dot(jawLiftingVector, vec2(sin_t, cos_t)));\n    vec2 jawPositionPoint = displacedPoint + jawLiftingVector;\n    vec2 displacedPoint2 = mix(displacedPoint, jawPositionPoint, faceJaw * jawMask);\n\n    const vec2 kScaleFactors = vec2(1.1, 1.1);\n    displacedPoint = jawCenterOfGravity + kScaleFactors * (position.xy - jawCenterOfGravity);\n    displacedPoint = mix(position.xy, displacedPoint, faceJaw * jawMask);\n\n    displacedPoint = displacedPoint * 0.65 + displacedPoint2 * 0.35;\n    vec2 diffPosition = displacedPoint - position.xy;\n    return diffPosition;\n}\n\nfloat head_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.6, 1.0);\n}\nfloat head_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.6, 1.0);\n}\nfloat head_getForeheadMask() {\n    return getEllipseMask(vec2(1.9, 1.6), position.xy, foreheadCenter, foreheadSize, 0.2, 1.4);\n}\n\nvec2 getForeHeadDiff() {\n    float foreheadMask    = head_getForeheadMask() * (1.0 - head_getLeftEyebrowMask()) * (1.0 - head_getRightEyebrowMask());\n    vec2 displacedForeheadPoint   = position.xy;\n\n    const float kForeheadLiftingYRatio = 0.05518821053;\n    vec2 foreheadLiftingVector = vec2(0.0, -kForeheadLiftingYRatio * foreheadSize.y);\n    foreheadLiftingVector = vec2(dot(foreheadLiftingVector, vec2(cos_t, -sin_t)), dot(foreheadLiftingVector, vec2(sin_t, cos_t)));\n    vec2 foreheadPositionPoint = displacedForeheadPoint + foreheadLiftingVector;\n    displacedForeheadPoint = mix(displacedForeheadPoint, foreheadPositionPoint, foreheadMask * foreheadHeight);\n\n    vec2 diffPosition = displacedForeheadPoint - position.xy;\n    return diffPosition;\n}\n\nvec2 wrinkle_rotate2DPointAroundCenter(in vec2 point, in vec2 center, in float angle) {\n    return center + rotate2DPoint(point - center, angle);\n}\nvec2 wrinkle_getRotatedLipsEdgeWrinkle(in vec2 originalPoint, in int isLeftSide) {\n    vec2 wrinkleSize = 1.1*vec2(kLipsEdgeWrinkleSizeToLipsSizeRatio * lipsPlainSize.x, 0.6*lipsPlainSize.y);\n    vec2 lipsEdge = isLeftSide == 1 ? lipsLeftEdge : lipsRightEdge;\n    float directionSign = isLeftSide == 1 ? 1.0 : -1.0;\n    vec2 wrinkleCenter = lipsEdge + directionSign * 0.055 * (lipsRightEdge - lipsLeftEdge);\n\n    float wrinkleMask = getEllipseMask(vec2(0.8, 0.5), position.xy, wrinkleCenter,wrinkleSize, 0.5, 1.2);\n    vec2 wrinkleRotationCenter = lipsEdge + directionSign * 0.2 * (lipsRightEdge - lipsLeftEdge);\n    vec2 rotated2DPoint = wrinkle_rotate2DPointAroundCenter(originalPoint, wrinkleRotationCenter, - directionSign * wrinkleMask * kLipsEdgeWrinklesRotationAngle);\n    return rotated2DPoint;\n}\nvec2 wrinkle_getRotatedLipsLeftEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 1);\n}\nvec2 wrinkle_getRotatedLipsRightEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 0);\n}\n\nfloat wrinkle_getNoseMask() {\n    return getEllipseMask(vec2(1.2, 1.5), position.xy, nose3DCenter.xy, nosePlainSize, 0.8, 1.0);\n}\nvec2 getWrinkleDiff() {\n    vec2 displacedPoint = position.xy;\n    float _noseMask = wrinkle_getNoseMask() * 0.8;\n    displacedPoint = mix(wrinkle_getRotatedLipsLeftEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    displacedPoint = mix(wrinkle_getRotatedLipsRightEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    vec2 displacedPosition = position.xy + faceSmile * (displacedPoint - position.xy);\n    vec2 diffPosition = displacedPosition - position.xy;\n    return diffPosition;\n}\n\nvoid main(){\n    vec2 diffPosition =  getJawDiff() + getFaceWidthDiff() + getForeHeadDiff() + getWrinkleDiff();\n    vec4 color = texture2D(inputImageTexture, position.xy);\n    vec2 offset = (color.xy * 255.0 + color.zw) / 127.5 - 1.0;\n    textureCoordinate = diffPosition + offset;\n\n    gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n}\n";
  private static final int XCOORD_NUM = 128;
  private static final int YCOORD_NUM = 128;
  private static float[] mFullscreenVerticesPortrait;
  private static float[] mInitTextureCoordinatesPortrait;
  private float[] angles = { 0.0F, 0.0F, 0.0F };
  private float[] faceCenter = { 0.0F, 0.0F };
  private float[] faceCenterLeft2 = { 0.0F, 0.0F };
  private float[] faceCenterRight2 = { 0.0F, 0.0F };
  private float[] faceCenterUpLeft2 = { 0.0F, 0.0F };
  private float[] faceCenterUpRight2 = { 0.0F, 0.0F };
  private float faceJaw = 0.0F;
  private float[] faceMoveCenter2 = { 0.0F, 0.0F, 0.0F };
  private float[] facePlainSize = { 0.0F, 0.0F };
  private float[] facePlainSizeLeft2 = { 0.0F, 0.0F };
  private float[] facePlainSizeRight2 = { 0.0F, 0.0F };
  private float[] facePlainSizeUpLeft2 = { 0.0F, 0.0F };
  private float[] facePlainSizeUpRight2 = { 0.0F, 0.0F };
  private float faceSmile = 0.0F;
  private float faceWidth = 1.0F;
  private float faceWidth2 = 1.0F;
  private float[] foreheadCenter = { 0.0F, 0.0F };
  private float foreheadHeight = 0.0F;
  private float[] foreheadSize = { 0.0F, 0.0F };
  private float[] jawCenterOfGravity = { 0.0F, 0.0F };
  private float[] jawSize = { 0.0F, 0.0F };
  private float leftAngle2 = 0.0F;
  private float[] leftEyeCenter = { 0.0F, 0.0F };
  private float[] leftEyePlainSize = { 0.0F, 0.0F };
  private float[] leftEyebrowCenter = { 0.0F, 0.0F };
  private float[] leftEyebrowPlainSize = { 0.0F, 0.0F };
  private float[] lipsCenter = { 0.0F, 0.0F };
  private float[] lipsLeftEdge = { 0.0F, 0.0F };
  private float[] lipsPlainSize = { 0.0F, 0.0F };
  private float[] lipsRightEdge = { 0.0F, 0.0F };
  private float meshType = 0.0F;
  private float[] nose3DCenter = { 0.0F, 0.0F };
  private float[] nosePlainSize = { 0.0F, 0.0F };
  private float rightAngle2 = 0.0F;
  private float[] rightEyeCenter = { 0.0F, 0.0F };
  private float[] rightEyePlainSize = { 0.0F, 0.0F };
  private float[] rightEyebrowCenter = { 0.0F, 0.0F };
  private float[] rightEyebrowPlainSize = { 0.0F, 0.0F };
  private float[] size = { 1.0F, 1.0F };
  private float upLeftAngle2 = 0.0F;
  private float upRightAngle2 = 0.0F;
  
  public ReshapeWholeFace(ReshapeType paramReshapeType)
  {
    super("precision highp float;\n\nattribute vec4 position;\n//common\nuniform float sin_t;\nuniform float cos_t;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\nvarying highp vec2 textureCoordinate;\n\n//eye\nuniform vec2 leftEyePlainSize;\nuniform vec2 leftEyeCenter;\nuniform vec2 rightEyePlainSize;\nuniform vec2 rightEyeCenter;\nuniform float eyesSize; // it is eye size adjust factor\nuniform float eyesWidth; // it is eye width adjust factor\nuniform float eyesHeight; // it is eye height adjust factor\nuniform float eyesTiltAngle; // rotate angle need to apply\nuniform float eyesDistance;\n\n//nose\nuniform vec2 nose3DCenter;\nuniform vec2 nosePlainSize;\nuniform vec2 nostrilsCenter;\nuniform vec2 nostrilsPlaneSize;\nuniform vec2 noseTipCenter;\nuniform vec2 noseTipPlaneSize;\nuniform vec2 noseBottomCenter;\nuniform float noseSize;\nuniform float noseOutlineWidth;\nuniform float noseBridgeWidth;\nuniform float nosePosition;\nuniform float noseTipSize;\n\n//lips\nuniform vec2 lipsCenter;\nuniform vec2 lipsPlainSize;\nuniform float lipsSize;\nuniform float lipsWidth;\nuniform float lipsHeight;\nuniform float lipsYPosition;\n\n//wrinkle\nuniform vec2 lipsLeftEdge;\nuniform vec2 lipsRightEdge;\nuniform float faceSmile;\n\n//jaw\nuniform vec2 jawCenterOfGravity;\nuniform vec2 jawSize;\nuniform float faceJaw;\n\n//eye brow\nuniform vec2 leftEyebrowPlainSize;\nuniform vec2 leftEyebrowCenter;\nuniform vec2 rightEyebrowPlainSize;\nuniform vec2 rightEyebrowCenter;\nuniform float eyebrowHeight; // eyebrow height adjust factor\nuniform float eyebrowDistance;\nuniform float eyebrowTiltAngle; // rotate angle need to apply\n\n//face width\nuniform vec2 facePlainSize;\nuniform vec2 faceCenter;\nuniform float faceWidth;\nuniform float faceWidth2;\n\nuniform vec2 facePlainSizeLeft2;\nuniform vec2 faceCenterLeft2;\nuniform float leftAngle2;\nuniform vec2 facePlainSizeRight2;\nuniform vec2 faceCenterRight2;\nuniform float rightAngle2;\nuniform vec2 faceMoveCenter2;\n\nuniform vec2 facePlainSizeUpLeft2;\nuniform vec2 faceCenterUpLeft2;\nuniform float upLeftAngle2;\nuniform vec2 facePlainSizeUpRight2;\nuniform vec2 faceCenterUpRight2;\nuniform float upRightAngle2;\n\n//forehead\nuniform vec2 foreheadSize;\nuniform vec2 foreheadCenter;\nuniform float foreheadHeight;\n\nconst float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\nconst float kPi = 3.14159265358979;\nconst float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\nuniform sampler2D inputImageTexture;\n\n//common func\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\nvec2 rotate2DPoint(vec2 point, float angle) {\n    return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n}\n\nfloat face_getLeftEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), position.xy, leftEyeCenter, leftEyePlainSize, 0.5, 1.2);\n}\nfloat face_getRightEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), position.xy, rightEyeCenter, rightEyePlainSize, 0.5, 1.2);\n}\nfloat face_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.5, 1.0);\n}\nfloat face_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.5, 1.0);\n}\nfloat face_getLipsMask() {\n    return getEllipseMask(vec2(1.5, 1.5), position.xy, lipsCenter, lipsPlainSize, 0.5, 1.2);\n}\nfloat face_getNoseMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n}\nfloat face_getFaceMask() {\n    return getEllipseMask(vec2(1.5, 1.2), position.xy, faceCenter, facePlainSize, 0.7, 0.9);\n}\nfloat face_getFaceMaskLeft2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, faceCenterLeft2, facePlainSizeLeft2, 0.5, 2.0, leftAngle2);\n}\nfloat face_getFaceMaskRight2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, faceCenterRight2, facePlainSizeRight2, 0.5, 2.0, rightAngle2);\n}\nfloat face_getFaceMaskUpLeft2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, faceCenterUpLeft2, facePlainSizeUpLeft2, 0.5, 0.8, upLeftAngle2);\n}\nfloat face_getFaceMaskUpRight2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, faceCenterUpRight2, facePlainSizeUpRight2, 0.5, 0.8, upRightAngle2);\n}\nvec2 face_getScaledFacePoint2(vec2 originalPoint, float scalingFactor, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    vec2 v = originalPoint - faceCenter;\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return originalPoint+sc;\n}\n\nvec2 getFaceWidthDiff() {\n     float faceNegativeRegionsMask = (1.0 - 0.8*face_getLeftEyeMask()) * (1.0 - 0.8*face_getRightEyeMask()) * (1.0 - 0.8*face_getLeftEyebrowMask()) * (1.0 - 0.8*face_getRightEyebrowMask()) * (1.0 - 0.6*face_getLipsMask()) * (1.0 - 0.9*face_getNoseMask());\n     float faceCoarseMask   = face_getFaceMask();\n     //width\n     vec2 displacedFacePoint   = face_getScaledFacePoint2(position.xy, faceWidth, faceCoarseMask*faceNegativeRegionsMask);\n\n     vec2 displacedFacePoint1 = displacedFacePoint;\n     for (int i = 0; i < 5; i++){   //4 times\n         float thres = 1.2;\n         if (i == 4) thres = 1.0;\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (faceMoveCenter2 - faceCenterLeft2)* 0.1, face_getFaceMaskLeft2(displacedFacePoint1) * faceWidth2 * thres);\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (faceMoveCenter2 - faceCenterRight2)* 0.1, face_getFaceMaskRight2(displacedFacePoint1) * faceWidth2 * thres);\n     }\n     vec2 displacedFacePoint2 = displacedFacePoint;\n     for (int i = 0; i < 3; i++){\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (faceMoveCenter2 - faceCenterUpLeft2)* 0.1, face_getFaceMaskUpLeft2(displacedFacePoint2) * faceWidth2);\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (faceMoveCenter2 - faceCenterUpRight2)* 0.1, face_getFaceMaskUpRight2(displacedFacePoint2) * faceWidth2);\n     }\n     vec2 diffPosition = displacedFacePoint1 - displacedFacePoint + displacedFacePoint2 - displacedFacePoint + displacedFacePoint - position.xy;\n\n     return diffPosition;\n }\n\n\nfloat jaw_getLipsMask() {\n    return getEllipseMask(vec2(1.4, 1.0), position.xy, lipsCenter, lipsPlainSize, 0.5, 1.2);\n}\nfloat jaw_getNoseMask() {\n    return getEllipseMask(vec2(1.0, 1.5), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n}\nfloat jaw_getJawMask() {\n    return getEllipseMask(vec2(1.8, 1.0), position.xy, jawCenterOfGravity, jawSize, 0.5, 1.2);\n}\nvec2 getJawDiff() {\n    float lipsMask = jaw_getLipsMask();\n    float noseMask = jaw_getNoseMask();\n    float jawMask = jaw_getJawMask() * (1.0 - 0.9 * lipsMask) * (1.0 - 0.9 * noseMask);\n\n    vec2 displacedPoint = position.xy;\n\n    const float kJawLiftingYRatio = 0.1;\n    vec2 jawLiftingVector = vec2(0.0, kJawLiftingYRatio * jawSize.y);\n    jawLiftingVector = vec2(dot(jawLiftingVector, vec2(cos_t, -sin_t)), dot(jawLiftingVector, vec2(sin_t, cos_t)));\n    vec2 jawPositionPoint = displacedPoint + jawLiftingVector;\n    vec2 displacedPoint2 = mix(displacedPoint, jawPositionPoint, faceJaw * jawMask);\n\n    const vec2 kScaleFactors = vec2(1.1, 1.1);\n    displacedPoint = jawCenterOfGravity + kScaleFactors * (position.xy - jawCenterOfGravity);\n    displacedPoint = mix(position.xy, displacedPoint, faceJaw * jawMask);\n\n    displacedPoint = displacedPoint * 0.65 + displacedPoint2 * 0.35;\n    vec2 diffPosition = displacedPoint - position.xy;\n    return diffPosition;\n}\n\nfloat head_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.6, 1.0);\n}\nfloat head_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.6, 1.0);\n}\nfloat head_getForeheadMask() {\n    return getEllipseMask(vec2(1.9, 1.6), position.xy, foreheadCenter, foreheadSize, 0.2, 1.4);\n}\n\nvec2 getForeHeadDiff() {\n    float foreheadMask    = head_getForeheadMask() * (1.0 - head_getLeftEyebrowMask()) * (1.0 - head_getRightEyebrowMask());\n    vec2 displacedForeheadPoint   = position.xy;\n\n    const float kForeheadLiftingYRatio = 0.05518821053;\n    vec2 foreheadLiftingVector = vec2(0.0, -kForeheadLiftingYRatio * foreheadSize.y);\n    foreheadLiftingVector = vec2(dot(foreheadLiftingVector, vec2(cos_t, -sin_t)), dot(foreheadLiftingVector, vec2(sin_t, cos_t)));\n    vec2 foreheadPositionPoint = displacedForeheadPoint + foreheadLiftingVector;\n    displacedForeheadPoint = mix(displacedForeheadPoint, foreheadPositionPoint, foreheadMask * foreheadHeight);\n\n    vec2 diffPosition = displacedForeheadPoint - position.xy;\n    return diffPosition;\n}\n\nvec2 wrinkle_rotate2DPointAroundCenter(in vec2 point, in vec2 center, in float angle) {\n    return center + rotate2DPoint(point - center, angle);\n}\nvec2 wrinkle_getRotatedLipsEdgeWrinkle(in vec2 originalPoint, in int isLeftSide) {\n    vec2 wrinkleSize = 1.1*vec2(kLipsEdgeWrinkleSizeToLipsSizeRatio * lipsPlainSize.x, 0.6*lipsPlainSize.y);\n    vec2 lipsEdge = isLeftSide == 1 ? lipsLeftEdge : lipsRightEdge;\n    float directionSign = isLeftSide == 1 ? 1.0 : -1.0;\n    vec2 wrinkleCenter = lipsEdge + directionSign * 0.055 * (lipsRightEdge - lipsLeftEdge);\n\n    float wrinkleMask = getEllipseMask(vec2(0.8, 0.5), position.xy, wrinkleCenter,wrinkleSize, 0.5, 1.2);\n    vec2 wrinkleRotationCenter = lipsEdge + directionSign * 0.2 * (lipsRightEdge - lipsLeftEdge);\n    vec2 rotated2DPoint = wrinkle_rotate2DPointAroundCenter(originalPoint, wrinkleRotationCenter, - directionSign * wrinkleMask * kLipsEdgeWrinklesRotationAngle);\n    return rotated2DPoint;\n}\nvec2 wrinkle_getRotatedLipsLeftEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 1);\n}\nvec2 wrinkle_getRotatedLipsRightEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 0);\n}\n\nfloat wrinkle_getNoseMask() {\n    return getEllipseMask(vec2(1.2, 1.5), position.xy, nose3DCenter.xy, nosePlainSize, 0.8, 1.0);\n}\nvec2 getWrinkleDiff() {\n    vec2 displacedPoint = position.xy;\n    float _noseMask = wrinkle_getNoseMask() * 0.8;\n    displacedPoint = mix(wrinkle_getRotatedLipsLeftEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    displacedPoint = mix(wrinkle_getRotatedLipsRightEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    vec2 displacedPosition = position.xy + faceSmile * (displacedPoint - position.xy);\n    vec2 diffPosition = displacedPosition - position.xy;\n    return diffPosition;\n}\n\nvoid main(){\n    vec2 diffPosition =  getJawDiff() + getFaceWidthDiff() + getForeHeadDiff() + getWrinkleDiff();\n    textureCoordinate = diffPosition + position.xy;\n    gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n}\n", "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n    //gl_FragColor = vec4(inputTextureCoordinate.xy, vec2(0.0, 1.0));\n\n    //vec4 color = vec4(textureCoordinate.x*8.0+0.5, textureCoordinate.y*8.0+0.5, 0.5, 1.0);\n    //gl_FragColor = color;\n\n    //gl_FragColor = vec4(textureCoordinate, textureCoordinate.x, 1.0);\n\n    gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n}");
    if (paramReshapeType == ReshapeType.VTF) {
      updateFilterShader("precision highp float;\n\nattribute vec4 position;\n//common\nuniform float sin_t;\nuniform float cos_t;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\nvarying highp vec2 textureCoordinate;\n\n//eye\nuniform vec2 leftEyePlainSize;\nuniform vec2 leftEyeCenter;\nuniform vec2 rightEyePlainSize;\nuniform vec2 rightEyeCenter;\nuniform float eyesSize; // it is eye size adjust factor\nuniform float eyesWidth; // it is eye width adjust factor\nuniform float eyesHeight; // it is eye height adjust factor\nuniform float eyesTiltAngle; // rotate angle need to apply\nuniform float eyesDistance;\n\n//nose\nuniform vec2 nose3DCenter;\nuniform vec2 nosePlainSize;\nuniform vec2 nostrilsCenter;\nuniform vec2 nostrilsPlaneSize;\nuniform vec2 noseTipCenter;\nuniform vec2 noseTipPlaneSize;\nuniform vec2 noseBottomCenter;\nuniform float noseSize;\nuniform float noseOutlineWidth;\nuniform float noseBridgeWidth;\nuniform float nosePosition;\nuniform float noseTipSize;\n\n//lips\nuniform vec2 lipsCenter;\nuniform vec2 lipsPlainSize;\nuniform float lipsSize;\nuniform float lipsWidth;\nuniform float lipsHeight;\nuniform float lipsYPosition;\n\n//wrinkle\nuniform vec2 lipsLeftEdge;\nuniform vec2 lipsRightEdge;\nuniform float faceSmile;\n\n//jaw\nuniform vec2 jawCenterOfGravity;\nuniform vec2 jawSize;\nuniform float faceJaw;\n\n//eye brow\nuniform vec2 leftEyebrowPlainSize;\nuniform vec2 leftEyebrowCenter;\nuniform vec2 rightEyebrowPlainSize;\nuniform vec2 rightEyebrowCenter;\nuniform float eyebrowHeight; // eyebrow height adjust factor\nuniform float eyebrowDistance;\nuniform float eyebrowTiltAngle; // rotate angle need to apply\n\n//face width\nuniform vec2 facePlainSize;\nuniform vec2 faceCenter;\nuniform float faceWidth;\nuniform float faceWidth2;\n\nuniform vec2 facePlainSizeLeft2;\nuniform vec2 faceCenterLeft2;\nuniform float leftAngle2;\nuniform vec2 facePlainSizeRight2;\nuniform vec2 faceCenterRight2;\nuniform float rightAngle2;\nuniform vec2 faceMoveCenter2;\n\nuniform vec2 facePlainSizeUpLeft2;\nuniform vec2 faceCenterUpLeft2;\nuniform float upLeftAngle2;\nuniform vec2 facePlainSizeUpRight2;\nuniform vec2 faceCenterUpRight2;\nuniform float upRightAngle2;\n\n//forehead\nuniform vec2 foreheadSize;\nuniform vec2 foreheadCenter;\nuniform float foreheadHeight;\n\nconst float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\nconst float kPi = 3.14159265358979;\nconst float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\nuniform sampler2D inputImageTexture;\n\n//common func\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    boundingSize = boundingSize * size;\n    point = point * size;\n    center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\nvec2 rotate2DPoint(vec2 point, float angle) {\n    return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n}\n\nfloat face_getLeftEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), position.xy, leftEyeCenter, leftEyePlainSize, 0.5, 1.2);\n}\nfloat face_getRightEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), position.xy, rightEyeCenter, rightEyePlainSize, 0.5, 1.2);\n}\nfloat face_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.5, 1.0);\n}\nfloat face_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.5, 1.0);\n}\nfloat face_getLipsMask() {\n    return getEllipseMask(vec2(1.5, 1.5), position.xy, lipsCenter, lipsPlainSize, 0.5, 1.2);\n}\nfloat face_getNoseMask() {\n    return getEllipseMask(vec2(1.1, 1.0), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n}\nfloat face_getFaceMask() {\n    return getEllipseMask(vec2(1.5, 1.2), position.xy, faceCenter, facePlainSize, 0.7, 0.9);\n}\nfloat face_getFaceMaskLeft2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, faceCenterLeft2, facePlainSizeLeft2, 0.5, 2.0, leftAngle2);\n}\nfloat face_getFaceMaskRight2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, faceCenterRight2, facePlainSizeRight2, 0.5, 2.0, rightAngle2);\n}\nfloat face_getFaceMaskUpLeft2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, faceCenterUpLeft2, facePlainSizeUpLeft2, 0.5, 0.8, upLeftAngle2);\n}\nfloat face_getFaceMaskUpRight2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, faceCenterUpRight2, facePlainSizeUpRight2, 0.5, 0.8, upRightAngle2);\n}\nvec2 face_getScaledFacePoint2(vec2 originalPoint, float scalingFactor, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    vec2 v = originalPoint - faceCenter;\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return originalPoint+sc;\n}\n\nvec2 getFaceWidthDiff() {\n     float faceNegativeRegionsMask = (1.0 - 0.8*face_getLeftEyeMask()) * (1.0 - 0.8*face_getRightEyeMask()) * (1.0 - 0.8*face_getLeftEyebrowMask()) * (1.0 - 0.8*face_getRightEyebrowMask()) * (1.0 - 0.6*face_getLipsMask()) * (1.0 - 0.9*face_getNoseMask());\n     float faceCoarseMask   = face_getFaceMask();\n     //width\n     vec2 displacedFacePoint   = face_getScaledFacePoint2(position.xy, faceWidth, faceCoarseMask*faceNegativeRegionsMask);\n\n     vec2 displacedFacePoint1 = displacedFacePoint;\n     for (int i = 0; i < 5; i++){   //4 times\n         float thres = 1.2;\n         if (i == 4) thres = 1.0;\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (faceMoveCenter2 - faceCenterLeft2)* 0.1, face_getFaceMaskLeft2(displacedFacePoint1) * faceWidth2 * thres);\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (faceMoveCenter2 - faceCenterRight2)* 0.1, face_getFaceMaskRight2(displacedFacePoint1) * faceWidth2 * thres);\n     }\n     vec2 displacedFacePoint2 = displacedFacePoint;\n     for (int i = 0; i < 3; i++){\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (faceMoveCenter2 - faceCenterUpLeft2)* 0.1, face_getFaceMaskUpLeft2(displacedFacePoint2) * faceWidth2);\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (faceMoveCenter2 - faceCenterUpRight2)* 0.1, face_getFaceMaskUpRight2(displacedFacePoint2) * faceWidth2);\n     }\n     vec2 diffPosition = displacedFacePoint1 - displacedFacePoint + displacedFacePoint2 - displacedFacePoint + displacedFacePoint - position.xy;\n\n     return diffPosition;\n }\n\n\nfloat jaw_getLipsMask() {\n    return getEllipseMask(vec2(1.4, 1.0), position.xy, lipsCenter, lipsPlainSize, 0.5, 1.2);\n}\nfloat jaw_getNoseMask() {\n    return getEllipseMask(vec2(1.0, 1.5), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n}\nfloat jaw_getJawMask() {\n    return getEllipseMask(vec2(1.8, 1.0), position.xy, jawCenterOfGravity, jawSize, 0.5, 1.2);\n}\nvec2 getJawDiff() {\n    float lipsMask = jaw_getLipsMask();\n    float noseMask = jaw_getNoseMask();\n    float jawMask = jaw_getJawMask() * (1.0 - 0.9 * lipsMask) * (1.0 - 0.9 * noseMask);\n\n    vec2 displacedPoint = position.xy;\n\n    const float kJawLiftingYRatio = 0.1;\n    vec2 jawLiftingVector = vec2(0.0, kJawLiftingYRatio * jawSize.y);\n    jawLiftingVector = vec2(dot(jawLiftingVector, vec2(cos_t, -sin_t)), dot(jawLiftingVector, vec2(sin_t, cos_t)));\n    vec2 jawPositionPoint = displacedPoint + jawLiftingVector;\n    vec2 displacedPoint2 = mix(displacedPoint, jawPositionPoint, faceJaw * jawMask);\n\n    const vec2 kScaleFactors = vec2(1.1, 1.1);\n    displacedPoint = jawCenterOfGravity + kScaleFactors * (position.xy - jawCenterOfGravity);\n    displacedPoint = mix(position.xy, displacedPoint, faceJaw * jawMask);\n\n    displacedPoint = displacedPoint * 0.65 + displacedPoint2 * 0.35;\n    vec2 diffPosition = displacedPoint - position.xy;\n    return diffPosition;\n}\n\nfloat head_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.6, 1.0);\n}\nfloat head_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.6, 1.0);\n}\nfloat head_getForeheadMask() {\n    return getEllipseMask(vec2(1.9, 1.6), position.xy, foreheadCenter, foreheadSize, 0.2, 1.4);\n}\n\nvec2 getForeHeadDiff() {\n    float foreheadMask    = head_getForeheadMask() * (1.0 - head_getLeftEyebrowMask()) * (1.0 - head_getRightEyebrowMask());\n    vec2 displacedForeheadPoint   = position.xy;\n\n    const float kForeheadLiftingYRatio = 0.05518821053;\n    vec2 foreheadLiftingVector = vec2(0.0, -kForeheadLiftingYRatio * foreheadSize.y);\n    foreheadLiftingVector = vec2(dot(foreheadLiftingVector, vec2(cos_t, -sin_t)), dot(foreheadLiftingVector, vec2(sin_t, cos_t)));\n    vec2 foreheadPositionPoint = displacedForeheadPoint + foreheadLiftingVector;\n    displacedForeheadPoint = mix(displacedForeheadPoint, foreheadPositionPoint, foreheadMask * foreheadHeight);\n\n    vec2 diffPosition = displacedForeheadPoint - position.xy;\n    return diffPosition;\n}\n\nvec2 wrinkle_rotate2DPointAroundCenter(in vec2 point, in vec2 center, in float angle) {\n    return center + rotate2DPoint(point - center, angle);\n}\nvec2 wrinkle_getRotatedLipsEdgeWrinkle(in vec2 originalPoint, in int isLeftSide) {\n    vec2 wrinkleSize = 1.1*vec2(kLipsEdgeWrinkleSizeToLipsSizeRatio * lipsPlainSize.x, 0.6*lipsPlainSize.y);\n    vec2 lipsEdge = isLeftSide == 1 ? lipsLeftEdge : lipsRightEdge;\n    float directionSign = isLeftSide == 1 ? 1.0 : -1.0;\n    vec2 wrinkleCenter = lipsEdge + directionSign * 0.055 * (lipsRightEdge - lipsLeftEdge);\n\n    float wrinkleMask = getEllipseMask(vec2(0.8, 0.5), position.xy, wrinkleCenter,wrinkleSize, 0.5, 1.2);\n    vec2 wrinkleRotationCenter = lipsEdge + directionSign * 0.2 * (lipsRightEdge - lipsLeftEdge);\n    vec2 rotated2DPoint = wrinkle_rotate2DPointAroundCenter(originalPoint, wrinkleRotationCenter, - directionSign * wrinkleMask * kLipsEdgeWrinklesRotationAngle);\n    return rotated2DPoint;\n}\nvec2 wrinkle_getRotatedLipsLeftEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 1);\n}\nvec2 wrinkle_getRotatedLipsRightEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 0);\n}\n\nfloat wrinkle_getNoseMask() {\n    return getEllipseMask(vec2(1.2, 1.5), position.xy, nose3DCenter.xy, nosePlainSize, 0.8, 1.0);\n}\nvec2 getWrinkleDiff() {\n    vec2 displacedPoint = position.xy;\n    float _noseMask = wrinkle_getNoseMask() * 0.8;\n    displacedPoint = mix(wrinkle_getRotatedLipsLeftEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    displacedPoint = mix(wrinkle_getRotatedLipsRightEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    vec2 displacedPosition = position.xy + faceSmile * (displacedPoint - position.xy);\n    vec2 diffPosition = displacedPosition - position.xy;\n    return diffPosition;\n}\n\nvoid main(){\n    vec2 diffPosition =  getJawDiff() + getFaceWidthDiff() + getForeHeadDiff() + getWrinkleDiff();\n    vec4 color = texture2D(inputImageTexture, position.xy);\n    vec2 offset = (color.xy * 255.0 + color.zw) / 127.5 - 1.0;\n    textureCoordinate = diffPosition + offset;\n\n    gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n}\n", "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n\n    //vec2 diffPosition = textureCoordinate;\n    //float ddx = (diffPosition.x + 1.0) / 2.0;\n    //float ddy = (diffPosition.y + 1.0) / 2.0;\n    //diffPosition = vec2(ddx,ddy);\n    //vec2 a = fract(diffPosition * 255.0 / 256.0);\n    //vec2 b = fract(diffPosition * 255.0 * 255.0 / 256.0);\n    //gl_FragColor = vec4(a,b);\n\n    // 新版的 shader 颜色通道中记录的是位移偏移量，只有在最后 combinedFilter 才最终将所有 filter 的位移量叠加，去图上取点。这样的好处是：\n    // 1. 只有 128 * 128 个点\n    // 2. smoothstep 会更平滑，128 * 128 个点取插值，原来的处理方法会使像素点变模糊\n    // 3. 两个矩形交叠的地方，位移处理的先后顺序不影响结果（不能说这是好还是坏，因为 PS 的液化是作用在原图上的）\n\n    // 至于此处要改为 * 255 再 / 255 是为了提升精度（浮点纹理 iOS 不支持，而一个字节只能表示 256 个不同值）\n    // 本来小奇使用了浮点纹理，但是发现有机型不支持，不用浮点纹理又精度不够，所以采用这个方法，变成2个字节表示一个值，提升了精度。\n    vec2 diffPosition = textureCoordinate;\n    diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;  // 0.5 * (diffPosition + 1.0) 是将(-1, 1)间的值转换到(0, 1)，\n    vec2 a = floor(diffPosition) / 255.0;\n    vec2 b = fract(diffPosition);\n    gl_FragColor = vec4(a, b);\n\n\n    //vec2 diffPosition = textureCoordinate;\n    //diffPosition = 0.5 * (diffPosition + 1.0) * 256.0;\n    //vec2 a = floor(diffPosition) / 256.0;\n    //vec2 b = fract(diffPosition);\n    //gl_FragColor = vec4(a, b);\n}\n");
    }
    if (paramReshapeType == ReshapeType.NORMAL) {
      f = 0.5F;
    }
    this.meshType = f;
    initParams();
  }
  
  public void ApplyGLSLFilter()
  {
    initParams();
    super.ApplyGLSLFilter();
    setDrawMode(AEOpenRenderConfig.DRAW_MODE.TRIANGLE_STRIP);
  }
  
  public void initAttribParams()
  {
    setPositions(mFullscreenVerticesPortrait, false);
    setTexCords(mInitTextureCoordinatesPortrait, false);
    setCoordNum(32897);
  }
  
  public void initParams()
  {
    addParam(new UniformParam.FloatsParam("leftEyePlainSize", this.leftEyePlainSize));
    addParam(new UniformParam.FloatsParam("leftEyeCenter", this.leftEyeCenter));
    addParam(new UniformParam.FloatsParam("rightEyePlainSize", this.rightEyePlainSize));
    addParam(new UniformParam.FloatsParam("rightEyeCenter", this.rightEyeCenter));
    addParam(new UniformParam.FloatsParam("leftEyebrowPlainSize", this.leftEyebrowPlainSize));
    addParam(new UniformParam.FloatsParam("leftEyebrowCenter", this.leftEyebrowCenter));
    addParam(new UniformParam.FloatsParam("rightEyebrowPlainSize", this.rightEyebrowPlainSize));
    addParam(new UniformParam.FloatsParam("rightEyebrowCenter", this.rightEyebrowCenter));
    addParam(new UniformParam.FloatsParam("nose3DCenter", this.nose3DCenter));
    addParam(new UniformParam.FloatsParam("nosePlainSize", this.nosePlainSize));
    addParam(new UniformParam.FloatsParam("lipsCenter", this.lipsCenter));
    addParam(new UniformParam.FloatsParam("lipsPlainSize", this.lipsPlainSize));
    addParam(new UniformParam.FloatsParam("lipsLeftEdge", this.lipsLeftEdge));
    addParam(new UniformParam.FloatsParam("lipsRightEdge", this.lipsRightEdge));
    addParam(new UniformParam.FloatsParam("facePlainSize", this.facePlainSize));
    addParam(new UniformParam.FloatsParam("faceCenter", this.faceCenter));
    addParam(new UniformParam.FloatsParam("facePlainSizeLeft2", this.facePlainSizeLeft2));
    addParam(new UniformParam.FloatsParam("faceCenterLeft2", this.faceCenterLeft2));
    addParam(new UniformParam.FloatParam("leftAngle2", this.leftAngle2));
    addParam(new UniformParam.FloatsParam("facePlainSizeRight2", this.facePlainSizeRight2));
    addParam(new UniformParam.FloatsParam("faceCenterRight2", this.faceCenterRight2));
    addParam(new UniformParam.FloatParam("rightAngle2", this.rightAngle2));
    addParam(new UniformParam.FloatsParam("faceMoveCenter2", this.faceMoveCenter2));
    addParam(new UniformParam.FloatsParam("facePlainSizeUpLeft2", this.facePlainSizeUpLeft2));
    addParam(new UniformParam.FloatsParam("faceCenterUpLeft2", this.faceCenterUpLeft2));
    addParam(new UniformParam.FloatParam("upLeftAngle2", this.upLeftAngle2));
    addParam(new UniformParam.FloatsParam("facePlainSizeUpRight2", this.facePlainSizeUpRight2));
    addParam(new UniformParam.FloatsParam("faceCenterUpRight2", this.faceCenterUpRight2));
    addParam(new UniformParam.FloatParam("upRightAngle2", this.upRightAngle2));
    addParam(new UniformParam.FloatsParam("jawCenterOfGravity", this.jawCenterOfGravity));
    addParam(new UniformParam.FloatsParam("jawSize", this.jawSize));
    addParam(new UniformParam.FloatsParam("foreheadSize", this.foreheadSize));
    addParam(new UniformParam.FloatsParam("foreheadCenter", this.foreheadCenter));
    addParam(new UniformParam.FloatParam("faceWidth", this.faceWidth));
    addParam(new UniformParam.FloatParam("faceWidth2", this.faceWidth2));
    addParam(new UniformParam.FloatParam("faceJaw", this.faceJaw));
    addParam(new UniformParam.FloatParam("faceSmile", this.faceSmile));
    addParam(new UniformParam.FloatParam("foreheadHeight", this.foreheadHeight));
    addParam(new UniformParam.FloatsParam("angles", this.angles));
    addParam(new UniformParam.FloatsParam("size", this.size));
    addParam(new UniformParam.FloatParam("meshType", this.meshType));
    float f = (float)Math.cos(this.angles[2]);
    addParam(new UniformParam.FloatParam("sin_t", (float)Math.sin(this.angles[2])));
    addParam(new UniformParam.FloatParam("cos_t", f));
  }
  
  public void setInitMesh(float[] paramArrayOfFloat1, float[] paramArrayOfFloat2)
  {
    mFullscreenVerticesPortrait = paramArrayOfFloat1;
    mInitTextureCoordinatesPortrait = paramArrayOfFloat2;
  }
  
  public void setParam(Map<String, Object> paramMap)
  {
    if (paramMap.containsKey("leftEyePlainSize")) {
      this.leftEyePlainSize = ((float[])paramMap.get("leftEyePlainSize"));
    }
    if (paramMap.containsKey("leftEyeCenter")) {
      this.leftEyeCenter = ((float[])paramMap.get("leftEyeCenter"));
    }
    if (paramMap.containsKey("rightEyePlainSize")) {
      this.rightEyePlainSize = ((float[])paramMap.get("rightEyePlainSize"));
    }
    if (paramMap.containsKey("rightEyeCenter")) {
      this.rightEyeCenter = ((float[])paramMap.get("rightEyeCenter"));
    }
    if (paramMap.containsKey("leftEyebrowPlainSize")) {
      this.leftEyebrowPlainSize = ((float[])paramMap.get("leftEyebrowPlainSize"));
    }
    if (paramMap.containsKey("leftEyebrowCenter")) {
      this.leftEyebrowCenter = ((float[])paramMap.get("leftEyebrowCenter"));
    }
    if (paramMap.containsKey("rightEyebrowPlainSize")) {
      this.rightEyebrowPlainSize = ((float[])paramMap.get("rightEyebrowPlainSize"));
    }
    if (paramMap.containsKey("rightEyebrowCenter")) {
      this.rightEyebrowCenter = ((float[])paramMap.get("rightEyebrowCenter"));
    }
    if (paramMap.containsKey("nose3DCenter")) {
      this.nose3DCenter = ((float[])paramMap.get("nose3DCenter"));
    }
    if (paramMap.containsKey("nosePlainSize")) {
      this.nosePlainSize = ((float[])paramMap.get("nosePlainSize"));
    }
    if (paramMap.containsKey("lipsCenter")) {
      this.lipsCenter = ((float[])paramMap.get("lipsCenter"));
    }
    if (paramMap.containsKey("lipsPlainSize")) {
      this.lipsPlainSize = ((float[])paramMap.get("lipsPlainSize"));
    }
    if (paramMap.containsKey("lipsLeftEdge")) {
      this.lipsLeftEdge = ((float[])paramMap.get("lipsLeftEdge"));
    }
    if (paramMap.containsKey("lipsRightEdge")) {
      this.lipsRightEdge = ((float[])paramMap.get("lipsRightEdge"));
    }
    if (paramMap.containsKey("facePlainSize")) {
      this.facePlainSize = ((float[])paramMap.get("facePlainSize"));
    }
    if (paramMap.containsKey("faceCenter")) {
      this.faceCenter = ((float[])paramMap.get("faceCenter"));
    }
    if (paramMap.containsKey("facePlainSizeLeft2")) {
      this.facePlainSizeLeft2 = ((float[])paramMap.get("facePlainSizeLeft2"));
    }
    if (paramMap.containsKey("faceCenterLeft2")) {
      this.faceCenterLeft2 = ((float[])paramMap.get("faceCenterLeft2"));
    }
    if (paramMap.containsKey("leftAngle2")) {
      this.leftAngle2 = ((Float)paramMap.get("leftAngle2")).floatValue();
    }
    if (paramMap.containsKey("facePlainSizeRight2")) {
      this.facePlainSizeRight2 = ((float[])paramMap.get("facePlainSizeRight2"));
    }
    if (paramMap.containsKey("faceCenterRight2")) {
      this.faceCenterRight2 = ((float[])paramMap.get("faceCenterRight2"));
    }
    if (paramMap.containsKey("rightAngle2")) {
      this.rightAngle2 = ((Float)paramMap.get("rightAngle2")).floatValue();
    }
    if (paramMap.containsKey("faceMoveCenter2")) {
      this.faceMoveCenter2 = ((float[])paramMap.get("faceMoveCenter2"));
    }
    if (paramMap.containsKey("facePlainSizeUpLeft2")) {
      this.facePlainSizeUpLeft2 = ((float[])paramMap.get("facePlainSizeUpLeft2"));
    }
    if (paramMap.containsKey("faceCenterUpLeft2")) {
      this.faceCenterUpLeft2 = ((float[])paramMap.get("faceCenterUpLeft2"));
    }
    if (paramMap.containsKey("upLeftAngle2")) {
      this.upLeftAngle2 = ((Float)paramMap.get("upLeftAngle2")).floatValue();
    }
    if (paramMap.containsKey("facePlainSizeUpRight2")) {
      this.facePlainSizeUpRight2 = ((float[])paramMap.get("facePlainSizeUpRight2"));
    }
    if (paramMap.containsKey("faceCenterUpRight2")) {
      this.faceCenterUpRight2 = ((float[])paramMap.get("faceCenterUpRight2"));
    }
    if (paramMap.containsKey("upRightAngle2")) {
      this.upRightAngle2 = ((Float)paramMap.get("upRightAngle2")).floatValue();
    }
    if (paramMap.containsKey("jawCenterOfGravity")) {
      this.jawCenterOfGravity = ((float[])paramMap.get("jawCenterOfGravity"));
    }
    if (paramMap.containsKey("foreheadSize")) {
      this.foreheadSize = ((float[])paramMap.get("foreheadSize"));
    }
    if (paramMap.containsKey("foreheadCenter")) {
      this.foreheadCenter = ((float[])paramMap.get("foreheadCenter"));
    }
    if (paramMap.containsKey("jawSize")) {
      this.jawSize = ((float[])paramMap.get("jawSize"));
    }
    if (paramMap.containsKey("foreheadHeight"))
    {
      this.foreheadHeight = (((Float)paramMap.get("foreheadHeight")).floatValue() * 0.02F);
      if (this.foreheadHeight > 0.0F) {
        this.foreheadHeight *= 1.5F;
      }
    }
    if (paramMap.containsKey("faceJaw")) {
      this.faceJaw = (((Float)paramMap.get("faceJaw")).floatValue() * 0.01F);
    }
    if (paramMap.containsKey("faceSmile")) {
      this.faceSmile = (((Float)paramMap.get("faceSmile")).floatValue() * 0.03F);
    }
    if (paramMap.containsKey("faceWidth"))
    {
      this.faceWidth = (((Float)paramMap.get("faceWidth")).floatValue() * 0.0012F);
      if (this.faceWidth > 0.0F) {
        this.faceWidth *= 1.15F;
      }
    }
    if (paramMap.containsKey("faceWidth2"))
    {
      this.faceWidth2 = (((Float)paramMap.get("faceWidth2")).floatValue() * 0.0017F);
      if (this.faceWidth2 > 0.0F) {
        this.faceWidth2 *= 1.15F;
      }
    }
    if (paramMap.containsKey("angles")) {
      this.angles = ((float[])paramMap.get("angles"));
    }
    if (paramMap.containsKey("size")) {
      this.size = ((float[])paramMap.get("size"));
    }
    initParams();
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.tim\classes12.jar
 * Qualified Name:     com.tencent.ttpic.filter.ReshapeWholeFace
 * JD-Core Version:    0.7.0.1
 */