package com.tencent.ttpic.openapi.filter.stylizefilter;

import com.tencent.aekit.openrender.UniformParam.FloatParam;
import com.tencent.filter.BaseFilter;

public class BSkinSmoothBilateralFilter
  extends BaseFilter
{
  private static final String FRAGMENT_SHADER = "precision highp float; \nuniform sampler2D inputImageTexture;\nvarying highp vec2 textureCoordinate;\nvarying highp vec2 blurCoordinates1;\nvarying highp vec2 blurCoordinates2;\nvarying highp vec2 blurCoordinates3;\nvarying highp vec2 blurCoordinates4;\nvarying highp vec2 blurCoordinates5;\nvarying highp vec2 blurCoordinates6;\nvarying highp vec2 blurCoordinates7;\nvarying highp vec2 blurCoordinates8;\nvarying highp vec2 blurCoordinates9;\nuniform mediump float distanceNormalizationFactor;\nvoid main() {\n    lowp vec4 centralColor;\n    lowp float gaussianWeightTotal;\n    lowp vec4 sum; lowp vec4 sampleColor;\n    lowp float distanceFromCentralColor;\n    lowp float gaussianWeight;\n    centralColor        = texture2D(inputImageTexture, blurCoordinates5);\n    gaussianWeightTotal = 0.18;\n    sum                 = centralColor * 0.18;\n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates1);\n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n    gaussianWeight              = 0.05 * (1.0 - distanceFromCentralColor);\n    gaussianWeightTotal         += gaussianWeight;\n    sum                         += sampleColor * gaussianWeight;\n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates2);\n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n    gaussianWeight              = 0.09 * (1.0 - distanceFromCentralColor);\n    gaussianWeightTotal         += gaussianWeight;\n    sum                         += sampleColor * gaussianWeight;\n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates3);\n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n    gaussianWeight              = 0.12 * (1.0 - distanceFromCentralColor);\n    gaussianWeightTotal         += gaussianWeight;\n    sum                         += sampleColor * gaussianWeight;\n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates4); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.15 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates6); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.15 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates7); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.12 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates8); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.09 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates9); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.05 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    if (gaussianWeightTotal < 0.4) { \n        gl_FragColor = centralColor; \n    }\n    else if (gaussianWeightTotal < 0.5) { \n        gl_FragColor = mix(sum / gaussianWeightTotal, centralColor, (gaussianWeightTotal - 0.4) / 0.1); \n    }\n    else { \n        gl_FragColor = sum / gaussianWeightTotal; \n    } \n} \n";
  private static final String VERTEX_SHADER = "precision highp float; \nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nuniform float texelWidthOffset;\nuniform float texelHeightOffset;\nvarying vec2 textureCoordinate;\nvarying vec2 blurCoordinates1;\nvarying vec2 blurCoordinates2;\nvarying vec2 blurCoordinates3;\nvarying vec2 blurCoordinates4;\nvarying vec2 blurCoordinates5;\nvarying vec2 blurCoordinates6;\nvarying vec2 blurCoordinates7;\nvarying vec2 blurCoordinates8;\nvarying vec2 blurCoordinates9;\nvoid main() { \n  gl_Position = position;\n  textureCoordinate = inputTextureCoordinate.xy;\n  int multiplier = 0;\n  vec2 blurStep = vec2(0.0);\n  vec2 singleStepOffset   = vec2(texelWidthOffset, texelHeightOffset); \n  blurStep = -4.0 * singleStepOffset; \n  blurCoordinates1 = inputTextureCoordinate.xy + blurStep; \n  blurStep = -3.0 * singleStepOffset; \n  blurCoordinates2 = inputTextureCoordinate.xy + blurStep; \n  blurStep = -2.0 * singleStepOffset; \n  blurCoordinates3 = inputTextureCoordinate.xy + blurStep; \n  blurStep = -1.0 * singleStepOffset; \n  blurCoordinates4 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 0.0 * singleStepOffset; \n  blurCoordinates5 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 1.0 * singleStepOffset; \n  blurCoordinates6 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 2.0 * singleStepOffset; \n  blurCoordinates7 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 3.0 * singleStepOffset; \n  blurCoordinates8 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 4.0 * singleStepOffset; \n  blurCoordinates9 = inputTextureCoordinate.xy + blurStep; \n} \n";
  
  public BSkinSmoothBilateralFilter()
  {
    super("precision highp float; \nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nuniform float texelWidthOffset;\nuniform float texelHeightOffset;\nvarying vec2 textureCoordinate;\nvarying vec2 blurCoordinates1;\nvarying vec2 blurCoordinates2;\nvarying vec2 blurCoordinates3;\nvarying vec2 blurCoordinates4;\nvarying vec2 blurCoordinates5;\nvarying vec2 blurCoordinates6;\nvarying vec2 blurCoordinates7;\nvarying vec2 blurCoordinates8;\nvarying vec2 blurCoordinates9;\nvoid main() { \n  gl_Position = position;\n  textureCoordinate = inputTextureCoordinate.xy;\n  int multiplier = 0;\n  vec2 blurStep = vec2(0.0);\n  vec2 singleStepOffset   = vec2(texelWidthOffset, texelHeightOffset); \n  blurStep = -4.0 * singleStepOffset; \n  blurCoordinates1 = inputTextureCoordinate.xy + blurStep; \n  blurStep = -3.0 * singleStepOffset; \n  blurCoordinates2 = inputTextureCoordinate.xy + blurStep; \n  blurStep = -2.0 * singleStepOffset; \n  blurCoordinates3 = inputTextureCoordinate.xy + blurStep; \n  blurStep = -1.0 * singleStepOffset; \n  blurCoordinates4 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 0.0 * singleStepOffset; \n  blurCoordinates5 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 1.0 * singleStepOffset; \n  blurCoordinates6 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 2.0 * singleStepOffset; \n  blurCoordinates7 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 3.0 * singleStepOffset; \n  blurCoordinates8 = inputTextureCoordinate.xy + blurStep; \n  blurStep = 4.0 * singleStepOffset; \n  blurCoordinates9 = inputTextureCoordinate.xy + blurStep; \n} \n", "precision highp float; \nuniform sampler2D inputImageTexture;\nvarying highp vec2 textureCoordinate;\nvarying highp vec2 blurCoordinates1;\nvarying highp vec2 blurCoordinates2;\nvarying highp vec2 blurCoordinates3;\nvarying highp vec2 blurCoordinates4;\nvarying highp vec2 blurCoordinates5;\nvarying highp vec2 blurCoordinates6;\nvarying highp vec2 blurCoordinates7;\nvarying highp vec2 blurCoordinates8;\nvarying highp vec2 blurCoordinates9;\nuniform mediump float distanceNormalizationFactor;\nvoid main() {\n    lowp vec4 centralColor;\n    lowp float gaussianWeightTotal;\n    lowp vec4 sum; lowp vec4 sampleColor;\n    lowp float distanceFromCentralColor;\n    lowp float gaussianWeight;\n    centralColor        = texture2D(inputImageTexture, blurCoordinates5);\n    gaussianWeightTotal = 0.18;\n    sum                 = centralColor * 0.18;\n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates1);\n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n    gaussianWeight              = 0.05 * (1.0 - distanceFromCentralColor);\n    gaussianWeightTotal         += gaussianWeight;\n    sum                         += sampleColor * gaussianWeight;\n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates2);\n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n    gaussianWeight              = 0.09 * (1.0 - distanceFromCentralColor);\n    gaussianWeightTotal         += gaussianWeight;\n    sum                         += sampleColor * gaussianWeight;\n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates3);\n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n    gaussianWeight              = 0.12 * (1.0 - distanceFromCentralColor);\n    gaussianWeightTotal         += gaussianWeight;\n    sum                         += sampleColor * gaussianWeight;\n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates4); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.15 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates6); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.15 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates7); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.12 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates8); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.09 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    sampleColor                 = texture2D(inputImageTexture, blurCoordinates9); \n    distanceFromCentralColor    = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0); \n    gaussianWeight              = 0.05 * (1.0 - distanceFromCentralColor); \n    gaussianWeightTotal         += gaussianWeight; \n    sum                         += sampleColor * gaussianWeight; \n    \n    if (gaussianWeightTotal < 0.4) { \n        gl_FragColor = centralColor; \n    }\n    else if (gaussianWeightTotal < 0.5) { \n        gl_FragColor = mix(sum / gaussianWeightTotal, centralColor, (gaussianWeightTotal - 0.4) / 0.1); \n    }\n    else { \n        gl_FragColor = sum / gaussianWeightTotal; \n    } \n} \n");
    initParams();
  }
  
  private void initParams()
  {
    addParam(new UniformParam.FloatParam("texelWidthOffset", 0.0F));
    addParam(new UniformParam.FloatParam("texelHeightOffset", 0.0F));
    addParam(new UniformParam.FloatParam("distanceNormalizationFactor", 4.0F));
  }
  
  public void updateSize(float paramFloat1, float paramFloat2)
  {
    addParam(new UniformParam.FloatParam("texelWidthOffset", 4.0F / paramFloat1));
    addParam(new UniformParam.FloatParam("texelHeightOffset", 4.0F / paramFloat2));
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes15.jar
 * Qualified Name:     com.tencent.ttpic.openapi.filter.stylizefilter.BSkinSmoothBilateralFilter
 * JD-Core Version:    0.7.0.1
 */