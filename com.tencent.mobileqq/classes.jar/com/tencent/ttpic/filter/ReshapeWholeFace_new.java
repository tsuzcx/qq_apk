package com.tencent.ttpic.filter;

import com.tencent.aekit.openrender.AEOpenRenderConfig.DRAW_MODE;
import com.tencent.aekit.openrender.UniformParam.Float1sParam;
import com.tencent.aekit.openrender.UniformParam.Float2sParam;
import com.tencent.aekit.openrender.UniformParam.FloatParam;
import com.tencent.aekit.openrender.UniformParam.FloatsParam;
import com.tencent.aekit.openrender.internal.VideoFilterBase;
import java.util.Map;

public class ReshapeWholeFace_new
  extends VideoFilterBase
{
  private static final String FRAGMENT_SHADER_VTF = "precision highp float;\n\n//common\nuniform float sin_t;\nuniform float cos_t;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\nvarying vec2 textureCoordinate;\n\nvec2 textureCoordinateFix; //used for fix error\nuniform vec2 posV[36];\nuniform float paramV[6];\n\nconst float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\nconst float kPi = 3.14159265358979;\nconst float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\nuniform sampler2D inputImageTexture;\n\n//common func\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    //boundingSize = boundingSize * size;\n    //point = point * size;\n    //center = center * size;\n\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    //boundingSize = boundingSize * size;\n    //point = point * size;\n    //center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\nvec2 rotate2DPoint(vec2 point, float angle) {\n    return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n}\n\nfloat face_getLeftEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), textureCoordinateFix, posV[1], posV[0], 0.5, 1.2);\n}\nfloat face_getRightEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), textureCoordinateFix, posV[3], posV[2], 0.5, 1.2);\n}\nfloat face_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), textureCoordinateFix, posV[4], posV[5], 0.5, 1.0);\n}\nfloat face_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), textureCoordinateFix, posV[6], posV[7], 0.5, 1.0);\n}\nfloat face_getLipsMask() {\n    return getEllipseMask(vec2(1.5, 1.5), textureCoordinateFix, posV[10], posV[11], 0.5, 1.2);\n}\nfloat face_getNoseMask() {\n    return getEllipseMask(vec2(1.1, 1.0), textureCoordinateFix, posV[8], posV[9], 0.5, 1.2);\n}\nfloat face_getFaceMask() {\n    return getEllipseMask(vec2(1.5, 1.2), textureCoordinateFix, posV[15], posV[14], 0.7, 0.9);\n}\nfloat face_getFaceMaskLeft2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, posV[17], posV[16], 0.5, 2.0, posV[18].x);\n}\nfloat face_getFaceMaskRight2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, posV[20], posV[19], 0.5, 2.0, posV[18].y);\n}\nfloat face_getFaceMaskUpLeft2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, posV[23], posV[22], 0.5, 0.8, posV[24].x);\n}\nfloat face_getFaceMaskUpRight2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, posV[26], posV[25], 0.5, 0.8, posV[24].y);\n}\nfloat face_getFaceMaskCheekboneLeft(vec2 point) {\n    return getEllipseMask2(vec2(1.5, 1.4), point, posV[32], posV[31], 0.2, 1.2, posV[33].x);\n}\nfloat face_getFaceMaskCheekboneRight(vec2 point) {\n    return getEllipseMask2(vec2(1.5, 1.4), point, posV[35], posV[34], 0.2, 1.2, posV[33].y);\n}\nvec2 face_getScaledFacePoint2(vec2 originalPoint, float scalingFactor, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    vec2 v = originalPoint - posV[15];\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return originalPoint+sc;\n}\n\nvec2 getFaceWidthDiff() {\n     vec2 diffPosition = vec2(0, 0);\n     vec2 displacedFacePoint = textureCoordinateFix;\n\n\n     float faceNegativeRegionsMask = (1.0 - 0.8*face_getLeftEyeMask()) * (1.0 - 0.8*face_getRightEyeMask()) * (1.0 - 0.8*face_getLeftEyebrowMask()) * (1.0 - 0.8*face_getRightEyebrowMask()) * (1.0 - 0.6*face_getLipsMask()) * (1.0 - 0.9*face_getNoseMask());\n     float faceCoarseMask   = face_getFaceMask();\n     //width\n     displacedFacePoint   = face_getScaledFacePoint2(displacedFacePoint, paramV[0], faceCoarseMask*faceNegativeRegionsMask);\n\n     diffPosition = displacedFacePoint - textureCoordinateFix;\n\n     vec2 displacedFacePoint1 = displacedFacePoint;\n     for (int i = 0; i < 5; i++){   //4 times\n         float thres = 1.2;\n         if (i == 4) thres = 1.0;\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (posV[21] - posV[17])* 0.1, face_getFaceMaskLeft2(displacedFacePoint1) * paramV[1] * thres);\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (posV[21] - posV[20])* 0.1, face_getFaceMaskRight2(displacedFacePoint1) * paramV[1] * thres);\n     }\n     vec2 displacedFacePoint2 = displacedFacePoint;\n     for (int i = 0; i < 3; i++){\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (posV[21] - posV[23])* 0.1, face_getFaceMaskUpLeft2(displacedFacePoint2) * paramV[1]);\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (posV[21] - posV[26])* 0.1, face_getFaceMaskUpRight2(displacedFacePoint2) * paramV[1]);\n     }\n\n     //cheekbone\n     displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (posV[21] - posV[32])* 0.1, face_getFaceMaskCheekboneLeft(displacedFacePoint2) * paramV[5] * 2.0);\n     displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (posV[21] - posV[35])* 0.1, face_getFaceMaskCheekboneRight(displacedFacePoint2) * paramV[5] * 2.0);\n\n     diffPosition = displacedFacePoint1 - displacedFacePoint + displacedFacePoint2 - displacedFacePoint + diffPosition;\n\n\n     return diffPosition;\n }\n\n\nfloat jaw_getLipsMask() {\n    return getEllipseMask(vec2(1.4, 1.0), textureCoordinateFix, posV[10], posV[11], 0.5, 1.2);\n}\nfloat jaw_getNoseMask() {\n    return getEllipseMask(vec2(1.0, 1.5), textureCoordinateFix, posV[8], posV[9], 0.5, 1.2);\n}\nfloat jaw_getJawMask() {\n    return getEllipseMask(vec2(1.8, 1.0), textureCoordinateFix, posV[27], posV[28], 0.5, 1.2);\n}\nvec2 getJawDiff() {\n    float lipsMask = jaw_getLipsMask();\n    float noseMask = jaw_getNoseMask();\n    float jawMask = jaw_getJawMask() * (1.0 - 0.9 * lipsMask) * (1.0 - 0.9 * noseMask);\n\n    vec2 displacedPoint = textureCoordinateFix;\n\n    const float kJawLiftingYRatio = 0.1;\n    vec2 jawLiftingVector = vec2(0.0, kJawLiftingYRatio * posV[28].y);\n    jawLiftingVector = vec2(dot(jawLiftingVector, vec2(cos_t, -sin_t)), dot(jawLiftingVector, vec2(sin_t, cos_t)));\n    vec2 jawPositionPoint = displacedPoint + jawLiftingVector;\n    vec2 displacedPoint2 = mix(displacedPoint, jawPositionPoint, paramV[2] * jawMask);\n\n    const vec2 kScaleFactors = vec2(1.1, 1.1);\n    displacedPoint = posV[27] + kScaleFactors * (textureCoordinateFix - posV[27]);\n    displacedPoint = mix(textureCoordinateFix, displacedPoint, paramV[2] * jawMask);\n\n    displacedPoint = displacedPoint * 0.65 + displacedPoint2 * 0.35;\n    vec2 diffPosition = displacedPoint - textureCoordinateFix;\n    return diffPosition;\n}\n\nfloat head_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), textureCoordinateFix, posV[4], posV[5], 0.6, 1.0);\n}\nfloat head_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), textureCoordinateFix, posV[6], posV[7], 0.6, 1.0);\n}\nfloat head_getForeheadMask() {\n    return getEllipseMask(vec2(1.9, 1.6), textureCoordinateFix, posV[29], posV[30], 0.2, 1.4);\n}\n\nvec2 getForeHeadDiff() {\n    float foreheadMask    = head_getForeheadMask() * (1.0 - head_getLeftEyebrowMask()) * (1.0 - head_getRightEyebrowMask());\n    vec2 displacedForeheadPoint   = textureCoordinateFix;\n\n    const float kForeheadLiftingYRatio = 0.04;\n    vec2 foreheadLiftingVector = vec2(0.0, -kForeheadLiftingYRatio * posV[30].y);\n    foreheadLiftingVector = vec2(dot(foreheadLiftingVector, vec2(cos_t, -sin_t)), dot(foreheadLiftingVector, vec2(sin_t, cos_t)));\n    vec2 foreheadPositionPoint = displacedForeheadPoint + foreheadLiftingVector;\n    displacedForeheadPoint = mix(displacedForeheadPoint, foreheadPositionPoint, foreheadMask * paramV[4]);\n\n    vec2 diffPosition = displacedForeheadPoint - textureCoordinateFix;\n    return diffPosition;\n}\n\nvec2 wrinkle_rotate2DPointAroundCenter(in vec2 point, in vec2 center, in float angle) {\n    return center + rotate2DPoint(point - center, angle);\n}\nvec2 wrinkle_getRotatedLipsEdgeWrinkle(in vec2 originalPoint, in int isLeftSide) {\n    vec2 wrinkleSize = 1.1*vec2(kLipsEdgeWrinkleSizeToLipsSizeRatio * posV[11].x, 0.6*posV[11].y);\n    vec2 lipsEdge = isLeftSide == 1 ? posV[12] : posV[13];\n    float directionSign = isLeftSide == 1 ? 1.0 : -1.0;\n    vec2 wrinkleCenter = lipsEdge + directionSign * 0.055 * (posV[13] - posV[12]);\n\n    float wrinkleMask = getEllipseMask(vec2(0.8, 0.5), textureCoordinateFix, wrinkleCenter,wrinkleSize, 0.5, 1.2);\n    vec2 wrinkleRotationCenter = lipsEdge + directionSign * 0.2 * (posV[13] - posV[12]);\n    vec2 rotated2DPoint = wrinkle_rotate2DPointAroundCenter(originalPoint, wrinkleRotationCenter, - directionSign * wrinkleMask * kLipsEdgeWrinklesRotationAngle);\n    return rotated2DPoint;\n}\nvec2 wrinkle_getRotatedLipsLeftEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 1);\n}\nvec2 wrinkle_getRotatedLipsRightEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 0);\n}\n\nfloat wrinkle_getNoseMask() {\n    return getEllipseMask(vec2(1.2, 1.5), textureCoordinateFix, posV[8].xy, posV[9], 0.8, 1.0);\n}\nvec2 getWrinkleDiff() {\n\n    vec2 displacedPoint = textureCoordinateFix;\n    float _noseMask = wrinkle_getNoseMask() * 0.9;\n    displacedPoint = mix(wrinkle_getRotatedLipsLeftEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    displacedPoint = mix(wrinkle_getRotatedLipsRightEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    vec2 displacedPosition = textureCoordinateFix + paramV[3] * (displacedPoint - textureCoordinateFix);\n    vec2 diffPosition = displacedPosition - textureCoordinateFix;\n    return diffPosition;\n}\n\nvoid main(){\n    vec2 trueDiff = vec2(0.0, 0.0);\n\n    vec4 texDiff = texture2D(inputImageTexture, textureCoordinate);\n    trueDiff = (texDiff.xy * 255.0 + texDiff.zw) / 127.5 - 1.0;   //diff of raw\n    if (trueDiff.x < -0.9 && trueDiff.y < -0.9){\n        trueDiff = vec2(0.0, 0.0);\n    }\n\n    textureCoordinateFix = (textureCoordinate * size - 0.5) / (size - 1.0);\n    vec2 diffPosition = getJawDiff() + getFaceWidthDiff() + getForeHeadDiff() + getWrinkleDiff() + trueDiff;\n    diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;\n    vec2 a = floor(diffPosition) / 255.0;\n    vec2 b = fract(diffPosition);\n    gl_FragColor = vec4(a,b);\n\n\n}\n";
  private static final String VERTEX_SHADER_VTF = "attribute vec4 position;\nattribute vec2 inputTextureCoordinate;\n\nvarying vec2 textureCoordinate;\n\nvoid main()\n{\n     gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     textureCoordinate = inputTextureCoordinate.xy;\n}";
  private static final int XCOORD_NUM = 64;
  private static final int YCOORD_NUM = 64;
  private static float[] mFullscreenVerticesPortrait;
  private static float[] mInitTextureCoordinatesPortrait;
  private float[] angles = { 0.0F, 0.0F, 0.0F };
  private float cheekbone = 0.0F;
  private float faceJaw = 0.0F;
  private float faceSmile = 0.0F;
  private float faceWidth = 1.0F;
  private float faceWidth2 = 1.0F;
  private float foreheadHeight = 0.0F;
  private float[] paramV2 = new float[6];
  private float[] posV2 = new float[72];
  private float[] size = { 1.0F, 1.0F };
  
  public ReshapeWholeFace_new()
  {
    super("attribute vec4 position;\nattribute vec2 inputTextureCoordinate;\n\nvarying vec2 textureCoordinate;\n\nvoid main()\n{\n     gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     textureCoordinate = inputTextureCoordinate.xy;\n}", "precision highp float;\n\n//common\nuniform float sin_t;\nuniform float cos_t;\nuniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\nuniform vec2 size;\nvarying vec2 textureCoordinate;\n\nvec2 textureCoordinateFix; //used for fix error\nuniform vec2 posV[36];\nuniform float paramV[6];\n\nconst float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\nconst float kPi = 3.14159265358979;\nconst float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\nuniform sampler2D inputImageTexture;\n\n//common func\nfloat getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n    // un-normalization\n    //boundingSize = boundingSize * size;\n    //point = point * size;\n    //center = center * size;\n\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\n\nfloat getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n    // un-normalization\n    //boundingSize = boundingSize * size;\n    //point = point * size;\n    //center = center * size;\n\n    float cos_t = cos(ang);\n    float sin_t = sin(ang);\n    vec2 translate = (point - center);\n    // rotate and scale\n    vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n    float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n    return 1.0 - smoothstep(a1, a2, d2);\n}\nvec2 rotate2DPoint(vec2 point, float angle) {\n    return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n}\n\nfloat face_getLeftEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), textureCoordinateFix, posV[1], posV[0], 0.5, 1.2);\n}\nfloat face_getRightEyeMask() {\n    return getEllipseMask(vec2(1.5, 0.9), textureCoordinateFix, posV[3], posV[2], 0.5, 1.2);\n}\nfloat face_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), textureCoordinateFix, posV[4], posV[5], 0.5, 1.0);\n}\nfloat face_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.1, 1.0), textureCoordinateFix, posV[6], posV[7], 0.5, 1.0);\n}\nfloat face_getLipsMask() {\n    return getEllipseMask(vec2(1.5, 1.5), textureCoordinateFix, posV[10], posV[11], 0.5, 1.2);\n}\nfloat face_getNoseMask() {\n    return getEllipseMask(vec2(1.1, 1.0), textureCoordinateFix, posV[8], posV[9], 0.5, 1.2);\n}\nfloat face_getFaceMask() {\n    return getEllipseMask(vec2(1.5, 1.2), textureCoordinateFix, posV[15], posV[14], 0.7, 0.9);\n}\nfloat face_getFaceMaskLeft2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, posV[17], posV[16], 0.5, 2.0, posV[18].x);\n}\nfloat face_getFaceMaskRight2(vec2 point) {\n    return getEllipseMask2(vec2(4.0, 1.4), point, posV[20], posV[19], 0.5, 2.0, posV[18].y);\n}\nfloat face_getFaceMaskUpLeft2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, posV[23], posV[22], 0.5, 0.8, posV[24].x);\n}\nfloat face_getFaceMaskUpRight2(vec2 point) {\n    return getEllipseMask2(vec2(2.0, 1.4), point, posV[26], posV[25], 0.5, 0.8, posV[24].y);\n}\nfloat face_getFaceMaskCheekboneLeft(vec2 point) {\n    return getEllipseMask2(vec2(1.5, 1.4), point, posV[32], posV[31], 0.2, 1.2, posV[33].x);\n}\nfloat face_getFaceMaskCheekboneRight(vec2 point) {\n    return getEllipseMask2(vec2(1.5, 1.4), point, posV[35], posV[34], 0.2, 1.2, posV[33].y);\n}\nvec2 face_getScaledFacePoint2(vec2 originalPoint, float scalingFactor, float faceCoarseMask) {\n    if (scalingFactor == 0.0) {\n        return originalPoint;\n    }\n    vec2 v = originalPoint - posV[15];\n    float d = dot(v, vec2(cos_t, sin_t));\n    d = d * 0.45 * faceCoarseMask * scalingFactor;\n    vec2 sc = d * vec2(cos_t, sin_t);\n    return originalPoint+sc;\n}\n\nvec2 getFaceWidthDiff() {\n     vec2 diffPosition = vec2(0, 0);\n     vec2 displacedFacePoint = textureCoordinateFix;\n\n\n     float faceNegativeRegionsMask = (1.0 - 0.8*face_getLeftEyeMask()) * (1.0 - 0.8*face_getRightEyeMask()) * (1.0 - 0.8*face_getLeftEyebrowMask()) * (1.0 - 0.8*face_getRightEyebrowMask()) * (1.0 - 0.6*face_getLipsMask()) * (1.0 - 0.9*face_getNoseMask());\n     float faceCoarseMask   = face_getFaceMask();\n     //width\n     displacedFacePoint   = face_getScaledFacePoint2(displacedFacePoint, paramV[0], faceCoarseMask*faceNegativeRegionsMask);\n\n     diffPosition = displacedFacePoint - textureCoordinateFix;\n\n     vec2 displacedFacePoint1 = displacedFacePoint;\n     for (int i = 0; i < 5; i++){   //4 times\n         float thres = 1.2;\n         if (i == 4) thres = 1.0;\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (posV[21] - posV[17])* 0.1, face_getFaceMaskLeft2(displacedFacePoint1) * paramV[1] * thres);\n         displacedFacePoint1 = mix(displacedFacePoint1, displacedFacePoint1 - (posV[21] - posV[20])* 0.1, face_getFaceMaskRight2(displacedFacePoint1) * paramV[1] * thres);\n     }\n     vec2 displacedFacePoint2 = displacedFacePoint;\n     for (int i = 0; i < 3; i++){\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (posV[21] - posV[23])* 0.1, face_getFaceMaskUpLeft2(displacedFacePoint2) * paramV[1]);\n         displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (posV[21] - posV[26])* 0.1, face_getFaceMaskUpRight2(displacedFacePoint2) * paramV[1]);\n     }\n\n     //cheekbone\n     displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (posV[21] - posV[32])* 0.1, face_getFaceMaskCheekboneLeft(displacedFacePoint2) * paramV[5] * 2.0);\n     displacedFacePoint2 = mix(displacedFacePoint2, displacedFacePoint2 - (posV[21] - posV[35])* 0.1, face_getFaceMaskCheekboneRight(displacedFacePoint2) * paramV[5] * 2.0);\n\n     diffPosition = displacedFacePoint1 - displacedFacePoint + displacedFacePoint2 - displacedFacePoint + diffPosition;\n\n\n     return diffPosition;\n }\n\n\nfloat jaw_getLipsMask() {\n    return getEllipseMask(vec2(1.4, 1.0), textureCoordinateFix, posV[10], posV[11], 0.5, 1.2);\n}\nfloat jaw_getNoseMask() {\n    return getEllipseMask(vec2(1.0, 1.5), textureCoordinateFix, posV[8], posV[9], 0.5, 1.2);\n}\nfloat jaw_getJawMask() {\n    return getEllipseMask(vec2(1.8, 1.0), textureCoordinateFix, posV[27], posV[28], 0.5, 1.2);\n}\nvec2 getJawDiff() {\n    float lipsMask = jaw_getLipsMask();\n    float noseMask = jaw_getNoseMask();\n    float jawMask = jaw_getJawMask() * (1.0 - 0.9 * lipsMask) * (1.0 - 0.9 * noseMask);\n\n    vec2 displacedPoint = textureCoordinateFix;\n\n    const float kJawLiftingYRatio = 0.1;\n    vec2 jawLiftingVector = vec2(0.0, kJawLiftingYRatio * posV[28].y);\n    jawLiftingVector = vec2(dot(jawLiftingVector, vec2(cos_t, -sin_t)), dot(jawLiftingVector, vec2(sin_t, cos_t)));\n    vec2 jawPositionPoint = displacedPoint + jawLiftingVector;\n    vec2 displacedPoint2 = mix(displacedPoint, jawPositionPoint, paramV[2] * jawMask);\n\n    const vec2 kScaleFactors = vec2(1.1, 1.1);\n    displacedPoint = posV[27] + kScaleFactors * (textureCoordinateFix - posV[27]);\n    displacedPoint = mix(textureCoordinateFix, displacedPoint, paramV[2] * jawMask);\n\n    displacedPoint = displacedPoint * 0.65 + displacedPoint2 * 0.35;\n    vec2 diffPosition = displacedPoint - textureCoordinateFix;\n    return diffPosition;\n}\n\nfloat head_getLeftEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), textureCoordinateFix, posV[4], posV[5], 0.6, 1.0);\n}\nfloat head_getRightEyebrowMask() {\n    return getEllipseMask(vec2(1.0, 0.8), textureCoordinateFix, posV[6], posV[7], 0.6, 1.0);\n}\nfloat head_getForeheadMask() {\n    return getEllipseMask(vec2(1.9, 1.6), textureCoordinateFix, posV[29], posV[30], 0.2, 1.4);\n}\n\nvec2 getForeHeadDiff() {\n    float foreheadMask    = head_getForeheadMask() * (1.0 - head_getLeftEyebrowMask()) * (1.0 - head_getRightEyebrowMask());\n    vec2 displacedForeheadPoint   = textureCoordinateFix;\n\n    const float kForeheadLiftingYRatio = 0.04;\n    vec2 foreheadLiftingVector = vec2(0.0, -kForeheadLiftingYRatio * posV[30].y);\n    foreheadLiftingVector = vec2(dot(foreheadLiftingVector, vec2(cos_t, -sin_t)), dot(foreheadLiftingVector, vec2(sin_t, cos_t)));\n    vec2 foreheadPositionPoint = displacedForeheadPoint + foreheadLiftingVector;\n    displacedForeheadPoint = mix(displacedForeheadPoint, foreheadPositionPoint, foreheadMask * paramV[4]);\n\n    vec2 diffPosition = displacedForeheadPoint - textureCoordinateFix;\n    return diffPosition;\n}\n\nvec2 wrinkle_rotate2DPointAroundCenter(in vec2 point, in vec2 center, in float angle) {\n    return center + rotate2DPoint(point - center, angle);\n}\nvec2 wrinkle_getRotatedLipsEdgeWrinkle(in vec2 originalPoint, in int isLeftSide) {\n    vec2 wrinkleSize = 1.1*vec2(kLipsEdgeWrinkleSizeToLipsSizeRatio * posV[11].x, 0.6*posV[11].y);\n    vec2 lipsEdge = isLeftSide == 1 ? posV[12] : posV[13];\n    float directionSign = isLeftSide == 1 ? 1.0 : -1.0;\n    vec2 wrinkleCenter = lipsEdge + directionSign * 0.055 * (posV[13] - posV[12]);\n\n    float wrinkleMask = getEllipseMask(vec2(0.8, 0.5), textureCoordinateFix, wrinkleCenter,wrinkleSize, 0.5, 1.2);\n    vec2 wrinkleRotationCenter = lipsEdge + directionSign * 0.2 * (posV[13] - posV[12]);\n    vec2 rotated2DPoint = wrinkle_rotate2DPointAroundCenter(originalPoint, wrinkleRotationCenter, - directionSign * wrinkleMask * kLipsEdgeWrinklesRotationAngle);\n    return rotated2DPoint;\n}\nvec2 wrinkle_getRotatedLipsLeftEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 1);\n}\nvec2 wrinkle_getRotatedLipsRightEdgeWrinkle(in vec2 originalPoint) {\n    return wrinkle_getRotatedLipsEdgeWrinkle(originalPoint, 0);\n}\n\nfloat wrinkle_getNoseMask() {\n    return getEllipseMask(vec2(1.2, 1.5), textureCoordinateFix, posV[8].xy, posV[9], 0.8, 1.0);\n}\nvec2 getWrinkleDiff() {\n\n    vec2 displacedPoint = textureCoordinateFix;\n    float _noseMask = wrinkle_getNoseMask() * 0.9;\n    displacedPoint = mix(wrinkle_getRotatedLipsLeftEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    displacedPoint = mix(wrinkle_getRotatedLipsRightEdgeWrinkle(displacedPoint), displacedPoint, _noseMask);\n    vec2 displacedPosition = textureCoordinateFix + paramV[3] * (displacedPoint - textureCoordinateFix);\n    vec2 diffPosition = displacedPosition - textureCoordinateFix;\n    return diffPosition;\n}\n\nvoid main(){\n    vec2 trueDiff = vec2(0.0, 0.0);\n\n    vec4 texDiff = texture2D(inputImageTexture, textureCoordinate);\n    trueDiff = (texDiff.xy * 255.0 + texDiff.zw) / 127.5 - 1.0;   //diff of raw\n    if (trueDiff.x < -0.9 && trueDiff.y < -0.9){\n        trueDiff = vec2(0.0, 0.0);\n    }\n\n    textureCoordinateFix = (textureCoordinate * size - 0.5) / (size - 1.0);\n    vec2 diffPosition = getJawDiff() + getFaceWidthDiff() + getForeHeadDiff() + getWrinkleDiff() + trueDiff;\n    diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;\n    vec2 a = floor(diffPosition) / 255.0;\n    vec2 b = fract(diffPosition);\n    gl_FragColor = vec4(a,b);\n\n\n}\n");
    initParams();
  }
  
  public void ApplyGLSLFilter()
  {
    initParams();
    super.ApplyGLSLFilter();
    setDrawMode(AEOpenRenderConfig.DRAW_MODE.TRIANGLE_STRIP);
  }
  
  public void getparamV()
  {
    float[] arrayOfFloat = this.paramV2;
    arrayOfFloat[0] = this.faceWidth;
    arrayOfFloat[1] = this.faceWidth2;
    arrayOfFloat[2] = this.faceJaw;
    arrayOfFloat[3] = this.faceSmile;
    arrayOfFloat[4] = this.foreheadHeight;
    arrayOfFloat[5] = this.cheekbone;
  }
  
  public void initAttribParams()
  {
    setPositions(mFullscreenVerticesPortrait, false);
    setTexCords(mInitTextureCoordinatesPortrait, false);
    setCoordNum(8257);
  }
  
  public void initParams()
  {
    addParam(new UniformParam.Float2sParam("posV", this.posV2));
    getparamV();
    addParam(new UniformParam.Float1sParam("paramV", this.paramV2));
    addParam(new UniformParam.FloatsParam("angles", this.angles));
    addParam(new UniformParam.FloatsParam("size", this.size));
    float f = (float)Math.cos(this.angles[2]);
    addParam(new UniformParam.FloatParam("sin_t", (float)Math.sin(this.angles[2])));
    addParam(new UniformParam.FloatParam("cos_t", f));
  }
  
  public void setInitMesh(float[] paramArrayOfFloat1, float[] paramArrayOfFloat2)
  {
    mFullscreenVerticesPortrait = paramArrayOfFloat1;
    mInitTextureCoordinatesPortrait = paramArrayOfFloat2;
  }
  
  public void setParam(Map<String, Object> paramMap)
  {
    if (paramMap.containsKey("posV2")) {
      this.posV2 = ((float[])paramMap.get("posV2"));
    }
    float f;
    if (paramMap.containsKey("foreheadHeight"))
    {
      this.foreheadHeight = (((Float)paramMap.get("foreheadHeight")).floatValue() * 0.02F);
      f = this.foreheadHeight;
      if (f > 0.0F) {
        this.foreheadHeight = (f * 1.5F);
      }
    }
    if (paramMap.containsKey("faceJaw")) {
      this.faceJaw = (((Float)paramMap.get("faceJaw")).floatValue() * 0.01F);
    }
    if (paramMap.containsKey("faceSmile")) {
      this.faceSmile = (((Float)paramMap.get("faceSmile")).floatValue() * 0.03F);
    }
    if (paramMap.containsKey("faceWidth"))
    {
      this.faceWidth = (((Float)paramMap.get("faceWidth")).floatValue() * 0.0012F);
      f = this.faceWidth;
      if (f > 0.0F) {
        this.faceWidth = (f * 1.15F);
      }
    }
    if (paramMap.containsKey("faceWidth2"))
    {
      this.faceWidth2 = (((Float)paramMap.get("faceWidth2")).floatValue() * 0.0017F);
      f = this.faceWidth2;
      if (f > 0.0F) {
        this.faceWidth2 = (f * 1.15F * 0.95F);
      }
    }
    if (paramMap.containsKey("cheekboneThin")) {
      this.cheekbone = (((Float)paramMap.get("cheekboneThin")).floatValue() * 0.0017F);
    }
    if (paramMap.containsKey("angles")) {
      this.angles = ((float[])paramMap.get("angles"));
    }
    if (paramMap.containsKey("size")) {
      this.size = ((float[])paramMap.get("size"));
    }
    initParams();
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes15.jar
 * Qualified Name:     com.tencent.ttpic.filter.ReshapeWholeFace_new
 * JD-Core Version:    0.7.0.1
 */