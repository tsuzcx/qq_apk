package com.tencent.ttpic.filter.shader;

public abstract interface TransformVertexShaderContent
{
  public static final String CONTENT = "precision highp float;\nattribute vec4 position;\nattribute vec2 inputTextureCoordinate;\nvarying vec2 textureCoordinate;\nuniform float screenRatioX;\nuniform float screenRatioY;\nuniform vec4 item[120];\nuniform float faceRatio;\nuniform float sin_roll;\nuniform float cos_roll;\nuniform float tan_yaw;\nuniform float cos_yaw;\nuniform float tan_pitch;\nuniform float cos_pitch;\nuniform int itemCount;\nuniform int meshVersion;\n\n//vec4[2]:type, strength, pointX, pointY, radius, direction, faceRatio,0\n\nfloat my_smoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvec4 distortedPosition(vec4 currentPosition) {\n    vec4 newPosition = currentPosition;\n    if (newPosition.x < -1.01 || newPosition.y < -1.01 || newPosition.x > 1.01 || newPosition.y > 1.01) {\n        return newPosition;\n    }\n    for (int i = 0; i < itemCount; i++) {\n        int idx = i * 2;\n        float item0 = item[idx].r;\n        if (item0 < 0.1) {\n            break;\n        }\n\n        vec2 centerPoint = vec2(item[idx].b, item[idx].a);\n        vec2 ratioTransTargetPoint = vec2(newPosition.x * screenRatioX, newPosition.y * screenRatioY);\n\n        vec2 distVector = ratioTransTargetPoint - centerPoint;\n        // first, rotate vector by face roll\n        vec2 _v = vec2(distVector.x*cos_roll+distVector.y*sin_roll, -distVector.x*sin_roll+distVector.y*cos_roll);\n        float distX0 = abs(_v.x);\n        float distY0 = abs(_v.y);\n        float item4 = item[idx+1].r;\n        float ddist = sqrt(distX0 * distX0 + distY0 * distY0);\n        if (ddist * 0.5 > item4) continue;\n\n        // second, remove perspective effect\n        float d = _v.x * tan_yaw;\n        float d2 = _v.y * tan_pitch;\n\n        float item6 = item[idx+1].b;\n        float depth = item6 + d;\n        if(depth <= 0.0) {\n            continue;\n        }\n        depth = clamp(depth, 1.0, 5.0);\n        float distX1 = distX0 * (depth / item6);\n        float distY1 = distY0 * (depth / item6);\n        // third, remove yaw and pitch effect\n        if(depth > 2.5) {\n          distX1 = distX1 / (1.0-(1.0-cos_yaw)*my_smoothstep(0.0, 0.05, depth-2.5));\n        }\n        float dist = sqrt(distX1 * distX1 + distY1 * distY1);\n\n        if (item0 > 1.1) {\n            dist = dist / 1.2;\n        }\n        \n        if (dist < item4) {\n            vec2 strengthAdjust = vec2(cos_yaw, 1.0);\n            if(depth < 2.5) {\n              strengthAdjust.x = 1.0-(1.0-cos_yaw)*(1.0-my_smoothstep(0.0, 0.1, 2.5-depth));\n            }\n            float distRatio = dist / item4;\n            float posRatioX = screenRatioX;\n            float posRatioY = screenRatioY;\n            float posScaleY = 1.0;\n            float vecRatioX = 1.0;\n            float vecRatioY = 1.0;\n            float vecScaleY = 9.0 / 16.0;\n            if (meshVersion < 2) {\n                posRatioX = 1.0;\n                posRatioY = 1.0;\n                posScaleY = 9.0 / 16.0;\n                vecRatioX = screenRatioX;\n                vecRatioY = screenRatioY;\n                vecScaleY = 1.0;\n            }\n            float dx = (centerPoint.x - ratioTransTargetPoint.x) / vecRatioX / 1.2;\n            float dy = (centerPoint.y - ratioTransTargetPoint.y) / vecRatioY / 1.2;\n            if (item0 < 1.1) {\n                float weight = 1.2 * (1.0 - smoothstep(0.0, 1.0, distRatio)) * item[idx].g;\n                dx = dx * weight;\n                dy = dy * weight;\n                // rotate\n                vec2 vector = vec2(dx*cos_roll+dy*sin_roll, -dx*sin_roll+dy*cos_roll) * strengthAdjust;\n                // rotate back\n                newPosition.x -= (vector.x * cos_roll - vector.y * sin_roll) / posRatioX;\n                newPosition.y -= (vector.y * cos_roll + vector.x * sin_roll) / posRatioY;\n            } else if (item0 < 2.1) {\n                float weight = (1.0 - smoothstep(0.0, 1.0, distRatio)) * item[idx].g;\n                dx = dx * weight;\n                dy = dy * weight;\n                // rotate\n                vec2 vector = vec2(dx*cos_roll+dy*sin_roll, -dx*sin_roll+dy*cos_roll) * strengthAdjust;\n                // rotate back\n                newPosition.x += (vector.x * cos_roll - vector.y * sin_roll) / posRatioX;\n                newPosition.y += (vector.y * cos_roll + vector.x * sin_roll) / posRatioY;\n            } else if (item0 < 3.1) {\n                float delta = 1.0 - distRatio*distRatio;\n                float deltaScale = smoothstep(0.0, 1.0, delta);\n                float weight = delta * deltaScale * item4 * 0.5 * item[idx].g;\n                vec2 vector = vec2(1.0 / vecRatioX, 1.0 / vecRatioY);\n                float item5 = item[idx+1].g;\n                if (item5 < 1.1) {\n                    vector.x *= -weight; vector.y = 0.0;\n                } else if (item5 < 2.1) {\n                    vector.x = 0.0; vector.y *= -weight;\n                } else if (item5 < 3.1) {\n                    vector.x *= weight; vector.y = 0.0;\n                } else if (item5 < 4.1) {\n                    vector.x = 0.0; vector.y *= weight;\n                } else if (item5 < 5.1) {\n                    vector.x *= -weight; vector.y *= -weight;\n                } else if (item5 < 6.1) {\n                    vector.x *= weight; vector.y *= -weight;\n                } else if (item5 < 7.1) {\n                    vector.x *= -weight; vector.y *= weight;\n                } else if (item5 < 8.1) {\n                    vector.x *= weight; vector.y *= weight;\n                } else {\n                    vector.x = 0.0; vector.y = 0.0;\n                }\n                // add yaw and pitch\n                vector = vector * strengthAdjust;\n                vector.y *= vecScaleY;\n                newPosition.x += (vector.x * cos_roll - vector.y * sin_roll) / posRatioX;\n                newPosition.y += (vector.y * cos_roll + vector.x * sin_roll) * posScaleY / posRatioY;\n            } else if (item0 < 5.1) {\n                float delta = 1.0 - distRatio*distRatio;\n                float deltaScale = smoothstep(0.0, 1.0, delta);\n                float weight = delta * deltaScale * item4 * 0.5 * item[idx].g;\n                dx = weight*cos(item[idx+1].g) / vecRatioX;\n                dy = weight*sin(item[idx+1].g) / vecRatioY;\n                // rotate\n                vec2 vector = vec2(dx*cos_roll+dy*sin_roll, -dx*sin_roll+dy*cos_roll);\n                // add yaw and pitch\n                vector = vector * strengthAdjust;\n                vector.y *= vecScaleY;\n                // rotate back\n                newPosition.x += (vector.x * cos_roll - vector.y * sin_roll) / posRatioX;\n                newPosition.y += (vector.y * cos_roll + vector.x * sin_roll) * posScaleY / posRatioY;\n            }\n        }\n    }\n    return newPosition;\n}\nvoid main() {\n    textureCoordinate = inputTextureCoordinate.xy;\n    gl_Position = distortedPosition(position);\n    //gl_Position = position;\n}\n ";
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes15.jar
 * Qualified Name:     com.tencent.ttpic.filter.shader.TransformVertexShaderContent
 * JD-Core Version:    0.7.0.1
 */