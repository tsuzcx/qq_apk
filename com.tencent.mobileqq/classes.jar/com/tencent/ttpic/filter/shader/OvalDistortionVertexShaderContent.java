package com.tencent.ttpic.filter.shader;

public abstract interface OvalDistortionVertexShaderContent
{
  public static final String CONTENT = " precision highp float;\n attribute vec4 position;\n attribute vec2 inputTextureCoordinate;\n varying vec2 textureCoordinate;\n// struct MeshDistortionType {\n//     int type; // 0\n//     float strength; // 1\n//     vec2 point; // 2 3\n//     float height; // 4\n//     float width; // 5\n//     float angle; // 6\n//     float innerCirc; // 7\n//     float outerCirc; // 8\n//     int quadrant; // 9\n//     float pushDx; // 10\n//     float pushDy; // 11\n// };\n uniform float item[240];\n\n float my_smoothstep(float edge0, float edge1, float x) {\n     float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n     return t * t * (3.0 - 2.0 * t);\n }\n\n float ovalWeight(float innerCirc, float outerCirc, float dist) {\n     return (1.0 - my_smoothstep(innerCirc, outerCirc, dist));\n }\n\n vec4 distortedPosition(vec4 currentPosition) {\n     vec4 newPosition = currentPosition;\n\n     if (newPosition.x == -1.0 || newPosition.y == -1.0 || newPosition.x == 1.0 || newPosition.y == 1.0) {\n         return newPosition;\n     }\n\n     for (int i = 0; i < 240; i+=12) {\n         if (item[i] <= 0.5) {\n             return newPosition;\n         }\n         vec2 centerPoint = vec2(item[i+2], item[i+3]);\n         vec2 ratioTransTargetPoint = vec2(newPosition.x, newPosition.y);\n\n         vec2 distVector = ratioTransTargetPoint - centerPoint;\n         vec2 newDistVector;\n\n         newDistVector.x = distVector.x * cos(-item[i+6]) - distVector.y * sin(-item[i+6]);\n         newDistVector.y = distVector.x * sin(-item[i+6]) + distVector.y * cos(-item[i+6]);\n\n         float dist = sqrt(newDistVector.x * newDistVector.x / item[i+4] / item[i+4] + newDistVector.y * newDistVector.y / item[i+5] / item[i+5]);\n         float weight = ovalWeight(item[i+7], item[i+8], dist);\n\n         // 坐标放正后的变化\n         if (item[i] < 1.5) {\n             // 扩大\n             float strength = item[i+1] * 0.3;\n             if (item[i+9] < 1.5 && dist < item[i+8]) {\n                 newDistVector = newDistVector * (1.0 + weight * strength);\n             }\n             else if (item[i+9] < 2.5 && dist < item[i+8] && newDistVector.x < 0.0) {\n                 newDistVector.x = newDistVector.x * (1.0 + weight * strength);\n             }\n             else if (item[i+9] < 3.5 && dist < item[i+8] && newDistVector.y > 0.0) {\n                 newDistVector.y = newDistVector.y * (1.0 + weight * strength);\n             }\n             else if (item[i+9] < 4.5 && dist < item[i+8] && newDistVector.x > 0.0) {\n                 newDistVector.x = newDistVector.x * (1.0 + weight * strength);\n             }\n             else if (item[i+9] < 5.5 && dist < item[i+8] && newDistVector.y > 0.0) {\n                 newDistVector.y = newDistVector.y * (1.0 + weight * strength);\n             }\n             else if (item[i+9] < 6.5 && dist < item[i+8]) {\n                 newDistVector.x = newDistVector.x * (1.0 + weight * strength);\n             }\n             else if (item[i+9] < 7.5 && dist < item[i+8]) {\n                 newDistVector.y = newDistVector.y * (1.0 + weight * strength);\n             }\n         } else if (item[i] < 2.5) {\n             // 缩小\n             float strength = item[i+1] * 0.3;\n             if (item[i+9] < 1.5 && dist < item[i+8]) {\n                 newDistVector = newDistVector * (1.0 - weight * strength);\n             }\n             else if (item[i+9] < 2.5 && dist < item[i+8] && newDistVector.x < 0.0) {\n                 newDistVector.x = newDistVector.x * (1.0 - weight * strength);\n             }\n             else if (item[i+9] < 3.5 && dist < item[i+8] && newDistVector.y > 0.0) {\n                 newDistVector.y = newDistVector.y * (1.0 - weight * strength);\n             }\n             else if (item[i+9] < 4.5 && dist < item[i+8] && newDistVector.x > 0.0) {\n                 newDistVector.x = newDistVector.x * (1.0 - weight * strength);\n             }\n             else if (item[i+9] < 5.5 && dist < item[i+8] && newDistVector.y > 0.0) {\n                 newDistVector.y = newDistVector.y * (1.0 - weight * strength);\n             }\n             else if (item[i+9] < 6.5 && dist < item[i+8]) {\n                 newDistVector.x = newDistVector.x * (1.0 - weight * strength);\n             }\n             else if (item[i+9] < 7.5 && dist < item[i+8]) {\n                 newDistVector.y = newDistVector.y * (1.0 - weight * strength);\n             }\n         }\n\n         distVector.x = newDistVector.x * cos(item[i+6]) - newDistVector.y * sin(item[i+6]);\n         distVector.y = newDistVector.x * sin(item[i+6]) + newDistVector.y * cos(item[i+6]);\n\n         // 原始坐标下的变化\n         if (item[i] < 3.5 && item[i] > 2.5 && dist < item[i+8]) {\n             distVector.x = distVector.x + item[i+10] * weight * item[i+1];\n             distVector.y = distVector.y + item[i+11] * weight * item[i+1];\n         }\n\n         ratioTransTargetPoint = distVector + centerPoint;\n         newPosition.x = ratioTransTargetPoint.x;\n         newPosition.y = ratioTransTargetPoint.y;\n     }\n     return newPosition;\n }\n\n void main() {\n     textureCoordinate = inputTextureCoordinate.xy;\n     gl_Position = distortedPosition(position);\n }";
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes15.jar
 * Qualified Name:     com.tencent.ttpic.filter.shader.OvalDistortionVertexShaderContent
 * JD-Core Version:    0.7.0.1
 */