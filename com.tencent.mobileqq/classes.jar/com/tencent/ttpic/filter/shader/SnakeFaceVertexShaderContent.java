package com.tencent.ttpic.filter.shader;

public abstract interface SnakeFaceVertexShaderContent
{
  public static final String CONTENT = " attribute vec4 position;\n attribute vec4 inputTextureCoordinate;\n\n uniform int nPoint;\n uniform vec2 fSrc[102];\n uniform vec2 fDst[102];\n\n varying vec2 textureCoordinate;\n\n void main(void) {\n     if (nPoint <= 0) {\n         vec4 xPosition = position;\n         gl_Position = xPosition;\n         textureCoordinate = inputTextureCoordinate.xy;\n         return;\n     }\n     float M_PI_HALF = 1.57079632679;\n\n     float imageWidth = fDst[101].x;\n     float imageHeight = fDst[101].y;\n     float xCenter = fSrc[64].x;\n     float yCenter = fSrc[64].y;\n\n\n     vec4 rawPosition = position;\n     rawPosition.x = (position.x + 1.0) * imageWidth / 2.0;\n     rawPosition.y = (position.y + 1.0) * imageHeight / 2.0;\n\n//     for (int ii = 0; ii < 19; ii++){\n//         if (abs(rawPosition.x - fSrc[ii].x) < 3.0 && abs(rawPosition.y - fSrc[ii].y) < 3.0) {\n//             vec4 xPosition = position;\n//             xPosition.x = 0.0;\n//             xPosition.y = 0.0;\n//             gl_Position = xPosition;\n//             textureCoordinate = inputTextureCoordinate.xy;\n//             return;\n//         }\n//     }\n     vec2 swq;\n     vec2 qstar;\n     vec2 newP;\n     vec2 tmpP;\n     float sw;\n\n     //float w[MAX_ASSIGN_POINT];\n\n     vec2 swp;\n     vec2 pstar;\n     vec2 curV;\n     vec2 curVJ;\n     vec2 Pi;\n     vec2 PiJ;\n     float miu_s;\n\n     float i = rawPosition.x;\n     float j = rawPosition.y;\n     sw = 0.0;\n     swp.x = swp.y = 0.0;\n     swq.x = swq.y = 0.0;\n     newP.x = newP.y = 0.0;\n     curV.x = i;\n     curV.y = j;\n     for (int k = 0; k < nPoint - 1; k++) {\n         float w = 1.0 / ((i - fSrc[k].x) * (i - fSrc[k].x) +\n                          (j - fSrc[k].y) * (j - fSrc[k].y));\n         sw = sw + w;\n         swp = swp + w * fSrc[k];\n         swq = swq + w * fDst[k];\n\n//         w[k] = 1.0 / ((i - fSrc[k].x) * (i - fSrc[k].x) +\n//                       (j - fSrc[k].y) * (j - fSrc[k].y));\n//         sw = sw + w[k];\n//         swp = swp + w[k] * fSrc[k];\n//         swq = swq + w[k] * fDst[k];\n     }\n\n     pstar = (1.0 / sw) * swp;\n     qstar = 1.0 / sw * swq;\n\n     miu_s = 0.0;\n     for (int k = 0; k < nPoint - 1; k++) {\n\n         float w = 1.0 / ((i - fSrc[k].x) * (i - fSrc[k].x) +\n                          (j - fSrc[k].y) * (j - fSrc[k].y));\n         Pi = fSrc[k] - pstar;\n         miu_s += w * dot(Pi, Pi);\n     }\n\n     curV -= pstar;\n     curVJ.x = -curV.y;\n     curVJ.y = curV.x;\n\n     for (int k = 0; k < nPoint - 1; k++) {\n\n         float w = 1.0 / ((i - fSrc[k].x) * (i - fSrc[k].x) +\n                          (j - fSrc[k].y) * (j - fSrc[k].y));\n         Pi = fSrc[k] - pstar;\n         PiJ.x = -Pi.y;\n         PiJ.y = Pi.x;\n\n         tmpP.x = dot(Pi, curV) * fDst[k].x -\n         dot(PiJ, curV) * fDst[k].y;\n         tmpP.y = - dot(Pi, curVJ) * fDst[k].x +\n         dot(PiJ, curVJ) * fDst[k].y;\n         tmpP *= w / miu_s;\n         newP += tmpP;\n     }\n     newP += qstar;\n\n     vec4 nPosition = rawPosition;\n     nPosition.x = newP.x;\n     nPosition.y = newP.y;\n\n     i = nPosition.x - rawPosition.x;\n     j = nPosition.y - rawPosition.y;\n\n     if (rawPosition.x < xCenter) {\n         i = sin(rawPosition.x * M_PI_HALF / xCenter) * i;\n     } else {\n         i = (i * sin((imageWidth - rawPosition.x) * M_PI_HALF / (imageWidth - xCenter)));\n     }\n     if (rawPosition.y < yCenter) {\n         j = sin(rawPosition.y * M_PI_HALF / yCenter) * j;\n     } else {\n         j = (j * sin((imageHeight - rawPosition.y) * M_PI_HALF / (imageHeight - yCenter)));\n     }\n\n     nPosition.x = rawPosition.x + i;\n     nPosition.y = rawPosition.y + j;\n\n     if (rawPosition.x <= 0.1) nPosition.x = 0.0;\n     if (rawPosition.x >= imageWidth - 0.1) nPosition.x = imageWidth;\n     if (rawPosition.y <= 0.1) nPosition.y = 0.0;\n     if (rawPosition.y >= imageHeight - 0.1) nPosition.y = imageHeight;\n\n     nPosition.x = (nPosition.x * 2.0 / imageWidth) - 1.0;\n     nPosition.y = (nPosition.y * 2.0 / imageHeight) - 1.0;\n\n     gl_Position = nPosition;\n     textureCoordinate = inputTextureCoordinate.xy;\n }";
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes10.jar
 * Qualified Name:     com.tencent.ttpic.filter.shader.SnakeFaceVertexShaderContent
 * JD-Core Version:    0.7.0.1
 */