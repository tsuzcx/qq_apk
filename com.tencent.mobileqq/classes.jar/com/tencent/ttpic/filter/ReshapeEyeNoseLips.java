package com.tencent.ttpic.filter;

import com.tencent.aekit.openrender.AEOpenRenderConfig.DRAW_MODE;
import com.tencent.aekit.openrender.UniformParam.FloatParam;
import com.tencent.aekit.openrender.UniformParam.FloatsParam;
import com.tencent.aekit.openrender.internal.VideoFilterBase;
import com.tencent.filter.BaseFilter;
import com.tencent.ttpic.openapi.filter.ReshapeType;
import java.util.Map;

public class ReshapeEyeNoseLips
  extends VideoFilterBase
{
  public static final String FRAGMENT_SHADER_NORMAL = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n    //gl_FragColor = vec4(inputTextureCoordinate.xy, vec2(0.0, 1.0));\n\n    //vec4 color = vec4(textureCoordinate.x*8.0+0.5, textureCoordinate.y*8.0+0.5, 0.5, 1.0);\n    //gl_FragColor = color;\n\n    //gl_FragColor = vec4(textureCoordinate, textureCoordinate.x, 1.0);\n\n    gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n}";
  private static final String FRAGMENT_SHADER_VTF = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n\n    //vec2 diffPosition = textureCoordinate;\n    //float ddx = (diffPosition.x + 1.0) / 2.0;\n    //float ddy = (diffPosition.y + 1.0) / 2.0;\n    //diffPosition = vec2(ddx,ddy);\n    //vec2 a = fract(diffPosition * 255.0 / 256.0);\n    //vec2 b = fract(diffPosition * 255.0 * 255.0 / 256.0);\n    //gl_FragColor = vec4(a,b);\n\n    // 新版的 shader 颜色通道中记录的是位移偏移量，只有在最后 combinedFilter 才最终将所有 filter 的位移量叠加，去图上取点。这样的好处是：\n    // 1. 只有 128 * 128 个点\n    // 2. smoothstep 会更平滑，128 * 128 个点取插值，原来的处理方法会使像素点变模糊\n    // 3. 两个矩形交叠的地方，位移处理的先后顺序不影响结果（不能说这是好还是坏，因为 PS 的液化是作用在原图上的）\n\n    // 至于此处要改为 * 255 再 / 255 是为了提升精度（浮点纹理 iOS 不支持，而一个字节只能表示 256 个不同值）\n    // 本来小奇使用了浮点纹理，但是发现有机型不支持，不用浮点纹理又精度不够，所以采用这个方法，变成2个字节表示一个值，提升了精度。\n    vec2 diffPosition = textureCoordinate;\n    diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;  // 0.5 * (diffPosition + 1.0) 是将(-1, 1)间的值转换到(0, 1)，\n    vec2 a = floor(diffPosition) / 255.0;\n    vec2 b = fract(diffPosition);\n    gl_FragColor = vec4(a, b);\n\n\n    //vec2 diffPosition = textureCoordinate;\n    //diffPosition = 0.5 * (diffPosition + 1.0) * 256.0;\n    //vec2 a = floor(diffPosition) / 256.0;\n    //vec2 b = fract(diffPosition);\n    //gl_FragColor = vec4(a, b);\n}\n";
  private static final String VERTEX_SHADER_NORMAL = " precision highp float;\n\nattribute vec4 position;\n\n //common\n uniform float sin_t;\n uniform float cos_t;\n uniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\n uniform vec2 size;\n varying vec2 textureCoordinate;\n\n //eye\n uniform vec2 leftEyePlainSize;\n uniform vec2 leftEyeCenter;\n uniform vec2 rightEyePlainSize;\n uniform vec2 rightEyeCenter;\n uniform float eyesSize; // it is eye size adjust factor\n uniform float eyesWidth; // it is eye width adjust factor\n uniform float eyesHeight; // it is eye height adjust factor\n uniform float eyesTiltAngle; // rotate angle need to apply\n uniform float eyesDistance;\n\n //nose\n uniform vec2 nose3DCenter;\n uniform vec2 nosePlainSize;\n uniform vec2 noseTipCenter;\n uniform vec2 noseTipPlaneSize;\n uniform vec2 noseBottomCenter;\n uniform float noseSize;\n uniform float noseOutlineWidth;\n uniform float noseBridgeWidth;\n uniform float nosePosition;\n uniform float noseTipSize;\n\n //teeth\n uniform vec2 teethPlainSize;\n uniform vec2 teethCenter;\n\n //lips\n uniform vec2 lipsCenter;\n uniform vec2 lipsPlainSize;\n uniform float lipsSize;\n uniform float lipsWidth;\n uniform float lipsHeight;\n uniform float lipsYPosition;\n uniform vec2 lipsProtectSizeLeft;\n uniform vec2 lipsProtectCenterLeft;\n uniform float lipsProtectAngleLeft;\n uniform vec2 lipsProtectSizeRight;\n uniform vec2 lipsProtectCenterRight;\n uniform float lipsProtectAngleRight;\n\n //eye brow\n uniform vec2 leftEyebrowPlainSize;\n uniform vec2 leftEyebrowCenter;\n uniform vec2 rightEyebrowPlainSize;\n uniform vec2 rightEyebrowCenter;\n uniform float eyebrowHeight; // eyebrow height adjust factor\n uniform float eyebrowDistance;\n uniform float eyebrowTiltAngle; // rotate angle need to apply\n\n uniform sampler2D inputImageTexture;\n\n const float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\n const float kPi = 3.14159265358979;\n const float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\n //common func\n float getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n     // un-normalization\n     boundingSize = boundingSize * size;\n     point = point * size;\n     center = center * size;\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n float getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n     // un-normalization\n     boundingSize = boundingSize * size;\n     point = point * size;\n     center = center * size;\n\n     float cos_t = cos(ang);\n     float sin_t = sin(ang);\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n vec2 rotate2DPoint(vec2 point, float angle) {\n     return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n }\n\n //for eye part\n float eye_getLeftEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, leftEyeCenter, leftEyePlainSize, a1, a2);\n }\n float eye_getRightEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, rightEyeCenter, rightEyePlainSize, a1, a2);\n }\n vec2 eye_getScaledEyesPoint(vec2 originalPoint, vec2 scalingFactors,float scalingFactor,float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     vec2 eyesScaledPoint = originalPoint;\n     vec2 leftEyeScaledPoint = leftEyeCenter + scalingFactors * (originalPoint - leftEyeCenter);\n     eyesScaledPoint = mix(eyesScaledPoint, leftEyeScaledPoint, leftEyeMask);\n     vec2 rightEyeScaledPoint = rightEyeCenter + scalingFactors * (originalPoint - rightEyeCenter);\n     eyesScaledPoint = mix(eyesScaledPoint, rightEyeScaledPoint, rightEyeMask);\n     return mix(originalPoint, eyesScaledPoint, scalingFactor);\n }\n vec2 eye_getEyesDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return vec2(abs(kEyesDistanceXRatio * (leftEyeCenter - rightEyeCenter).x), 0.0);\n }\n vec2 eye_getEyesDistanceFactors2() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(leftEyeCenter.x - rightEyeCenter.x, leftEyeCenter.y - rightEyeCenter.y);\n }\n\n vec2 eye_getScaledEyesPoint2(vec2 originalPoint, float scalingFactor, float theta, float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     float sin_t2 = sin(theta);\n     float cos_t2 = cos(theta);\n     vec2 v = originalPoint - leftEyeCenter;\n     float d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * leftEyeMask * scalingFactor;\n     vec2 left = d * vec2(cos_t2, sin_t2);\n\n     v = originalPoint - rightEyeCenter;\n     d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * rightEyeMask * scalingFactor;\n     vec2 right = d * vec2(cos_t2, sin_t2);\n     return originalPoint+left+right;\n }\n\n vec2 getEyeDiff() {\n     //faceIndex;\n     float leftEyeFineMask     = eye_getLeftEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float rightEyeFineMask    = eye_getRightEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float leftEyeCoarseMask   = eye_getLeftEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     float rightEyeCoarseMask  = eye_getRightEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     vec2 displacedEyesPoint   = position.xy;\n     //textureCoordinate = vec2(leftEyeFineMask+rightEyeFineMask);\n     //gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     //return;\n     // width\n     vec2 kEyesWidthFactors = vec2(1.3*cos_t, -1.3*sin_t);\n     //vec3 kEyesWidthFactors = vec3(1.3, 1.0, 1.0);\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, eyesWidth, angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // height\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, eyesHeight, kPi/2.0 + angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // all size\n     const vec2 kEyesSizeFactors = vec2(1.4, 1.4);\n     displacedEyesPoint = eye_getScaledEyesPoint(displacedEyesPoint, kEyesSizeFactors, eyesSize, leftEyeFineMask, rightEyeFineMask);\n\n     // rotate\n     vec2 leftEye2DTiltPoint = leftEyeCenter + rotate2DPoint(displacedEyesPoint - leftEyeCenter, -eyesTiltAngle);\n     displacedEyesPoint = mix(displacedEyesPoint, leftEye2DTiltPoint, leftEyeCoarseMask);\n     vec2 rightEye2DTiltPoint = rightEyeCenter + rotate2DPoint(displacedEyesPoint - rightEyeCenter, eyesTiltAngle);\n     displacedEyesPoint = mix(displacedEyesPoint, rightEye2DTiltPoint, rightEyeCoarseMask);\n\n     // distance\n     vec2 eyesDistanceFactors = eye_getEyesDistanceFactors2();\n     vec2 leftEyeDistancePoint = displacedEyesPoint + eyesDistance * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, leftEyeDistancePoint, leftEyeCoarseMask);\n     vec2 rightEyeDistancePoint = displacedEyesPoint - eyesDistance * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, rightEyeDistancePoint, rightEyeCoarseMask);\n\n     vec2 diffPosition = displacedEyesPoint - position.xy;\n     return diffPosition;\n }\n\n float nose_getNoseMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, nose3DCenter, nosePlainSize, a1, a2);\n }\n float nose_getNoseTipFineMask() {\n     return getEllipseMask(vec2(2.0, 2.0), position.xy, noseTipCenter, noseTipPlaneSize, 0.4, 0.8);\n }\n float nose_getNoseTipCoarseMask() {\n     return getEllipseMask(vec2(1.0, 1.2), position.xy, noseBottomCenter, noseTipPlaneSize, 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisMask() {\n     return getEllipseMask(vec2(2.0, 1.0), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisFineMask() {\n     return getEllipseMask(vec2(2.5, 0.8), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n }\n float nose_getLipsMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, lipsCenter, lipsPlainSize, a1, a2);\n }\n\n vec2 nose_getScaledNosePoint(vec2 originalPoint, vec2 center, float scale) {\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n\n vec2 getNoseDiff() {\n     float noseNegativeRegionsMask = (1.0 - eye_getLeftEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - eye_getRightEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - nose_getLipsMask(vec2(1.8), 0.5, 1.0));\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.5), 0.5, 1.2) * noseNegativeRegionsMask;\n     float noseTipFineMask = nose_getNoseTipFineMask() * noseNegativeRegionsMask;\n     float noseTipCoarseMask = nose_getNoseTipCoarseMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisMask = nose_getNoseVerticalAxisMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisFineMask = nose_getNoseVerticalAxisFineMask() * noseNegativeRegionsMask;\n     vec2 displacedNosePoint = position.xy;\n\n     vec2 noseOutlineWidthPoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseOutlineWidthPoint, noseOutlineWidth * noseTipCoarseMask*(1.0-noseVertivalAxisFineMask));\n\n     vec2 noseBridgeWidthPoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseBridgeWidthPoint, noseBridgeWidth * noseVertivalAxisMask);\n\n     vec2 noseSizePoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseSizePoint, noseSize * noseMask);\n\n     const float kNoseLiftingYRatio = 0.05518821053;\n     vec2 noseLiftingVector = vec2(0.0, -kNoseLiftingYRatio * nosePlainSize.y);\n     noseLiftingVector = vec2(dot(noseLiftingVector, vec2(cos_t, -sin_t)), dot(noseLiftingVector, vec2(sin_t, cos_t)));\n     vec2 nosePositionPoint = displacedNosePoint + noseLiftingVector;\n     displacedNosePoint = mix(displacedNosePoint, nosePositionPoint, nosePosition * noseMask);\n\n     vec2 noseTipPoint = noseTipCenter + vec2(0.4) * (displacedNosePoint - noseTipCenter);\n     displacedNosePoint = mix(displacedNosePoint, noseTipPoint, noseTipSize * noseTipFineMask);\n\n     vec2 diffPosition = displacedNosePoint - position.xy;\n     return diffPosition;\n }\n vec2 lips_getScaledLipsPoint(in vec2 originalPoint, in vec2 scalingFactors, in float scalingCoefficient, in float lipsMask) {\n     if (scalingCoefficient == 0.0) {\n         return originalPoint;\n     }\n     vec2 lipsScaledPoint = lipsCenter + scalingFactors * (originalPoint - lipsCenter);\n     return mix(originalPoint, lipsScaledPoint, scalingCoefficient * lipsMask);\n }\n\n vec2 lips_getScaledLipsPoint2(vec2 originalPoint, vec2 center, float theta, float scale) {\n     float sin_t = sin(theta);\n     float cos_t = cos(theta);\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n vec2 lips_getTransformYFactors() {\n     const float kDistanceYRatio = 0.1;\n     return kDistanceYRatio * (nose3DCenter - lipsCenter) / 2.0;\n }\n float lips_face_getFaceMaskLeft2(vec2 point) {\n     return getEllipseMask2(vec2(1.0, 2.0), point, lipsProtectCenterLeft, lipsProtectSizeLeft, 0.8, 1.2, lipsProtectAngleLeft);\n }\n float lips_face_getFaceMaskRight2(vec2 point) {\n     return getEllipseMask2(vec2(1.0, 2.0), point, lipsProtectCenterRight, lipsProtectSizeRight, 0.8, 1.2, lipsProtectAngleRight);\n }\n float getTeethMask() {\n    const vec2 sigmaScaling = vec2(1.0, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, teethCenter.xy, teethPlainSize, 0.8, 1.0);\n }\n vec2 getLipsDiff() {\n     const float kScalingFactor = 1.3;\n     vec2 originalPosition = position.xy;\n     vec2 faceFrameCoords = originalPosition;\n     float teethRegionWeight = getTeethMask();\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.2), 0.8, 1.0);\n     float faceCoarseMaskLeft2   = lips_face_getFaceMaskLeft2(position.xy);\n     float faceCoarseMaskRight2   = lips_face_getFaceMaskRight2(position.xy);\n     float lipsNegativeMask = (1.0 - teethRegionWeight) * (1.0 - noseMask) * (1.0 - faceCoarseMaskLeft2) * (1.0 - faceCoarseMaskRight2);\n     float lipsMask = nose_getLipsMask(vec2(1.2, 1.2), 0.8, 1.1) * lipsNegativeMask;\n//     lipsMask = lips_face_getFaceMaskLeft2(position.xy) + lips_face_getFaceMaskRight2(position.xy);\n     float lipsMask1 = nose_getLipsMask(vec2(1.2, 1.1), 0.8, 0.9) * lipsNegativeMask;\n     float lipsMask2 = nose_getLipsMask(vec2(1.2, 0.8), 1.0, 1.2) * lipsNegativeMask;\n     vec2 displacedLipsPoint = position.xy;\n     const vec2 kLipsWidthFactors = vec2(kScalingFactor, 1.0);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, lipsCenter, angles.z, 0.3), lipsWidth * lipsMask1);\n\n     const vec2 kLipsHeightFactors = vec2(1.0, kScalingFactor);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, lipsCenter, kPi/2.0 + angles.z, 0.3), lipsHeight * lipsMask);\n\n     const vec2 kLipsSizeFactors = vec2(kScalingFactor, kScalingFactor);\n     displacedLipsPoint = lips_getScaledLipsPoint(displacedLipsPoint, kLipsSizeFactors, lipsSize, lipsMask);\n\n     vec2 lipsYFactors = lips_getTransformYFactors();\n     vec2 lipsTransformYPoint = displacedLipsPoint + lipsYFactors;\n     displacedLipsPoint = mix(displacedLipsPoint, lipsTransformYPoint, lipsYPosition * lipsMask2);\n\n     vec2 diffPosition = displacedLipsPoint - position.xy;\n     return diffPosition;\n }\n\n float brow_getLeftEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.7, 1.0);\n }\n\n float brow_getRightEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.7, 1.0);\n }\n\n float brow_getLeftEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.6, 1.0);\n }\n\n float brow_getRightEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.6, 1.0);\n }\n vec2 brow_getEyebrowDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(leftEyebrowCenter.x - rightEyebrowCenter.x, leftEyebrowCenter.y - rightEyebrowCenter.y);\n }\n vec2 brow_getEyebrowHeightFactors() {\n     const float kEyesDistanceXRatio = 0.14;\n     return kEyesDistanceXRatio * (leftEyebrowCenter + rightEyebrowCenter - leftEyeCenter - rightEyeCenter) / 2.0;\n }\n vec2 getEyebrowDiff() {\n     float _noseNegativeMask    = 1.0 - nose_getNoseMask(vec2(3.0, 0.9), 0.7, 0.9);\n     float _leftEyeNegativeMask = 1.0 - eye_getLeftEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float _rightEyeNegativeMask = 1.0 - eye_getRightEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float leftEyebrowMask   = brow_getLeftEyebrowMask() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask  = brow_getRightEyebrowMask() * _rightEyeNegativeMask * _noseNegativeMask;\n     float leftEyebrowMask2   = brow_getLeftEyebrowMask2() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask2  = brow_getRightEyebrowMask2() * _rightEyeNegativeMask * _noseNegativeMask;\n     vec2 displacedEyebrowPoint   = position.xy;\n\n     // rotate\n     vec2 leftEyebrow2DTiltPoint = leftEyebrowCenter + rotate2DPoint(displacedEyebrowPoint - leftEyebrowCenter, -eyebrowTiltAngle);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyebrow2DTiltPoint, leftEyebrowMask2);\n     vec2 rightEyebrow2DTiltPoint = rightEyebrowCenter + rotate2DPoint(displacedEyebrowPoint - rightEyebrowCenter, eyebrowTiltAngle);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrow2DTiltPoint, rightEyebrowMask2);\n\n     // distance\n     vec2 eyebrowDistanceFactors = brow_getEyebrowDistanceFactors();\n     vec2 leftEyeBrowDistancePoint = displacedEyebrowPoint + eyebrowDistance * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowDistancePoint, leftEyebrowMask);\n     vec2 rightEyebrowDistancePoint = displacedEyebrowPoint - eyebrowDistance * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowDistancePoint, rightEyebrowMask);\n\n     vec2 eyebrowHeightFactors = brow_getEyebrowHeightFactors();\n     vec2 leftEyeBrowHeightPoint = displacedEyebrowPoint + eyebrowHeight * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowHeightPoint, leftEyebrowMask);\n     vec2 rightEyebrowHeightPoint = displacedEyebrowPoint + eyebrowHeight * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowHeightPoint, rightEyebrowMask);\n\n     vec2 diffPosition = displacedEyebrowPoint - position.xy;\n     return diffPosition;\n }\n\n void main(){\n     vec2 diffPosition = getEyeDiff() + getNoseDiff() + getLipsDiff() + getEyebrowDiff();\n\n     textureCoordinate = diffPosition + position.xy;\n     gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n }";
  private static final String VERTEX_SHADER_VTF = " precision highp float;\n\nattribute vec4 position;\n\n //common\n uniform float sin_t;\n uniform float cos_t;\n uniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\n uniform vec2 size;\n varying vec2 textureCoordinate;\n\n //eye\n uniform vec2 leftEyePlainSize;\n uniform vec2 leftEyeCenter;\n uniform vec2 rightEyePlainSize;\n uniform vec2 rightEyeCenter;\n uniform float eyesSize; // it is eye size adjust factor\n uniform float eyesWidth; // it is eye width adjust factor\n uniform float eyesHeight; // it is eye height adjust factor\n uniform float eyesTiltAngle; // rotate angle need to apply\n uniform float eyesDistance;\n\n //nose\n uniform vec2 nose3DCenter;\n uniform vec2 nosePlainSize;\n uniform vec2 noseTipCenter;\n uniform vec2 noseTipPlaneSize;\n uniform vec2 noseBottomCenter;\n uniform float noseSize;\n uniform float noseOutlineWidth;\n uniform float noseBridgeWidth;\n uniform float nosePosition;\n uniform float noseTipSize;\n\n //teeth\n uniform vec2 teethPlainSize;\n uniform vec2 teethCenter;\n\n //lips\n uniform vec2 lipsCenter;\n uniform vec2 lipsPlainSize;\n uniform float lipsSize;\n uniform float lipsWidth;\n uniform float lipsHeight;\n uniform float lipsYPosition;\n uniform vec2 lipsProtectSizeLeft;\n uniform vec2 lipsProtectCenterLeft;\n uniform float lipsProtectAngleLeft;\n uniform vec2 lipsProtectSizeRight;\n uniform vec2 lipsProtectCenterRight;\n uniform float lipsProtectAngleRight;\n\n //eye brow\n uniform vec2 leftEyebrowPlainSize;\n uniform vec2 leftEyebrowCenter;\n uniform vec2 rightEyebrowPlainSize;\n uniform vec2 rightEyebrowCenter;\n uniform float eyebrowHeight; // eyebrow height adjust factor\n uniform float eyebrowDistance;\n uniform float eyebrowTiltAngle; // rotate angle need to apply\n\n uniform sampler2D inputImageTexture;\n\n const float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\n const float kPi = 3.14159265358979;\n const float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\n //common func\n float getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n     // un-normalization\n     boundingSize = boundingSize * size;\n     point = point * size;\n     center = center * size;\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n float getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n     // un-normalization\n     boundingSize = boundingSize * size;\n     point = point * size;\n     center = center * size;\n\n     float cos_t = cos(ang);\n     float sin_t = sin(ang);\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n vec2 rotate2DPoint(vec2 point, float angle) {\n     return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n }\n\n //for eye part\n float eye_getLeftEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, leftEyeCenter, leftEyePlainSize, a1, a2);\n }\n float eye_getRightEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, rightEyeCenter, rightEyePlainSize, a1, a2);\n }\n vec2 eye_getScaledEyesPoint(vec2 originalPoint, vec2 scalingFactors,float scalingFactor,float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     vec2 eyesScaledPoint = originalPoint;\n     vec2 leftEyeScaledPoint = leftEyeCenter + scalingFactors * (originalPoint - leftEyeCenter);\n     eyesScaledPoint = mix(eyesScaledPoint, leftEyeScaledPoint, leftEyeMask);\n     vec2 rightEyeScaledPoint = rightEyeCenter + scalingFactors * (originalPoint - rightEyeCenter);\n     eyesScaledPoint = mix(eyesScaledPoint, rightEyeScaledPoint, rightEyeMask);\n     return mix(originalPoint, eyesScaledPoint, scalingFactor);\n }\n vec2 eye_getEyesDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return vec2(abs(kEyesDistanceXRatio * (leftEyeCenter - rightEyeCenter).x), 0.0);\n }\n vec2 eye_getEyesDistanceFactors2() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(leftEyeCenter.x - rightEyeCenter.x, leftEyeCenter.y - rightEyeCenter.y);\n }\n\n vec2 eye_getScaledEyesPoint2(vec2 originalPoint, float scalingFactor, float theta, float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     float sin_t2 = sin(theta);\n     float cos_t2 = cos(theta);\n     vec2 v = originalPoint - leftEyeCenter;\n     float d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * leftEyeMask * scalingFactor;\n     vec2 left = d * vec2(cos_t2, sin_t2);\n\n     v = originalPoint - rightEyeCenter;\n     d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * rightEyeMask * scalingFactor;\n     vec2 right = d * vec2(cos_t2, sin_t2);\n     return originalPoint+left+right;\n }\n\n vec2 getEyeDiff() {\n     //faceIndex;\n     float leftEyeFineMask     = eye_getLeftEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float rightEyeFineMask    = eye_getRightEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float leftEyeCoarseMask   = eye_getLeftEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     float rightEyeCoarseMask  = eye_getRightEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     vec2 displacedEyesPoint   = position.xy;\n     //textureCoordinate = vec2(leftEyeFineMask+rightEyeFineMask);\n     //gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     //return;\n     // width\n     vec2 kEyesWidthFactors = vec2(1.3*cos_t, -1.3*sin_t);\n     //vec3 kEyesWidthFactors = vec3(1.3, 1.0, 1.0);\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, eyesWidth, angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // height\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, eyesHeight, kPi/2.0 + angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // all size\n     const vec2 kEyesSizeFactors = vec2(1.4, 1.4);\n     displacedEyesPoint = eye_getScaledEyesPoint(displacedEyesPoint, kEyesSizeFactors, eyesSize, leftEyeFineMask, rightEyeFineMask);\n\n     // rotate\n     vec2 leftEye2DTiltPoint = leftEyeCenter + rotate2DPoint(displacedEyesPoint - leftEyeCenter, -eyesTiltAngle);\n     displacedEyesPoint = mix(displacedEyesPoint, leftEye2DTiltPoint, leftEyeCoarseMask);\n     vec2 rightEye2DTiltPoint = rightEyeCenter + rotate2DPoint(displacedEyesPoint - rightEyeCenter, eyesTiltAngle);\n     displacedEyesPoint = mix(displacedEyesPoint, rightEye2DTiltPoint, rightEyeCoarseMask);\n\n     // distance\n     vec2 eyesDistanceFactors = eye_getEyesDistanceFactors2();\n     vec2 leftEyeDistancePoint = displacedEyesPoint + eyesDistance * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, leftEyeDistancePoint, leftEyeCoarseMask);\n     vec2 rightEyeDistancePoint = displacedEyesPoint - eyesDistance * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, rightEyeDistancePoint, rightEyeCoarseMask);\n\n     vec2 diffPosition = displacedEyesPoint - position.xy;\n     return diffPosition;\n }\n\n float nose_getNoseMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, nose3DCenter, nosePlainSize, a1, a2);\n }\n float nose_getNoseTipFineMask() {\n     return getEllipseMask(vec2(2.0, 2.0), position.xy, noseTipCenter, noseTipPlaneSize, 0.4, 0.8);\n }\n float nose_getNoseTipCoarseMask() {\n     return getEllipseMask(vec2(1.0, 1.2), position.xy, noseBottomCenter, noseTipPlaneSize, 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisMask() {\n     return getEllipseMask(vec2(2.0, 1.0), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisFineMask() {\n     return getEllipseMask(vec2(2.5, 0.8), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n }\n float nose_getLipsMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, lipsCenter, lipsPlainSize, a1, a2);\n }\n\n vec2 nose_getScaledNosePoint(vec2 originalPoint, vec2 center, float scale) {\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n\n vec2 getNoseDiff() {\n     float noseNegativeRegionsMask = (1.0 - eye_getLeftEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - eye_getRightEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - nose_getLipsMask(vec2(1.8), 0.5, 1.0));\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.5), 0.5, 1.2) * noseNegativeRegionsMask;\n     float noseTipFineMask = nose_getNoseTipFineMask() * noseNegativeRegionsMask;\n     float noseTipCoarseMask = nose_getNoseTipCoarseMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisMask = nose_getNoseVerticalAxisMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisFineMask = nose_getNoseVerticalAxisFineMask() * noseNegativeRegionsMask;\n     vec2 displacedNosePoint = position.xy;\n\n     vec2 noseOutlineWidthPoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseOutlineWidthPoint, noseOutlineWidth * noseTipCoarseMask*(1.0-noseVertivalAxisFineMask));\n\n     vec2 noseBridgeWidthPoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseBridgeWidthPoint, noseBridgeWidth * noseVertivalAxisMask);\n\n     vec2 noseSizePoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseSizePoint, noseSize * noseMask);\n\n     const float kNoseLiftingYRatio = 0.05518821053;\n     vec2 noseLiftingVector = vec2(0.0, -kNoseLiftingYRatio * nosePlainSize.y);\n     noseLiftingVector = vec2(dot(noseLiftingVector, vec2(cos_t, -sin_t)), dot(noseLiftingVector, vec2(sin_t, cos_t)));\n     vec2 nosePositionPoint = displacedNosePoint + noseLiftingVector;\n     displacedNosePoint = mix(displacedNosePoint, nosePositionPoint, nosePosition * noseMask);\n\n     vec2 noseTipPoint = noseTipCenter + vec2(0.4) * (displacedNosePoint - noseTipCenter);\n     displacedNosePoint = mix(displacedNosePoint, noseTipPoint, noseTipSize * noseTipFineMask);\n\n     vec2 diffPosition = displacedNosePoint - position.xy;\n     return diffPosition;\n }\n vec2 lips_getScaledLipsPoint(in vec2 originalPoint, in vec2 scalingFactors, in float scalingCoefficient, in float lipsMask) {\n     if (scalingCoefficient == 0.0) {\n         return originalPoint;\n     }\n     vec2 lipsScaledPoint = lipsCenter + scalingFactors * (originalPoint - lipsCenter);\n     return mix(originalPoint, lipsScaledPoint, scalingCoefficient * lipsMask);\n }\n\n vec2 lips_getScaledLipsPoint2(vec2 originalPoint, vec2 center, float theta, float scale) {\n     float sin_t = sin(theta);\n     float cos_t = cos(theta);\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n vec2 lips_getTransformYFactors() {\n     const float kDistanceYRatio = 0.1;\n     return kDistanceYRatio * (nose3DCenter - lipsCenter) / 2.0;\n }\n float lips_face_getFaceMaskLeft2(vec2 point) {\n     return getEllipseMask2(vec2(1.0, 2.0), point, lipsProtectCenterLeft, lipsProtectSizeLeft, 0.8, 1.2, lipsProtectAngleLeft);\n }\n float lips_face_getFaceMaskRight2(vec2 point) {\n     return getEllipseMask2(vec2(1.0, 2.0), point, lipsProtectCenterRight, lipsProtectSizeRight, 0.8, 1.2, lipsProtectAngleRight);\n }\n float getTeethMask() {\n    const vec2 sigmaScaling = vec2(1.0, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, teethCenter.xy, teethPlainSize, 0.8, 1.0);\n }\n vec2 getLipsDiff() {\n     const float kScalingFactor = 1.3;\n     vec2 originalPosition = position.xy;\n     vec2 faceFrameCoords = originalPosition;\n     float teethRegionWeight = getTeethMask();\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.2), 0.8, 1.0);\n     float faceCoarseMaskLeft2   = lips_face_getFaceMaskLeft2(position.xy);\n     float faceCoarseMaskRight2   = lips_face_getFaceMaskRight2(position.xy);\n     float lipsNegativeMask = (1.0 - teethRegionWeight) * (1.0 - noseMask) * (1.0 - faceCoarseMaskLeft2) * (1.0 - faceCoarseMaskRight2);\n     float lipsMask = nose_getLipsMask(vec2(1.2, 1.2), 0.8, 1.1) * lipsNegativeMask;\n//     lipsMask = lips_face_getFaceMaskLeft2(position.xy) + lips_face_getFaceMaskRight2(position.xy);\n     float lipsMask1 = nose_getLipsMask(vec2(1.2, 1.1), 0.8, 0.9) * lipsNegativeMask;\n     float lipsMask2 = nose_getLipsMask(vec2(1.2, 0.8), 1.0, 1.2) * lipsNegativeMask;\n     vec2 displacedLipsPoint = position.xy;\n     const vec2 kLipsWidthFactors = vec2(kScalingFactor, 1.0);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, lipsCenter, angles.z, 0.3), lipsWidth * lipsMask1);\n\n     const vec2 kLipsHeightFactors = vec2(1.0, kScalingFactor);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, lipsCenter, kPi/2.0 + angles.z, 0.3), lipsHeight * lipsMask);\n\n     const vec2 kLipsSizeFactors = vec2(kScalingFactor, kScalingFactor);\n     displacedLipsPoint = lips_getScaledLipsPoint(displacedLipsPoint, kLipsSizeFactors, lipsSize, lipsMask);\n\n     vec2 lipsYFactors = lips_getTransformYFactors();\n     vec2 lipsTransformYPoint = displacedLipsPoint + lipsYFactors;\n     displacedLipsPoint = mix(displacedLipsPoint, lipsTransformYPoint, lipsYPosition * lipsMask2);\n\n     vec2 diffPosition = displacedLipsPoint - position.xy;\n     return diffPosition;\n }\n\n float brow_getLeftEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.7, 1.0);\n }\n\n float brow_getRightEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.7, 1.0);\n }\n\n float brow_getLeftEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.6, 1.0);\n }\n\n float brow_getRightEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.6, 1.0);\n }\n vec2 brow_getEyebrowDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(leftEyebrowCenter.x - rightEyebrowCenter.x, leftEyebrowCenter.y - rightEyebrowCenter.y);\n }\n vec2 brow_getEyebrowHeightFactors() {\n     const float kEyesDistanceXRatio = 0.14;\n     return kEyesDistanceXRatio * (leftEyebrowCenter + rightEyebrowCenter - leftEyeCenter - rightEyeCenter) / 2.0;\n }\n vec2 getEyebrowDiff() {\n     float _noseNegativeMask    = 1.0 - nose_getNoseMask(vec2(3.0, 0.9), 0.7, 0.9);\n     float _leftEyeNegativeMask = 1.0 - eye_getLeftEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float _rightEyeNegativeMask = 1.0 - eye_getRightEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float leftEyebrowMask   = brow_getLeftEyebrowMask() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask  = brow_getRightEyebrowMask() * _rightEyeNegativeMask * _noseNegativeMask;\n     float leftEyebrowMask2   = brow_getLeftEyebrowMask2() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask2  = brow_getRightEyebrowMask2() * _rightEyeNegativeMask * _noseNegativeMask;\n     vec2 displacedEyebrowPoint   = position.xy;\n\n     // rotate\n     vec2 leftEyebrow2DTiltPoint = leftEyebrowCenter + rotate2DPoint(displacedEyebrowPoint - leftEyebrowCenter, -eyebrowTiltAngle);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyebrow2DTiltPoint, leftEyebrowMask2);\n     vec2 rightEyebrow2DTiltPoint = rightEyebrowCenter + rotate2DPoint(displacedEyebrowPoint - rightEyebrowCenter, eyebrowTiltAngle);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrow2DTiltPoint, rightEyebrowMask2);\n\n     // distance\n     vec2 eyebrowDistanceFactors = brow_getEyebrowDistanceFactors();\n     vec2 leftEyeBrowDistancePoint = displacedEyebrowPoint + eyebrowDistance * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowDistancePoint, leftEyebrowMask);\n     vec2 rightEyebrowDistancePoint = displacedEyebrowPoint - eyebrowDistance * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowDistancePoint, rightEyebrowMask);\n\n     vec2 eyebrowHeightFactors = brow_getEyebrowHeightFactors();\n     vec2 leftEyeBrowHeightPoint = displacedEyebrowPoint + eyebrowHeight * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowHeightPoint, leftEyebrowMask);\n     vec2 rightEyebrowHeightPoint = displacedEyebrowPoint + eyebrowHeight * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowHeightPoint, rightEyebrowMask);\n\n     vec2 diffPosition = displacedEyebrowPoint - position.xy;\n     return diffPosition;\n }\n\n void main(){\n     vec2 diffPosition = getEyeDiff() + getNoseDiff() + getLipsDiff() + getEyebrowDiff();\n     vec4 color = texture2D(inputImageTexture, position.xy);\n     vec2 offset = (color.xy * 255.0 + color.zw) / 127.5 - 1.0;\n     textureCoordinate = diffPosition + offset;\n\n     gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n }";
  private static final int XCOORD_NUM = 128;
  private static final int YCOORD_NUM = 128;
  private static float[] mFullscreenVerticesPortrait;
  private static float[] mInitTextureCoordinatesPortrait;
  private float[] angles = { 0.0F, 0.0F, 0.0F };
  private float eyebrowDistance = 1.0F;
  private float eyebrowHeight = 0.0F;
  private float eyebrowTiltAngle = 0.0F;
  private float eyesDistance = 1.0F;
  private float eyesHeight = 0.0F;
  private float eyesSize = 0.1F;
  private float eyesTiltAngle = 0.0F;
  private float eyesWidth = 0.0F;
  private float[] leftEyeCenter = { 0.0F, 0.0F };
  private float[] leftEyePlainSize = { 0.0F, 0.0F };
  private float[] leftEyebrowCenter = { 0.0F, 0.0F };
  private float[] leftEyebrowPlainSize = { 0.0F, 0.0F };
  private float[] lipsCenter = { 0.0F, 0.0F };
  private float lipsHeight = 0.0F;
  private float[] lipsPlainSize = { 0.0F, 0.0F };
  private float lipsProtectAngleLeft = 0.0F;
  private float lipsProtectAngleRight = 0.0F;
  private float[] lipsProtectCenterLeft = { 0.0F, 0.0F };
  private float[] lipsProtectCenterRight = { 0.0F, 0.0F };
  private float[] lipsProtectSizeLeft = { 0.0F, 0.0F };
  private float[] lipsProtectSizeRight = { 0.0F, 0.0F };
  private float lipsSize = 0.0F;
  private float lipsWidth = 0.0F;
  private float lipsYPosition = 0.0F;
  private float meshType = 0.0F;
  private float[] nose3DCenter = { 0.0F, 0.0F };
  private float[] noseBottomCenter = { 0.0F, 0.0F };
  private float noseBridgeWidth = 0.1F;
  private float noseOutlineWidth = 0.0F;
  private float[] nosePlainSize = { 0.0F, 0.0F };
  private float nosePosition = 0.0F;
  private float noseSize = 0.0F;
  private float[] noseTipCenter = { 0.0F, 0.0F };
  private float[] noseTipPlaneSize = { 0.0F, 0.0F };
  private float noseTipSize = 1.0F;
  private float[] rightEyeCenter = { 0.0F, 0.0F };
  private float[] rightEyePlainSize = { 0.0F, 0.0F };
  private float[] rightEyebrowCenter = { 0.0F, 0.0F };
  private float[] rightEyebrowPlainSize = { 0.0F, 0.0F };
  private float[] size = { 1.0F, 1.0F };
  
  public ReshapeEyeNoseLips(ReshapeType paramReshapeType)
  {
    super(BaseFilter.nativeDecrypt(" precision highp float;\n\nattribute vec4 position;\n\n //common\n uniform float sin_t;\n uniform float cos_t;\n uniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\n uniform vec2 size;\n varying vec2 textureCoordinate;\n\n //eye\n uniform vec2 leftEyePlainSize;\n uniform vec2 leftEyeCenter;\n uniform vec2 rightEyePlainSize;\n uniform vec2 rightEyeCenter;\n uniform float eyesSize; // it is eye size adjust factor\n uniform float eyesWidth; // it is eye width adjust factor\n uniform float eyesHeight; // it is eye height adjust factor\n uniform float eyesTiltAngle; // rotate angle need to apply\n uniform float eyesDistance;\n\n //nose\n uniform vec2 nose3DCenter;\n uniform vec2 nosePlainSize;\n uniform vec2 noseTipCenter;\n uniform vec2 noseTipPlaneSize;\n uniform vec2 noseBottomCenter;\n uniform float noseSize;\n uniform float noseOutlineWidth;\n uniform float noseBridgeWidth;\n uniform float nosePosition;\n uniform float noseTipSize;\n\n //teeth\n uniform vec2 teethPlainSize;\n uniform vec2 teethCenter;\n\n //lips\n uniform vec2 lipsCenter;\n uniform vec2 lipsPlainSize;\n uniform float lipsSize;\n uniform float lipsWidth;\n uniform float lipsHeight;\n uniform float lipsYPosition;\n uniform vec2 lipsProtectSizeLeft;\n uniform vec2 lipsProtectCenterLeft;\n uniform float lipsProtectAngleLeft;\n uniform vec2 lipsProtectSizeRight;\n uniform vec2 lipsProtectCenterRight;\n uniform float lipsProtectAngleRight;\n\n //eye brow\n uniform vec2 leftEyebrowPlainSize;\n uniform vec2 leftEyebrowCenter;\n uniform vec2 rightEyebrowPlainSize;\n uniform vec2 rightEyebrowCenter;\n uniform float eyebrowHeight; // eyebrow height adjust factor\n uniform float eyebrowDistance;\n uniform float eyebrowTiltAngle; // rotate angle need to apply\n\n uniform sampler2D inputImageTexture;\n\n const float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\n const float kPi = 3.14159265358979;\n const float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\n //common func\n float getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n     // un-normalization\n     boundingSize = boundingSize * size;\n     point = point * size;\n     center = center * size;\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n float getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n     // un-normalization\n     boundingSize = boundingSize * size;\n     point = point * size;\n     center = center * size;\n\n     float cos_t = cos(ang);\n     float sin_t = sin(ang);\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n vec2 rotate2DPoint(vec2 point, float angle) {\n     return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n }\n\n //for eye part\n float eye_getLeftEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, leftEyeCenter, leftEyePlainSize, a1, a2);\n }\n float eye_getRightEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, rightEyeCenter, rightEyePlainSize, a1, a2);\n }\n vec2 eye_getScaledEyesPoint(vec2 originalPoint, vec2 scalingFactors,float scalingFactor,float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     vec2 eyesScaledPoint = originalPoint;\n     vec2 leftEyeScaledPoint = leftEyeCenter + scalingFactors * (originalPoint - leftEyeCenter);\n     eyesScaledPoint = mix(eyesScaledPoint, leftEyeScaledPoint, leftEyeMask);\n     vec2 rightEyeScaledPoint = rightEyeCenter + scalingFactors * (originalPoint - rightEyeCenter);\n     eyesScaledPoint = mix(eyesScaledPoint, rightEyeScaledPoint, rightEyeMask);\n     return mix(originalPoint, eyesScaledPoint, scalingFactor);\n }\n vec2 eye_getEyesDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return vec2(abs(kEyesDistanceXRatio * (leftEyeCenter - rightEyeCenter).x), 0.0);\n }\n vec2 eye_getEyesDistanceFactors2() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(leftEyeCenter.x - rightEyeCenter.x, leftEyeCenter.y - rightEyeCenter.y);\n }\n\n vec2 eye_getScaledEyesPoint2(vec2 originalPoint, float scalingFactor, float theta, float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     float sin_t2 = sin(theta);\n     float cos_t2 = cos(theta);\n     vec2 v = originalPoint - leftEyeCenter;\n     float d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * leftEyeMask * scalingFactor;\n     vec2 left = d * vec2(cos_t2, sin_t2);\n\n     v = originalPoint - rightEyeCenter;\n     d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * rightEyeMask * scalingFactor;\n     vec2 right = d * vec2(cos_t2, sin_t2);\n     return originalPoint+left+right;\n }\n\n vec2 getEyeDiff() {\n     //faceIndex;\n     float leftEyeFineMask     = eye_getLeftEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float rightEyeFineMask    = eye_getRightEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float leftEyeCoarseMask   = eye_getLeftEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     float rightEyeCoarseMask  = eye_getRightEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     vec2 displacedEyesPoint   = position.xy;\n     //textureCoordinate = vec2(leftEyeFineMask+rightEyeFineMask);\n     //gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     //return;\n     // width\n     vec2 kEyesWidthFactors = vec2(1.3*cos_t, -1.3*sin_t);\n     //vec3 kEyesWidthFactors = vec3(1.3, 1.0, 1.0);\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, eyesWidth, angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // height\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, eyesHeight, kPi/2.0 + angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // all size\n     const vec2 kEyesSizeFactors = vec2(1.4, 1.4);\n     displacedEyesPoint = eye_getScaledEyesPoint(displacedEyesPoint, kEyesSizeFactors, eyesSize, leftEyeFineMask, rightEyeFineMask);\n\n     // rotate\n     vec2 leftEye2DTiltPoint = leftEyeCenter + rotate2DPoint(displacedEyesPoint - leftEyeCenter, -eyesTiltAngle);\n     displacedEyesPoint = mix(displacedEyesPoint, leftEye2DTiltPoint, leftEyeCoarseMask);\n     vec2 rightEye2DTiltPoint = rightEyeCenter + rotate2DPoint(displacedEyesPoint - rightEyeCenter, eyesTiltAngle);\n     displacedEyesPoint = mix(displacedEyesPoint, rightEye2DTiltPoint, rightEyeCoarseMask);\n\n     // distance\n     vec2 eyesDistanceFactors = eye_getEyesDistanceFactors2();\n     vec2 leftEyeDistancePoint = displacedEyesPoint + eyesDistance * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, leftEyeDistancePoint, leftEyeCoarseMask);\n     vec2 rightEyeDistancePoint = displacedEyesPoint - eyesDistance * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, rightEyeDistancePoint, rightEyeCoarseMask);\n\n     vec2 diffPosition = displacedEyesPoint - position.xy;\n     return diffPosition;\n }\n\n float nose_getNoseMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, nose3DCenter, nosePlainSize, a1, a2);\n }\n float nose_getNoseTipFineMask() {\n     return getEllipseMask(vec2(2.0, 2.0), position.xy, noseTipCenter, noseTipPlaneSize, 0.4, 0.8);\n }\n float nose_getNoseTipCoarseMask() {\n     return getEllipseMask(vec2(1.0, 1.2), position.xy, noseBottomCenter, noseTipPlaneSize, 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisMask() {\n     return getEllipseMask(vec2(2.0, 1.0), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisFineMask() {\n     return getEllipseMask(vec2(2.5, 0.8), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n }\n float nose_getLipsMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, lipsCenter, lipsPlainSize, a1, a2);\n }\n\n vec2 nose_getScaledNosePoint(vec2 originalPoint, vec2 center, float scale) {\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n\n vec2 getNoseDiff() {\n     float noseNegativeRegionsMask = (1.0 - eye_getLeftEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - eye_getRightEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - nose_getLipsMask(vec2(1.8), 0.5, 1.0));\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.5), 0.5, 1.2) * noseNegativeRegionsMask;\n     float noseTipFineMask = nose_getNoseTipFineMask() * noseNegativeRegionsMask;\n     float noseTipCoarseMask = nose_getNoseTipCoarseMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisMask = nose_getNoseVerticalAxisMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisFineMask = nose_getNoseVerticalAxisFineMask() * noseNegativeRegionsMask;\n     vec2 displacedNosePoint = position.xy;\n\n     vec2 noseOutlineWidthPoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseOutlineWidthPoint, noseOutlineWidth * noseTipCoarseMask*(1.0-noseVertivalAxisFineMask));\n\n     vec2 noseBridgeWidthPoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseBridgeWidthPoint, noseBridgeWidth * noseVertivalAxisMask);\n\n     vec2 noseSizePoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseSizePoint, noseSize * noseMask);\n\n     const float kNoseLiftingYRatio = 0.05518821053;\n     vec2 noseLiftingVector = vec2(0.0, -kNoseLiftingYRatio * nosePlainSize.y);\n     noseLiftingVector = vec2(dot(noseLiftingVector, vec2(cos_t, -sin_t)), dot(noseLiftingVector, vec2(sin_t, cos_t)));\n     vec2 nosePositionPoint = displacedNosePoint + noseLiftingVector;\n     displacedNosePoint = mix(displacedNosePoint, nosePositionPoint, nosePosition * noseMask);\n\n     vec2 noseTipPoint = noseTipCenter + vec2(0.4) * (displacedNosePoint - noseTipCenter);\n     displacedNosePoint = mix(displacedNosePoint, noseTipPoint, noseTipSize * noseTipFineMask);\n\n     vec2 diffPosition = displacedNosePoint - position.xy;\n     return diffPosition;\n }\n vec2 lips_getScaledLipsPoint(in vec2 originalPoint, in vec2 scalingFactors, in float scalingCoefficient, in float lipsMask) {\n     if (scalingCoefficient == 0.0) {\n         return originalPoint;\n     }\n     vec2 lipsScaledPoint = lipsCenter + scalingFactors * (originalPoint - lipsCenter);\n     return mix(originalPoint, lipsScaledPoint, scalingCoefficient * lipsMask);\n }\n\n vec2 lips_getScaledLipsPoint2(vec2 originalPoint, vec2 center, float theta, float scale) {\n     float sin_t = sin(theta);\n     float cos_t = cos(theta);\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n vec2 lips_getTransformYFactors() {\n     const float kDistanceYRatio = 0.1;\n     return kDistanceYRatio * (nose3DCenter - lipsCenter) / 2.0;\n }\n float lips_face_getFaceMaskLeft2(vec2 point) {\n     return getEllipseMask2(vec2(1.0, 2.0), point, lipsProtectCenterLeft, lipsProtectSizeLeft, 0.8, 1.2, lipsProtectAngleLeft);\n }\n float lips_face_getFaceMaskRight2(vec2 point) {\n     return getEllipseMask2(vec2(1.0, 2.0), point, lipsProtectCenterRight, lipsProtectSizeRight, 0.8, 1.2, lipsProtectAngleRight);\n }\n float getTeethMask() {\n    const vec2 sigmaScaling = vec2(1.0, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, teethCenter.xy, teethPlainSize, 0.8, 1.0);\n }\n vec2 getLipsDiff() {\n     const float kScalingFactor = 1.3;\n     vec2 originalPosition = position.xy;\n     vec2 faceFrameCoords = originalPosition;\n     float teethRegionWeight = getTeethMask();\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.2), 0.8, 1.0);\n     float faceCoarseMaskLeft2   = lips_face_getFaceMaskLeft2(position.xy);\n     float faceCoarseMaskRight2   = lips_face_getFaceMaskRight2(position.xy);\n     float lipsNegativeMask = (1.0 - teethRegionWeight) * (1.0 - noseMask) * (1.0 - faceCoarseMaskLeft2) * (1.0 - faceCoarseMaskRight2);\n     float lipsMask = nose_getLipsMask(vec2(1.2, 1.2), 0.8, 1.1) * lipsNegativeMask;\n//     lipsMask = lips_face_getFaceMaskLeft2(position.xy) + lips_face_getFaceMaskRight2(position.xy);\n     float lipsMask1 = nose_getLipsMask(vec2(1.2, 1.1), 0.8, 0.9) * lipsNegativeMask;\n     float lipsMask2 = nose_getLipsMask(vec2(1.2, 0.8), 1.0, 1.2) * lipsNegativeMask;\n     vec2 displacedLipsPoint = position.xy;\n     const vec2 kLipsWidthFactors = vec2(kScalingFactor, 1.0);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, lipsCenter, angles.z, 0.3), lipsWidth * lipsMask1);\n\n     const vec2 kLipsHeightFactors = vec2(1.0, kScalingFactor);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, lipsCenter, kPi/2.0 + angles.z, 0.3), lipsHeight * lipsMask);\n\n     const vec2 kLipsSizeFactors = vec2(kScalingFactor, kScalingFactor);\n     displacedLipsPoint = lips_getScaledLipsPoint(displacedLipsPoint, kLipsSizeFactors, lipsSize, lipsMask);\n\n     vec2 lipsYFactors = lips_getTransformYFactors();\n     vec2 lipsTransformYPoint = displacedLipsPoint + lipsYFactors;\n     displacedLipsPoint = mix(displacedLipsPoint, lipsTransformYPoint, lipsYPosition * lipsMask2);\n\n     vec2 diffPosition = displacedLipsPoint - position.xy;\n     return diffPosition;\n }\n\n float brow_getLeftEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.7, 1.0);\n }\n\n float brow_getRightEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.7, 1.0);\n }\n\n float brow_getLeftEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.6, 1.0);\n }\n\n float brow_getRightEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.6, 1.0);\n }\n vec2 brow_getEyebrowDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(leftEyebrowCenter.x - rightEyebrowCenter.x, leftEyebrowCenter.y - rightEyebrowCenter.y);\n }\n vec2 brow_getEyebrowHeightFactors() {\n     const float kEyesDistanceXRatio = 0.14;\n     return kEyesDistanceXRatio * (leftEyebrowCenter + rightEyebrowCenter - leftEyeCenter - rightEyeCenter) / 2.0;\n }\n vec2 getEyebrowDiff() {\n     float _noseNegativeMask    = 1.0 - nose_getNoseMask(vec2(3.0, 0.9), 0.7, 0.9);\n     float _leftEyeNegativeMask = 1.0 - eye_getLeftEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float _rightEyeNegativeMask = 1.0 - eye_getRightEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float leftEyebrowMask   = brow_getLeftEyebrowMask() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask  = brow_getRightEyebrowMask() * _rightEyeNegativeMask * _noseNegativeMask;\n     float leftEyebrowMask2   = brow_getLeftEyebrowMask2() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask2  = brow_getRightEyebrowMask2() * _rightEyeNegativeMask * _noseNegativeMask;\n     vec2 displacedEyebrowPoint   = position.xy;\n\n     // rotate\n     vec2 leftEyebrow2DTiltPoint = leftEyebrowCenter + rotate2DPoint(displacedEyebrowPoint - leftEyebrowCenter, -eyebrowTiltAngle);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyebrow2DTiltPoint, leftEyebrowMask2);\n     vec2 rightEyebrow2DTiltPoint = rightEyebrowCenter + rotate2DPoint(displacedEyebrowPoint - rightEyebrowCenter, eyebrowTiltAngle);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrow2DTiltPoint, rightEyebrowMask2);\n\n     // distance\n     vec2 eyebrowDistanceFactors = brow_getEyebrowDistanceFactors();\n     vec2 leftEyeBrowDistancePoint = displacedEyebrowPoint + eyebrowDistance * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowDistancePoint, leftEyebrowMask);\n     vec2 rightEyebrowDistancePoint = displacedEyebrowPoint - eyebrowDistance * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowDistancePoint, rightEyebrowMask);\n\n     vec2 eyebrowHeightFactors = brow_getEyebrowHeightFactors();\n     vec2 leftEyeBrowHeightPoint = displacedEyebrowPoint + eyebrowHeight * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowHeightPoint, leftEyebrowMask);\n     vec2 rightEyebrowHeightPoint = displacedEyebrowPoint + eyebrowHeight * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowHeightPoint, rightEyebrowMask);\n\n     vec2 diffPosition = displacedEyebrowPoint - position.xy;\n     return diffPosition;\n }\n\n void main(){\n     vec2 diffPosition = getEyeDiff() + getNoseDiff() + getLipsDiff() + getEyebrowDiff();\n\n     textureCoordinate = diffPosition + position.xy;\n     gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n }"), BaseFilter.nativeDecrypt("#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n    //gl_FragColor = vec4(inputTextureCoordinate.xy, vec2(0.0, 1.0));\n\n    //vec4 color = vec4(textureCoordinate.x*8.0+0.5, textureCoordinate.y*8.0+0.5, 0.5, 1.0);\n    //gl_FragColor = color;\n\n    //gl_FragColor = vec4(textureCoordinate, textureCoordinate.x, 1.0);\n\n    gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n}"));
    if (paramReshapeType == ReshapeType.VTF) {
      updateFilterShader(BaseFilter.nativeDecrypt(" precision highp float;\n\nattribute vec4 position;\n\n //common\n uniform float sin_t;\n uniform float cos_t;\n uniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\n uniform vec2 size;\n varying vec2 textureCoordinate;\n\n //eye\n uniform vec2 leftEyePlainSize;\n uniform vec2 leftEyeCenter;\n uniform vec2 rightEyePlainSize;\n uniform vec2 rightEyeCenter;\n uniform float eyesSize; // it is eye size adjust factor\n uniform float eyesWidth; // it is eye width adjust factor\n uniform float eyesHeight; // it is eye height adjust factor\n uniform float eyesTiltAngle; // rotate angle need to apply\n uniform float eyesDistance;\n\n //nose\n uniform vec2 nose3DCenter;\n uniform vec2 nosePlainSize;\n uniform vec2 noseTipCenter;\n uniform vec2 noseTipPlaneSize;\n uniform vec2 noseBottomCenter;\n uniform float noseSize;\n uniform float noseOutlineWidth;\n uniform float noseBridgeWidth;\n uniform float nosePosition;\n uniform float noseTipSize;\n\n //teeth\n uniform vec2 teethPlainSize;\n uniform vec2 teethCenter;\n\n //lips\n uniform vec2 lipsCenter;\n uniform vec2 lipsPlainSize;\n uniform float lipsSize;\n uniform float lipsWidth;\n uniform float lipsHeight;\n uniform float lipsYPosition;\n uniform vec2 lipsProtectSizeLeft;\n uniform vec2 lipsProtectCenterLeft;\n uniform float lipsProtectAngleLeft;\n uniform vec2 lipsProtectSizeRight;\n uniform vec2 lipsProtectCenterRight;\n uniform float lipsProtectAngleRight;\n\n //eye brow\n uniform vec2 leftEyebrowPlainSize;\n uniform vec2 leftEyebrowCenter;\n uniform vec2 rightEyebrowPlainSize;\n uniform vec2 rightEyebrowCenter;\n uniform float eyebrowHeight; // eyebrow height adjust factor\n uniform float eyebrowDistance;\n uniform float eyebrowTiltAngle; // rotate angle need to apply\n\n uniform sampler2D inputImageTexture;\n\n const float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\n const float kPi = 3.14159265358979;\n const float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\n //common func\n float getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n     // un-normalization\n     boundingSize = boundingSize * size;\n     point = point * size;\n     center = center * size;\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n float getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n     // un-normalization\n     boundingSize = boundingSize * size;\n     point = point * size;\n     center = center * size;\n\n     float cos_t = cos(ang);\n     float sin_t = sin(ang);\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n vec2 rotate2DPoint(vec2 point, float angle) {\n     return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n }\n\n //for eye part\n float eye_getLeftEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, leftEyeCenter, leftEyePlainSize, a1, a2);\n }\n float eye_getRightEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, rightEyeCenter, rightEyePlainSize, a1, a2);\n }\n vec2 eye_getScaledEyesPoint(vec2 originalPoint, vec2 scalingFactors,float scalingFactor,float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     vec2 eyesScaledPoint = originalPoint;\n     vec2 leftEyeScaledPoint = leftEyeCenter + scalingFactors * (originalPoint - leftEyeCenter);\n     eyesScaledPoint = mix(eyesScaledPoint, leftEyeScaledPoint, leftEyeMask);\n     vec2 rightEyeScaledPoint = rightEyeCenter + scalingFactors * (originalPoint - rightEyeCenter);\n     eyesScaledPoint = mix(eyesScaledPoint, rightEyeScaledPoint, rightEyeMask);\n     return mix(originalPoint, eyesScaledPoint, scalingFactor);\n }\n vec2 eye_getEyesDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return vec2(abs(kEyesDistanceXRatio * (leftEyeCenter - rightEyeCenter).x), 0.0);\n }\n vec2 eye_getEyesDistanceFactors2() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(leftEyeCenter.x - rightEyeCenter.x, leftEyeCenter.y - rightEyeCenter.y);\n }\n\n vec2 eye_getScaledEyesPoint2(vec2 originalPoint, float scalingFactor, float theta, float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     float sin_t2 = sin(theta);\n     float cos_t2 = cos(theta);\n     vec2 v = originalPoint - leftEyeCenter;\n     float d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * leftEyeMask * scalingFactor;\n     vec2 left = d * vec2(cos_t2, sin_t2);\n\n     v = originalPoint - rightEyeCenter;\n     d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * rightEyeMask * scalingFactor;\n     vec2 right = d * vec2(cos_t2, sin_t2);\n     return originalPoint+left+right;\n }\n\n vec2 getEyeDiff() {\n     //faceIndex;\n     float leftEyeFineMask     = eye_getLeftEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float rightEyeFineMask    = eye_getRightEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float leftEyeCoarseMask   = eye_getLeftEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     float rightEyeCoarseMask  = eye_getRightEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     vec2 displacedEyesPoint   = position.xy;\n     //textureCoordinate = vec2(leftEyeFineMask+rightEyeFineMask);\n     //gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     //return;\n     // width\n     vec2 kEyesWidthFactors = vec2(1.3*cos_t, -1.3*sin_t);\n     //vec3 kEyesWidthFactors = vec3(1.3, 1.0, 1.0);\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, eyesWidth, angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // height\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, eyesHeight, kPi/2.0 + angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // all size\n     const vec2 kEyesSizeFactors = vec2(1.4, 1.4);\n     displacedEyesPoint = eye_getScaledEyesPoint(displacedEyesPoint, kEyesSizeFactors, eyesSize, leftEyeFineMask, rightEyeFineMask);\n\n     // rotate\n     vec2 leftEye2DTiltPoint = leftEyeCenter + rotate2DPoint(displacedEyesPoint - leftEyeCenter, -eyesTiltAngle);\n     displacedEyesPoint = mix(displacedEyesPoint, leftEye2DTiltPoint, leftEyeCoarseMask);\n     vec2 rightEye2DTiltPoint = rightEyeCenter + rotate2DPoint(displacedEyesPoint - rightEyeCenter, eyesTiltAngle);\n     displacedEyesPoint = mix(displacedEyesPoint, rightEye2DTiltPoint, rightEyeCoarseMask);\n\n     // distance\n     vec2 eyesDistanceFactors = eye_getEyesDistanceFactors2();\n     vec2 leftEyeDistancePoint = displacedEyesPoint + eyesDistance * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, leftEyeDistancePoint, leftEyeCoarseMask);\n     vec2 rightEyeDistancePoint = displacedEyesPoint - eyesDistance * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, rightEyeDistancePoint, rightEyeCoarseMask);\n\n     vec2 diffPosition = displacedEyesPoint - position.xy;\n     return diffPosition;\n }\n\n float nose_getNoseMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, nose3DCenter, nosePlainSize, a1, a2);\n }\n float nose_getNoseTipFineMask() {\n     return getEllipseMask(vec2(2.0, 2.0), position.xy, noseTipCenter, noseTipPlaneSize, 0.4, 0.8);\n }\n float nose_getNoseTipCoarseMask() {\n     return getEllipseMask(vec2(1.0, 1.2), position.xy, noseBottomCenter, noseTipPlaneSize, 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisMask() {\n     return getEllipseMask(vec2(2.0, 1.0), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisFineMask() {\n     return getEllipseMask(vec2(2.5, 0.8), position.xy, nose3DCenter, nosePlainSize, 0.5, 1.2);\n }\n float nose_getLipsMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, position.xy, lipsCenter, lipsPlainSize, a1, a2);\n }\n\n vec2 nose_getScaledNosePoint(vec2 originalPoint, vec2 center, float scale) {\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n\n vec2 getNoseDiff() {\n     float noseNegativeRegionsMask = (1.0 - eye_getLeftEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - eye_getRightEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - nose_getLipsMask(vec2(1.8), 0.5, 1.0));\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.5), 0.5, 1.2) * noseNegativeRegionsMask;\n     float noseTipFineMask = nose_getNoseTipFineMask() * noseNegativeRegionsMask;\n     float noseTipCoarseMask = nose_getNoseTipCoarseMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisMask = nose_getNoseVerticalAxisMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisFineMask = nose_getNoseVerticalAxisFineMask() * noseNegativeRegionsMask;\n     vec2 displacedNosePoint = position.xy;\n\n     vec2 noseOutlineWidthPoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseOutlineWidthPoint, noseOutlineWidth * noseTipCoarseMask*(1.0-noseVertivalAxisFineMask));\n\n     vec2 noseBridgeWidthPoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseBridgeWidthPoint, noseBridgeWidth * noseVertivalAxisMask);\n\n     vec2 noseSizePoint = nose_getScaledNosePoint(displacedNosePoint, nose3DCenter, 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseSizePoint, noseSize * noseMask);\n\n     const float kNoseLiftingYRatio = 0.05518821053;\n     vec2 noseLiftingVector = vec2(0.0, -kNoseLiftingYRatio * nosePlainSize.y);\n     noseLiftingVector = vec2(dot(noseLiftingVector, vec2(cos_t, -sin_t)), dot(noseLiftingVector, vec2(sin_t, cos_t)));\n     vec2 nosePositionPoint = displacedNosePoint + noseLiftingVector;\n     displacedNosePoint = mix(displacedNosePoint, nosePositionPoint, nosePosition * noseMask);\n\n     vec2 noseTipPoint = noseTipCenter + vec2(0.4) * (displacedNosePoint - noseTipCenter);\n     displacedNosePoint = mix(displacedNosePoint, noseTipPoint, noseTipSize * noseTipFineMask);\n\n     vec2 diffPosition = displacedNosePoint - position.xy;\n     return diffPosition;\n }\n vec2 lips_getScaledLipsPoint(in vec2 originalPoint, in vec2 scalingFactors, in float scalingCoefficient, in float lipsMask) {\n     if (scalingCoefficient == 0.0) {\n         return originalPoint;\n     }\n     vec2 lipsScaledPoint = lipsCenter + scalingFactors * (originalPoint - lipsCenter);\n     return mix(originalPoint, lipsScaledPoint, scalingCoefficient * lipsMask);\n }\n\n vec2 lips_getScaledLipsPoint2(vec2 originalPoint, vec2 center, float theta, float scale) {\n     float sin_t = sin(theta);\n     float cos_t = cos(theta);\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n vec2 lips_getTransformYFactors() {\n     const float kDistanceYRatio = 0.1;\n     return kDistanceYRatio * (nose3DCenter - lipsCenter) / 2.0;\n }\n float lips_face_getFaceMaskLeft2(vec2 point) {\n     return getEllipseMask2(vec2(1.0, 2.0), point, lipsProtectCenterLeft, lipsProtectSizeLeft, 0.8, 1.2, lipsProtectAngleLeft);\n }\n float lips_face_getFaceMaskRight2(vec2 point) {\n     return getEllipseMask2(vec2(1.0, 2.0), point, lipsProtectCenterRight, lipsProtectSizeRight, 0.8, 1.2, lipsProtectAngleRight);\n }\n float getTeethMask() {\n    const vec2 sigmaScaling = vec2(1.0, 0.9);\n    return getEllipseMask(sigmaScaling, position.xy, teethCenter.xy, teethPlainSize, 0.8, 1.0);\n }\n vec2 getLipsDiff() {\n     const float kScalingFactor = 1.3;\n     vec2 originalPosition = position.xy;\n     vec2 faceFrameCoords = originalPosition;\n     float teethRegionWeight = getTeethMask();\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.2), 0.8, 1.0);\n     float faceCoarseMaskLeft2   = lips_face_getFaceMaskLeft2(position.xy);\n     float faceCoarseMaskRight2   = lips_face_getFaceMaskRight2(position.xy);\n     float lipsNegativeMask = (1.0 - teethRegionWeight) * (1.0 - noseMask) * (1.0 - faceCoarseMaskLeft2) * (1.0 - faceCoarseMaskRight2);\n     float lipsMask = nose_getLipsMask(vec2(1.2, 1.2), 0.8, 1.1) * lipsNegativeMask;\n//     lipsMask = lips_face_getFaceMaskLeft2(position.xy) + lips_face_getFaceMaskRight2(position.xy);\n     float lipsMask1 = nose_getLipsMask(vec2(1.2, 1.1), 0.8, 0.9) * lipsNegativeMask;\n     float lipsMask2 = nose_getLipsMask(vec2(1.2, 0.8), 1.0, 1.2) * lipsNegativeMask;\n     vec2 displacedLipsPoint = position.xy;\n     const vec2 kLipsWidthFactors = vec2(kScalingFactor, 1.0);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, lipsCenter, angles.z, 0.3), lipsWidth * lipsMask1);\n\n     const vec2 kLipsHeightFactors = vec2(1.0, kScalingFactor);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, lipsCenter, kPi/2.0 + angles.z, 0.3), lipsHeight * lipsMask);\n\n     const vec2 kLipsSizeFactors = vec2(kScalingFactor, kScalingFactor);\n     displacedLipsPoint = lips_getScaledLipsPoint(displacedLipsPoint, kLipsSizeFactors, lipsSize, lipsMask);\n\n     vec2 lipsYFactors = lips_getTransformYFactors();\n     vec2 lipsTransformYPoint = displacedLipsPoint + lipsYFactors;\n     displacedLipsPoint = mix(displacedLipsPoint, lipsTransformYPoint, lipsYPosition * lipsMask2);\n\n     vec2 diffPosition = displacedLipsPoint - position.xy;\n     return diffPosition;\n }\n\n float brow_getLeftEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.7, 1.0);\n }\n\n float brow_getRightEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.7, 1.0);\n }\n\n float brow_getLeftEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), position.xy, leftEyebrowCenter, leftEyebrowPlainSize, 0.6, 1.0);\n }\n\n float brow_getRightEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), position.xy, rightEyebrowCenter, rightEyebrowPlainSize, 0.6, 1.0);\n }\n vec2 brow_getEyebrowDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(leftEyebrowCenter.x - rightEyebrowCenter.x, leftEyebrowCenter.y - rightEyebrowCenter.y);\n }\n vec2 brow_getEyebrowHeightFactors() {\n     const float kEyesDistanceXRatio = 0.14;\n     return kEyesDistanceXRatio * (leftEyebrowCenter + rightEyebrowCenter - leftEyeCenter - rightEyeCenter) / 2.0;\n }\n vec2 getEyebrowDiff() {\n     float _noseNegativeMask    = 1.0 - nose_getNoseMask(vec2(3.0, 0.9), 0.7, 0.9);\n     float _leftEyeNegativeMask = 1.0 - eye_getLeftEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float _rightEyeNegativeMask = 1.0 - eye_getRightEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float leftEyebrowMask   = brow_getLeftEyebrowMask() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask  = brow_getRightEyebrowMask() * _rightEyeNegativeMask * _noseNegativeMask;\n     float leftEyebrowMask2   = brow_getLeftEyebrowMask2() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask2  = brow_getRightEyebrowMask2() * _rightEyeNegativeMask * _noseNegativeMask;\n     vec2 displacedEyebrowPoint   = position.xy;\n\n     // rotate\n     vec2 leftEyebrow2DTiltPoint = leftEyebrowCenter + rotate2DPoint(displacedEyebrowPoint - leftEyebrowCenter, -eyebrowTiltAngle);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyebrow2DTiltPoint, leftEyebrowMask2);\n     vec2 rightEyebrow2DTiltPoint = rightEyebrowCenter + rotate2DPoint(displacedEyebrowPoint - rightEyebrowCenter, eyebrowTiltAngle);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrow2DTiltPoint, rightEyebrowMask2);\n\n     // distance\n     vec2 eyebrowDistanceFactors = brow_getEyebrowDistanceFactors();\n     vec2 leftEyeBrowDistancePoint = displacedEyebrowPoint + eyebrowDistance * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowDistancePoint, leftEyebrowMask);\n     vec2 rightEyebrowDistancePoint = displacedEyebrowPoint - eyebrowDistance * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowDistancePoint, rightEyebrowMask);\n\n     vec2 eyebrowHeightFactors = brow_getEyebrowHeightFactors();\n     vec2 leftEyeBrowHeightPoint = displacedEyebrowPoint + eyebrowHeight * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowHeightPoint, leftEyebrowMask);\n     vec2 rightEyebrowHeightPoint = displacedEyebrowPoint + eyebrowHeight * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowHeightPoint, rightEyebrowMask);\n\n     vec2 diffPosition = displacedEyebrowPoint - position.xy;\n     return diffPosition;\n }\n\n void main(){\n     vec2 diffPosition = getEyeDiff() + getNoseDiff() + getLipsDiff() + getEyebrowDiff();\n     vec4 color = texture2D(inputImageTexture, position.xy);\n     vec2 offset = (color.xy * 255.0 + color.zw) / 127.5 - 1.0;\n     textureCoordinate = diffPosition + offset;\n\n     gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n }"), BaseFilter.nativeDecrypt("#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float; //支持高精度，限定浮点型为高精度\n#else\n    precision mediump float; //不支持高精度，限定浮点型为中精度\n#endif\n\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nvoid main()\n{\n\n    //vec2 diffPosition = textureCoordinate;\n    //float ddx = (diffPosition.x + 1.0) / 2.0;\n    //float ddy = (diffPosition.y + 1.0) / 2.0;\n    //diffPosition = vec2(ddx,ddy);\n    //vec2 a = fract(diffPosition * 255.0 / 256.0);\n    //vec2 b = fract(diffPosition * 255.0 * 255.0 / 256.0);\n    //gl_FragColor = vec4(a,b);\n\n    // 新版的 shader 颜色通道中记录的是位移偏移量，只有在最后 combinedFilter 才最终将所有 filter 的位移量叠加，去图上取点。这样的好处是：\n    // 1. 只有 128 * 128 个点\n    // 2. smoothstep 会更平滑，128 * 128 个点取插值，原来的处理方法会使像素点变模糊\n    // 3. 两个矩形交叠的地方，位移处理的先后顺序不影响结果（不能说这是好还是坏，因为 PS 的液化是作用在原图上的）\n\n    // 至于此处要改为 * 255 再 / 255 是为了提升精度（浮点纹理 iOS 不支持，而一个字节只能表示 256 个不同值）\n    // 本来小奇使用了浮点纹理，但是发现有机型不支持，不用浮点纹理又精度不够，所以采用这个方法，变成2个字节表示一个值，提升了精度。\n    vec2 diffPosition = textureCoordinate;\n    diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;  // 0.5 * (diffPosition + 1.0) 是将(-1, 1)间的值转换到(0, 1)，\n    vec2 a = floor(diffPosition) / 255.0;\n    vec2 b = fract(diffPosition);\n    gl_FragColor = vec4(a, b);\n\n\n    //vec2 diffPosition = textureCoordinate;\n    //diffPosition = 0.5 * (diffPosition + 1.0) * 256.0;\n    //vec2 a = floor(diffPosition) / 256.0;\n    //vec2 b = fract(diffPosition);\n    //gl_FragColor = vec4(a, b);\n}\n"));
    }
    if (paramReshapeType == ReshapeType.NORMAL) {
      f = 0.5F;
    }
    this.meshType = f;
    initParams();
  }
  
  public void ApplyGLSLFilter()
  {
    initParams();
    super.ApplyGLSLFilter();
    setDrawMode(AEOpenRenderConfig.DRAW_MODE.TRIANGLE_STRIP);
  }
  
  public void initAttribParams()
  {
    setPositions(mFullscreenVerticesPortrait, false);
    setTexCords(mInitTextureCoordinatesPortrait, false);
    setCoordNum(32897);
  }
  
  public void initParams()
  {
    addParam(new UniformParam.FloatsParam("leftEyePlainSize", this.leftEyePlainSize));
    addParam(new UniformParam.FloatsParam("leftEyeCenter", this.leftEyeCenter));
    addParam(new UniformParam.FloatsParam("rightEyePlainSize", this.rightEyePlainSize));
    addParam(new UniformParam.FloatsParam("rightEyeCenter", this.rightEyeCenter));
    addParam(new UniformParam.FloatsParam("leftEyebrowPlainSize", this.leftEyebrowPlainSize));
    addParam(new UniformParam.FloatsParam("leftEyebrowCenter", this.leftEyebrowCenter));
    addParam(new UniformParam.FloatsParam("rightEyebrowPlainSize", this.rightEyebrowPlainSize));
    addParam(new UniformParam.FloatsParam("rightEyebrowCenter", this.rightEyebrowCenter));
    addParam(new UniformParam.FloatsParam("nose3DCenter", this.nose3DCenter));
    addParam(new UniformParam.FloatsParam("nosePlainSize", this.nosePlainSize));
    addParam(new UniformParam.FloatsParam("noseTipCenter", this.noseTipCenter));
    addParam(new UniformParam.FloatsParam("noseTipPlaneSize", this.noseTipPlaneSize));
    addParam(new UniformParam.FloatsParam("noseBottomCenter", this.noseBottomCenter));
    addParam(new UniformParam.FloatsParam("lipsCenter", this.lipsCenter));
    addParam(new UniformParam.FloatsParam("lipsPlainSize", this.lipsPlainSize));
    addParam(new UniformParam.FloatsParam("lipsProtectSizeLeft", this.lipsProtectSizeLeft));
    addParam(new UniformParam.FloatsParam("lipsProtectCenterLeft", this.lipsProtectCenterLeft));
    addParam(new UniformParam.FloatParam("lipsProtectAngleLeft", this.lipsProtectAngleLeft));
    addParam(new UniformParam.FloatsParam("lipsProtectSizeRight", this.lipsProtectSizeRight));
    addParam(new UniformParam.FloatsParam("lipsProtectCenterRight", this.lipsProtectCenterRight));
    addParam(new UniformParam.FloatParam("lipsProtectAngleRight", this.lipsProtectAngleRight));
    addParam(new UniformParam.FloatParam("eyebrowHeight", this.eyebrowHeight));
    addParam(new UniformParam.FloatParam("eyebrowDistance", this.eyebrowDistance));
    addParam(new UniformParam.FloatParam("eyebrowTiltAngle", this.eyebrowTiltAngle));
    addParam(new UniformParam.FloatParam("eyesSize", this.eyesSize));
    addParam(new UniformParam.FloatParam("eyesWidth", this.eyesWidth));
    addParam(new UniformParam.FloatParam("eyesHeight", this.eyesHeight));
    addParam(new UniformParam.FloatParam("eyesTiltAngle", this.eyesTiltAngle));
    addParam(new UniformParam.FloatParam("eyesDistance", this.eyesDistance));
    addParam(new UniformParam.FloatParam("noseSize", this.noseSize));
    addParam(new UniformParam.FloatParam("noseOutlineWidth", this.noseOutlineWidth));
    addParam(new UniformParam.FloatParam("noseBridgeWidth", this.noseBridgeWidth));
    addParam(new UniformParam.FloatParam("nosePosition", this.nosePosition));
    addParam(new UniformParam.FloatParam("noseTipSize", this.noseTipSize));
    addParam(new UniformParam.FloatParam("lipsSize", this.lipsSize));
    addParam(new UniformParam.FloatParam("lipsWidth", this.lipsWidth));
    addParam(new UniformParam.FloatParam("lipsHeight", this.lipsHeight));
    addParam(new UniformParam.FloatParam("lipsYPosition", this.lipsYPosition));
    addParam(new UniformParam.FloatsParam("angles", this.angles));
    addParam(new UniformParam.FloatsParam("size", this.size));
    addParam(new UniformParam.FloatParam("meshType", this.meshType));
    float f = (float)Math.cos(this.angles[2]);
    addParam(new UniformParam.FloatParam("sin_t", (float)Math.sin(this.angles[2])));
    addParam(new UniformParam.FloatParam("cos_t", f));
  }
  
  public void setInitMesh(float[] paramArrayOfFloat1, float[] paramArrayOfFloat2)
  {
    mFullscreenVerticesPortrait = paramArrayOfFloat1;
    mInitTextureCoordinatesPortrait = paramArrayOfFloat2;
  }
  
  public void setParam(Map<String, Object> paramMap)
  {
    if (paramMap.containsKey("leftEyebrowPlainSize")) {
      this.leftEyebrowPlainSize = ((float[])paramMap.get("leftEyebrowPlainSize"));
    }
    if (paramMap.containsKey("leftEyebrowCenter")) {
      this.leftEyebrowCenter = ((float[])paramMap.get("leftEyebrowCenter"));
    }
    if (paramMap.containsKey("rightEyebrowPlainSize")) {
      this.rightEyebrowPlainSize = ((float[])paramMap.get("rightEyebrowPlainSize"));
    }
    if (paramMap.containsKey("rightEyebrowCenter")) {
      this.rightEyebrowCenter = ((float[])paramMap.get("rightEyebrowCenter"));
    }
    if (paramMap.containsKey("leftEyePlainSize")) {
      this.leftEyePlainSize = ((float[])paramMap.get("leftEyePlainSize"));
    }
    if (paramMap.containsKey("leftEyeCenter")) {
      this.leftEyeCenter = ((float[])paramMap.get("leftEyeCenter"));
    }
    if (paramMap.containsKey("rightEyePlainSize")) {
      this.rightEyePlainSize = ((float[])paramMap.get("rightEyePlainSize"));
    }
    if (paramMap.containsKey("rightEyeCenter")) {
      this.rightEyeCenter = ((float[])paramMap.get("rightEyeCenter"));
    }
    if (paramMap.containsKey("nose3DCenter")) {
      this.nose3DCenter = ((float[])paramMap.get("nose3DCenter"));
    }
    if (paramMap.containsKey("nosePlainSize")) {
      this.nosePlainSize = ((float[])paramMap.get("nosePlainSize"));
    }
    if (paramMap.containsKey("noseTipCenter")) {
      this.noseTipCenter = ((float[])paramMap.get("noseTipCenter"));
    }
    if (paramMap.containsKey("noseTipPlaneSize")) {
      this.noseTipPlaneSize = ((float[])paramMap.get("noseTipPlaneSize"));
    }
    if (paramMap.containsKey("noseBottomCenter")) {
      this.noseBottomCenter = ((float[])paramMap.get("noseBottomCenter"));
    }
    if (paramMap.containsKey("lipsCenter")) {
      this.lipsCenter = ((float[])paramMap.get("lipsCenter"));
    }
    if (paramMap.containsKey("lipsPlainSize")) {
      this.lipsPlainSize = ((float[])paramMap.get("lipsPlainSize"));
    }
    if (paramMap.containsKey("lipsProtectSizeLeft")) {
      this.lipsProtectSizeLeft = ((float[])paramMap.get("lipsProtectSizeLeft"));
    }
    if (paramMap.containsKey("lipsProtectCenterLeft")) {
      this.lipsProtectCenterLeft = ((float[])paramMap.get("lipsProtectCenterLeft"));
    }
    if (paramMap.containsKey("lipsProtectAngleLeft")) {
      this.lipsProtectAngleLeft = ((Float)paramMap.get("lipsProtectAngleLeft")).floatValue();
    }
    if (paramMap.containsKey("lipsProtectSizeRight")) {
      this.lipsProtectSizeRight = ((float[])paramMap.get("lipsProtectSizeRight"));
    }
    if (paramMap.containsKey("lipsProtectCenterRight")) {
      this.lipsProtectCenterRight = ((float[])paramMap.get("lipsProtectCenterRight"));
    }
    if (paramMap.containsKey("lipsProtectAngleRight")) {
      this.lipsProtectAngleRight = ((Float)paramMap.get("lipsProtectAngleRight")).floatValue();
    }
    if (paramMap.containsKey("eyebrowHeight")) {
      this.eyebrowHeight = (((Float)paramMap.get("eyebrowHeight")).floatValue() * 0.006F);
    }
    if (paramMap.containsKey("eyebrowDistance")) {
      this.eyebrowDistance = (((Float)paramMap.get("eyebrowDistance")).floatValue() * 0.009F);
    }
    if (paramMap.containsKey("eyebrowAngle")) {
      this.eyebrowTiltAngle = (((Float)paramMap.get("eyebrowAngle")).floatValue() * 0.0017F);
    }
    if (paramMap.containsKey("eyesWidth")) {
      this.eyesWidth = (((Float)paramMap.get("eyesWidth")).floatValue() * -0.003F);
    }
    if (paramMap.containsKey("eyesHeight")) {
      this.eyesHeight = (((Float)paramMap.get("eyesHeight")).floatValue() * -0.004F);
    }
    if (paramMap.containsKey("eyesSize")) {
      this.eyesSize = (((Float)paramMap.get("eyesSize")).floatValue() * -0.0032F);
    }
    if (paramMap.containsKey("eyesTiltAngle")) {
      this.eyesTiltAngle = (((Float)paramMap.get("eyesTiltAngle")).floatValue() * 0.001F);
    }
    if (paramMap.containsKey("eyesDistance")) {
      this.eyesDistance = (((Float)paramMap.get("eyesDistance")).floatValue() * 0.016F);
    }
    if (paramMap.containsKey("noseSize")) {
      this.noseSize = (((Float)paramMap.get("noseSize")).floatValue() * 0.006F);
    }
    if (paramMap.containsKey("noseOutlineWidth")) {
      this.noseOutlineWidth = (((Float)paramMap.get("noseOutlineWidth")).floatValue() * 0.01F);
    }
    if (paramMap.containsKey("noseBridgeWidth")) {
      this.noseBridgeWidth = (((Float)paramMap.get("noseBridgeWidth")).floatValue() * 0.008F);
    }
    if (paramMap.containsKey("nosePosition")) {
      this.nosePosition = (((Float)paramMap.get("nosePosition")).floatValue() * 0.008F);
    }
    if (paramMap.containsKey("noseTipSize")) {
      this.noseTipSize = (((Float)paramMap.get("noseTipSize")).floatValue() * -0.02F);
    }
    if (paramMap.containsKey("lipsSize")) {
      this.lipsSize = (((Float)paramMap.get("lipsSize")).floatValue() * -0.003F);
    }
    if (paramMap.containsKey("lipsHeight")) {
      this.lipsHeight = (((Float)paramMap.get("lipsHeight")).floatValue() * -0.008F);
    }
    if (paramMap.containsKey("lipsWidth"))
    {
      this.lipsWidth = (((Float)paramMap.get("lipsWidth")).floatValue() * -0.0038F);
      if (this.lipsWidth < 0.0F) {
        this.lipsWidth *= 0.8F;
      }
    }
    if (paramMap.containsKey("lipsYPosition"))
    {
      this.lipsYPosition = (((Float)paramMap.get("lipsYPosition")).floatValue() * -0.01F);
      if (this.lipsYPosition < 0.0F) {
        this.lipsYPosition *= 1.4F;
      }
    }
    if (paramMap.containsKey("angles")) {
      this.angles = ((float[])paramMap.get("angles"));
    }
    if (paramMap.containsKey("size")) {
      this.size = ((float[])paramMap.get("size"));
    }
    initParams();
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes11.jar
 * Qualified Name:     com.tencent.ttpic.filter.ReshapeEyeNoseLips
 * JD-Core Version:    0.7.0.1
 */