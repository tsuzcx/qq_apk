package com.tencent.ttpic.filter;

import com.tencent.aekit.openrender.AEOpenRenderConfig.DRAW_MODE;
import com.tencent.aekit.openrender.UniformParam.Float1sParam;
import com.tencent.aekit.openrender.UniformParam.Float2sParam;
import com.tencent.aekit.openrender.UniformParam.FloatParam;
import com.tencent.aekit.openrender.UniformParam.FloatsParam;
import com.tencent.aekit.openrender.internal.VideoFilterBase;
import com.tencent.filter.BaseFilter;
import java.util.Map;

public class ReshapeEyeNoseLips_new
  extends VideoFilterBase
{
  private static final String FRAGMENT_SHADER_VTF = " precision highp float;\n\n vec2 textureCoordinateFix; //used for fix error\n\n uniform vec2 posV[20];\n uniform float paramV[17];\n //common\n uniform float sin_t;\n uniform float cos_t;\n uniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\n uniform vec2 size;\n varying vec2 textureCoordinate;\n\n uniform sampler2D inputImageTexture;\n\n const float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\n const float kPi = 3.14159265358979;\n const float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\n //common func\n float getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n     // un-normalization\n     //boundingSize = boundingSize * size;\n     //point = point * size;\n     //center = center * size;\n\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n float getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n     // un-normalization\n     //boundingSize = boundingSize * size;\n     //point = point * size;\n     //center = center * size;\n\n     float cos_t = cos(ang);\n     float sin_t = sin(ang);\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n float getEllipseMask3(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n     // un-normalization\n     //boundingSize = boundingSize * size;\n     //point = point * size;\n     //center = center * size;\n\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n     return 1.0 - clamp((d2 - a1) / (a2 - a1), 0.0, 1.0);\n }\n\n vec2 rotate2DPoint(vec2 point, float angle) {\n     return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n }\n\n //for eye part\n float eye_getLeftEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, textureCoordinateFix, posV[1], posV[0], a1, a2);\n }\n float eye_getRightEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, textureCoordinateFix, posV[3], posV[2], a1, a2);\n }\n vec2 eye_getScaledEyesPoint(vec2 originalPoint, vec2 scalingFactors,float scalingFactor,float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     vec2 eyesScaledPoint = originalPoint;\n     vec2 leftEyeScaledPoint = posV[1] + scalingFactors * (originalPoint - posV[1]);\n     eyesScaledPoint = mix(eyesScaledPoint, leftEyeScaledPoint, leftEyeMask);\n     vec2 rightEyeScaledPoint = posV[3] + scalingFactors * (originalPoint - posV[3]);\n     eyesScaledPoint = mix(eyesScaledPoint, rightEyeScaledPoint, rightEyeMask);\n     return mix(originalPoint, eyesScaledPoint, scalingFactor);\n }\n vec2 eye_getEyesDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return vec2(abs(kEyesDistanceXRatio * (posV[1] - posV[3]).x), 0.0);\n }\n vec2 eye_getEyesDistanceFactors2() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(posV[1].x - posV[3].x, posV[1].y - posV[3].y);\n }\n\n vec2 eye_getScaledEyesPoint2(vec2 originalPoint, float scalingFactor, float theta, float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     float sin_t2 = sin(theta);\n     float cos_t2 = cos(theta);\n     vec2 v = originalPoint - posV[1];\n     float d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * leftEyeMask * scalingFactor;\n     vec2 left = d * vec2(cos_t2, sin_t2);\n\n     v = originalPoint - posV[3];\n     d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * rightEyeMask * scalingFactor;\n     vec2 right = d * vec2(cos_t2, sin_t2);\n     return originalPoint+left+right;\n }\n\n vec2 getEyeDiff() {\n     //faceIndex;\n     float leftEyeFineMask     = eye_getLeftEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float rightEyeFineMask    = eye_getRightEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float leftEyeCoarseMask   = eye_getLeftEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     float rightEyeCoarseMask  = eye_getRightEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     vec2 displacedEyesPoint   = textureCoordinateFix;\n     //textureCoordinate = vec2(leftEyeFineMask+rightEyeFineMask);\n     //gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     //return;\n     // width\n     vec2 kEyesWidthFactors = vec2(1.3*cos_t, -1.3*sin_t);\n     //vec3 kEyesWidthFactors = vec3(1.3, 1.0, 1.0);\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, paramV[1], angles.z, leftEyeFineMask, rightEyeFineMask);\n\n\n     // height\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, paramV[2], kPi/2.0 + angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // all size\n     const vec2 kEyesSizeFactors = vec2(1.4, 1.4);\n     displacedEyesPoint = eye_getScaledEyesPoint(displacedEyesPoint, kEyesSizeFactors, paramV[0], leftEyeFineMask, rightEyeFineMask);\n\n     // rotate\n     vec2 leftEye2DTiltPoint = posV[1] + rotate2DPoint(displacedEyesPoint - posV[1], -paramV[3]);\n     displacedEyesPoint = mix(displacedEyesPoint, leftEye2DTiltPoint, leftEyeCoarseMask);\n     vec2 rightEye2DTiltPoint = posV[3] + rotate2DPoint(displacedEyesPoint - posV[3], paramV[3]);\n     displacedEyesPoint = mix(displacedEyesPoint, rightEye2DTiltPoint, rightEyeCoarseMask);\n\n\n     // distance\n     vec2 eyesDistanceFactors = eye_getEyesDistanceFactors2();\n     vec2 leftEyeDistancePoint = displacedEyesPoint + paramV[4] * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, leftEyeDistancePoint, leftEyeCoarseMask);\n     vec2 rightEyeDistancePoint = displacedEyesPoint - paramV[4] * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, rightEyeDistancePoint, rightEyeCoarseMask);\n\n\n     vec2 diffPosition = displacedEyesPoint - textureCoordinateFix;\n     return diffPosition;\n }\n\n float nose_getNoseMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, textureCoordinateFix, posV[4], posV[5], a1, a2);\n }\n float nose_getNoseTipFineMask() {\n     return getEllipseMask(vec2(2.0, 2.0), textureCoordinateFix, posV[6], posV[7], 0.4, 0.8);\n }\n float nose_getNoseTipCoarseMask() {\n     return getEllipseMask(vec2(1.0, 1.2), textureCoordinateFix, posV[8], posV[7], 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisMask() {\n     return getEllipseMask(vec2(2.0, 1.0), textureCoordinateFix, posV[4], posV[5], 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisFineMask() {\n     return getEllipseMask(vec2(2.5, 0.8), textureCoordinateFix, posV[4], posV[5], 0.5, 1.2);\n }\n float nose_getLipsMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask3(sigmaScaling, textureCoordinateFix, posV[9], posV[10], a1, a2);\n }\n\n vec2 nose_getScaledNosePoint(vec2 originalPoint, vec2 center, float scale) {\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n\n vec2 getNoseDiff() {\n     float noseNegativeRegionsMask = (1.0 - eye_getLeftEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - eye_getRightEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - nose_getLipsMask(vec2(1.8), 0.5, 1.0));\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.5), 0.5, 1.2) * noseNegativeRegionsMask;\n     float noseTipFineMask = nose_getNoseTipFineMask() * noseNegativeRegionsMask;\n     float noseTipCoarseMask = nose_getNoseTipCoarseMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisMask = nose_getNoseVerticalAxisMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisFineMask = nose_getNoseVerticalAxisFineMask() * noseNegativeRegionsMask;\n     vec2 displacedNosePoint = textureCoordinateFix;\n\n     vec2 noseOutlineWidthPoint = nose_getScaledNosePoint(displacedNosePoint, posV[4], 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseOutlineWidthPoint, paramV[6] * noseTipCoarseMask*(1.0-noseVertivalAxisFineMask));\n\n     vec2 noseBridgeWidthPoint = nose_getScaledNosePoint(displacedNosePoint, posV[4], 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseBridgeWidthPoint, paramV[7] * noseVertivalAxisMask);\n\n\n     vec2 noseSizePoint = nose_getScaledNosePoint(displacedNosePoint, posV[4], 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseSizePoint, paramV[5] * noseMask);\n\n\n     const float kNoseLiftingYRatio = 0.05518821053;\n     vec2 noseLiftingVector = vec2(0.0, -kNoseLiftingYRatio * posV[5].y);\n     noseLiftingVector = vec2(dot(noseLiftingVector, vec2(cos_t, -sin_t)), dot(noseLiftingVector, vec2(sin_t, cos_t)));\n     vec2 nosePositionPoint = displacedNosePoint + noseLiftingVector;\n     displacedNosePoint = mix(displacedNosePoint, nosePositionPoint, paramV[8] * noseMask);\n\n     vec2 noseTipPoint = posV[6] + vec2(0.4) * (displacedNosePoint - posV[6]);\n     displacedNosePoint = mix(displacedNosePoint, noseTipPoint, paramV[9] * noseTipFineMask);\n\n\n     vec2 diffPosition = displacedNosePoint - textureCoordinateFix;\n     return diffPosition;\n }\n vec2 lips_getScaledLipsPoint(in vec2 originalPoint, in vec2 scalingFactors, in float scalingCoefficient, in float lipsMask) {\n     if (scalingCoefficient == 0.0) {\n         return originalPoint;\n     }\n     vec2 lipsScaledPoint = posV[9] + scalingFactors * (originalPoint - posV[9]);\n     return mix(originalPoint, lipsScaledPoint, scalingCoefficient * lipsMask);\n }\n\n vec2 lips_getScaledLipsPoint2(vec2 originalPoint, vec2 center, float theta, float scale) {\n     float sin_t = sin(theta);\n     float cos_t = cos(theta);\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n vec2 lips_getTransformYFactors() {\n     const float kDistanceYRatio = 0.1;\n     return kDistanceYRatio * (posV[4] - posV[9]) / 2.0;\n }\n float lips_face_getFaceMaskLeft2(vec2 point) {\n     return getEllipseMask2(vec2(0.8, 1.8), point, posV[16], posV[15], 0.6, 1.2, posV[17].x);\n }\n float lips_face_getFaceMaskRight2(vec2 point) {\n     return getEllipseMask2(vec2(0.8, 1.8), point, posV[19], posV[18], 0.6, 1.2, posV[17].y);\n }\n\n vec2 getLipsDiff() {\n     const float kScalingFactor = 1.3;\n     vec2 originalPosition = textureCoordinateFix;\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.2), 0.5, 1.0);\n     float faceCoarseMaskLeft2   = lips_face_getFaceMaskLeft2(textureCoordinateFix);\n     float faceCoarseMaskRight2   = lips_face_getFaceMaskRight2(textureCoordinateFix);\n     float lipsNegativeMask = min((1.0 - noseMask), min((1.0 - faceCoarseMaskLeft2), (1.0 - faceCoarseMaskRight2)));\n     float lipsMask = nose_getLipsMask(vec2(1.2, 1.2), 0.7, 1.1) * lipsNegativeMask;\n//     float lipsMask1 = nose_getLipsMask(vec2(1.2, 1.1), 0.8, 0.9) * lipsNegativeMask;\n     float lipsMask2 = nose_getLipsMask(vec2(1.2, 0.8), 0.8, 1.2) * lipsNegativeMask;\n     vec2 displacedLipsPoint = textureCoordinateFix;\n\n//     const vec2 kLipsWidthFactors = vec2(kScalingFactor, 1.0);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, posV[9], angles.z, 0.3), paramV[11] * lipsMask);\n\n\n//     const vec2 kLipsHeightFactors = vec2(1.0, kScalingFactor);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, posV[9], kPi/2.0 + angles.z, 0.3), paramV[12] * lipsMask);\n\n\n     const vec2 kLipsSizeFactors = vec2(kScalingFactor, kScalingFactor);\n     displacedLipsPoint = lips_getScaledLipsPoint(displacedLipsPoint, kLipsSizeFactors, paramV[10], lipsMask);\n\n\n     vec2 lipsYFactors = lips_getTransformYFactors();\n     vec2 lipsTransformYPoint = displacedLipsPoint + lipsYFactors;\n     displacedLipsPoint = mix(displacedLipsPoint, lipsTransformYPoint, paramV[13] * lipsMask2);\n\n     vec2 diffPosition = displacedLipsPoint - textureCoordinateFix;\n     return diffPosition;\n }\n\n float brow_getLeftEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), textureCoordinateFix, posV[11], posV[12], 0.7, 1.0);\n }\n\n float brow_getRightEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), textureCoordinateFix, posV[13], posV[14], 0.7, 1.0);\n }\n\n float brow_getLeftEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), textureCoordinateFix, posV[11], posV[12], 0.6, 1.0);\n }\n\n float brow_getRightEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), textureCoordinateFix, posV[13], posV[14], 0.6, 1.0);\n }\n vec2 brow_getEyebrowDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(posV[11].x - posV[13].x, posV[11].y - posV[13].y);\n }\n vec2 brow_getEyebrowHeightFactors() {\n     const float kEyesDistanceXRatio = 0.14;\n     return kEyesDistanceXRatio * (posV[11] + posV[13] - posV[1] - posV[3]) / 2.0;\n }\n vec2 getEyebrowDiff() {\n     float _noseNegativeMask    = 1.0 - nose_getNoseMask(vec2(3.0, 0.9), 0.7, 0.9);\n     float _leftEyeNegativeMask = 1.0 - eye_getLeftEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float _rightEyeNegativeMask = 1.0 - eye_getRightEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float leftEyebrowMask   = brow_getLeftEyebrowMask() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask  = brow_getRightEyebrowMask() * _rightEyeNegativeMask * _noseNegativeMask;\n     float leftEyebrowMask2   = brow_getLeftEyebrowMask2() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask2  = brow_getRightEyebrowMask2() * _rightEyeNegativeMask * _noseNegativeMask;\n     vec2 displacedEyebrowPoint   = textureCoordinateFix;\n\n     // rotate\n\n     vec2 leftEyebrow2DTiltPoint = posV[11] + rotate2DPoint(displacedEyebrowPoint - posV[11], -paramV[16]);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyebrow2DTiltPoint, leftEyebrowMask2);\n     vec2 rightEyebrow2DTiltPoint = posV[13] + rotate2DPoint(displacedEyebrowPoint - posV[13], paramV[16]);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrow2DTiltPoint, rightEyebrowMask2);\n\n\n     // distance\n     vec2 eyebrowDistanceFactors = brow_getEyebrowDistanceFactors();\n     vec2 leftEyeBrowDistancePoint = displacedEyebrowPoint + paramV[15] * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowDistancePoint, leftEyebrowMask);\n     vec2 rightEyebrowDistancePoint = displacedEyebrowPoint - paramV[15] * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowDistancePoint, rightEyebrowMask);\n\n\n     vec2 eyebrowHeightFactors = brow_getEyebrowHeightFactors();\n     vec2 leftEyeBrowHeightPoint = displacedEyebrowPoint + paramV[14] * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowHeightPoint, leftEyebrowMask);\n     vec2 rightEyebrowHeightPoint = displacedEyebrowPoint + paramV[14] * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowHeightPoint, rightEyebrowMask);\n\n     vec2 diffPosition = displacedEyebrowPoint - textureCoordinateFix;\n     return diffPosition;\n }\n\n void main(){\n     vec2 trueDiff = vec2(0.0, 0.0);\n\n     vec4 texDiff = texture2D(inputImageTexture, textureCoordinate);\n     trueDiff = (texDiff.xy * 255.0 + texDiff.zw) / 127.5 - 1.0;   //diff of raw\n     if (trueDiff.x < -0.9 && trueDiff.y < -0.9){\n         trueDiff = vec2(0.0, 0.0);\n     }\n\n     textureCoordinateFix = (textureCoordinate * size - 0.5) / (size - 1.0);\n     vec2 diffPosition = getEyeDiff() + getNoseDiff() + getLipsDiff() + getEyebrowDiff() + trueDiff;\n     diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;\n     vec2 a = floor(diffPosition) / 255.0;\n     vec2 b = fract(diffPosition);\n     gl_FragColor = vec4(a,b);\n\n }";
  private static final String VERTEX_SHADER_VTF = "attribute vec4 position;\nattribute vec2 inputTextureCoordinate;\n\nvarying vec2 textureCoordinate;\n\nvoid main()\n{\n     gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     textureCoordinate = inputTextureCoordinate.xy;\n}";
  private static final int XCOORD_NUM = 64;
  private static final int YCOORD_NUM = 64;
  private static float[] mFullscreenVerticesPortrait;
  private static float[] mInitTextureCoordinatesPortrait;
  private float[] angles = { 0.0F, 0.0F, 0.0F };
  private float eyebrowDistance = 1.0F;
  private float eyebrowHeight = 0.0F;
  private float eyebrowTiltAngle = 0.0F;
  private float eyesDistance = 1.0F;
  private float eyesHeight = 0.0F;
  private float eyesSize = 0.1F;
  private float eyesTiltAngle = 0.0F;
  private float eyesWidth = 0.0F;
  private float lipsHeight = 0.0F;
  private float lipsSize = 0.0F;
  private float lipsWidth = 0.0F;
  private float lipsYPosition = 0.0F;
  private float noseBridgeWidth = 0.1F;
  private float noseOutlineWidth = 0.0F;
  private float nosePosition = 0.0F;
  private float noseSize = 0.0F;
  private float noseTipSize = 1.0F;
  private float[] paramV1 = new float[17];
  private float[] posV1 = new float[40];
  private float[] size = { 1.0F, 1.0F };
  
  public ReshapeEyeNoseLips_new()
  {
    super(BaseFilter.nativeDecrypt("attribute vec4 position;\nattribute vec2 inputTextureCoordinate;\n\nvarying vec2 textureCoordinate;\n\nvoid main()\n{\n     gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     textureCoordinate = inputTextureCoordinate.xy;\n}"), BaseFilter.nativeDecrypt(" precision highp float;\n\n vec2 textureCoordinateFix; //used for fix error\n\n uniform vec2 posV[20];\n uniform float paramV[17];\n //common\n uniform float sin_t;\n uniform float cos_t;\n uniform vec3 angles; // angles.x: pitch, angles.y: yaw, angles.z: roll\n uniform vec2 size;\n varying vec2 textureCoordinate;\n\n uniform sampler2D inputImageTexture;\n\n const float kLipsEdgeWrinkleSizeToLipsSizeRatio = 0.23;\n const float kPi = 3.14159265358979;\n const float kLipsEdgeWrinklesRotationAngle = 0.025 * kPi;\n\n //common func\n float getEllipseMask(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n     // un-normalization\n     //boundingSize = boundingSize * size;\n     //point = point * size;\n     //center = center * size;\n\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n float getEllipseMask2(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2, float ang) {\n     // un-normalization\n     //boundingSize = boundingSize * size;\n     //point = point * size;\n     //center = center * size;\n\n     float cos_t = cos(ang);\n     float sin_t = sin(ang);\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n     return 1.0 - smoothstep(a1, a2, d2);\n }\n\n float getEllipseMask3(in vec2 sigmaScaling, in vec2 point,in vec2 center, in vec2 boundingSize, float a1, float a2) {\n     // un-normalization\n     //boundingSize = boundingSize * size;\n     //point = point * size;\n     //center = center * size;\n\n     vec2 translate = (point - center);\n     // rotate and scale\n     vec2 v = vec2(dot(translate, vec2(cos_t, sin_t)), dot(translate, vec2(-sin_t, cos_t))) * sigmaScaling;\n\n     float d2 = sqrt(dot(v / boundingSize, v / boundingSize));\n\n     return 1.0 - clamp((d2 - a1) / (a2 - a1), 0.0, 1.0);\n }\n\n vec2 rotate2DPoint(vec2 point, float angle) {\n     return vec2(cos(angle) * point.x - sin(angle) * point.y, sin(angle) * point.x + cos(angle) * point.y);\n }\n\n //for eye part\n float eye_getLeftEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, textureCoordinateFix, posV[1], posV[0], a1, a2);\n }\n float eye_getRightEyeFineMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, textureCoordinateFix, posV[3], posV[2], a1, a2);\n }\n vec2 eye_getScaledEyesPoint(vec2 originalPoint, vec2 scalingFactors,float scalingFactor,float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     vec2 eyesScaledPoint = originalPoint;\n     vec2 leftEyeScaledPoint = posV[1] + scalingFactors * (originalPoint - posV[1]);\n     eyesScaledPoint = mix(eyesScaledPoint, leftEyeScaledPoint, leftEyeMask);\n     vec2 rightEyeScaledPoint = posV[3] + scalingFactors * (originalPoint - posV[3]);\n     eyesScaledPoint = mix(eyesScaledPoint, rightEyeScaledPoint, rightEyeMask);\n     return mix(originalPoint, eyesScaledPoint, scalingFactor);\n }\n vec2 eye_getEyesDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return vec2(abs(kEyesDistanceXRatio * (posV[1] - posV[3]).x), 0.0);\n }\n vec2 eye_getEyesDistanceFactors2() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(posV[1].x - posV[3].x, posV[1].y - posV[3].y);\n }\n\n vec2 eye_getScaledEyesPoint2(vec2 originalPoint, float scalingFactor, float theta, float leftEyeMask, float rightEyeMask) {\n     if (scalingFactor == 0.0) {\n         return originalPoint;\n     }\n     float sin_t2 = sin(theta);\n     float cos_t2 = cos(theta);\n     vec2 v = originalPoint - posV[1];\n     float d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * leftEyeMask * scalingFactor;\n     vec2 left = d * vec2(cos_t2, sin_t2);\n\n     v = originalPoint - posV[3];\n     d = dot(v, vec2(cos_t2, sin_t2));\n     d = d * 0.3 * rightEyeMask * scalingFactor;\n     vec2 right = d * vec2(cos_t2, sin_t2);\n     return originalPoint+left+right;\n }\n\n vec2 getEyeDiff() {\n     //faceIndex;\n     float leftEyeFineMask     = eye_getLeftEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float rightEyeFineMask    = eye_getRightEyeFineMask(vec2(1.0, 0.6), 0.9, 1.1);\n     float leftEyeCoarseMask   = eye_getLeftEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     float rightEyeCoarseMask  = eye_getRightEyeFineMask(vec2(0.8, 0.7), 0.7, 1.2);\n     vec2 displacedEyesPoint   = textureCoordinateFix;\n     //textureCoordinate = vec2(leftEyeFineMask+rightEyeFineMask);\n     //gl_Position = vec4(position.x*2.0-1.0, position.y*2.0-1.0, 0.0, 1.0);\n     //return;\n     // width\n     vec2 kEyesWidthFactors = vec2(1.3*cos_t, -1.3*sin_t);\n     //vec3 kEyesWidthFactors = vec3(1.3, 1.0, 1.0);\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, paramV[1], angles.z, leftEyeFineMask, rightEyeFineMask);\n\n\n     // height\n     displacedEyesPoint = eye_getScaledEyesPoint2(displacedEyesPoint, paramV[2], kPi/2.0 + angles.z, leftEyeFineMask, rightEyeFineMask);\n\n     // all size\n     const vec2 kEyesSizeFactors = vec2(1.4, 1.4);\n     displacedEyesPoint = eye_getScaledEyesPoint(displacedEyesPoint, kEyesSizeFactors, paramV[0], leftEyeFineMask, rightEyeFineMask);\n\n     // rotate\n     vec2 leftEye2DTiltPoint = posV[1] + rotate2DPoint(displacedEyesPoint - posV[1], -paramV[3]);\n     displacedEyesPoint = mix(displacedEyesPoint, leftEye2DTiltPoint, leftEyeCoarseMask);\n     vec2 rightEye2DTiltPoint = posV[3] + rotate2DPoint(displacedEyesPoint - posV[3], paramV[3]);\n     displacedEyesPoint = mix(displacedEyesPoint, rightEye2DTiltPoint, rightEyeCoarseMask);\n\n\n     // distance\n     vec2 eyesDistanceFactors = eye_getEyesDistanceFactors2();\n     vec2 leftEyeDistancePoint = displacedEyesPoint + paramV[4] * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, leftEyeDistancePoint, leftEyeCoarseMask);\n     vec2 rightEyeDistancePoint = displacedEyesPoint - paramV[4] * eyesDistanceFactors;\n     displacedEyesPoint = mix(displacedEyesPoint, rightEyeDistancePoint, rightEyeCoarseMask);\n\n\n     vec2 diffPosition = displacedEyesPoint - textureCoordinateFix;\n     return diffPosition;\n }\n\n float nose_getNoseMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask(sigmaScaling, textureCoordinateFix, posV[4], posV[5], a1, a2);\n }\n float nose_getNoseTipFineMask() {\n     return getEllipseMask(vec2(2.0, 2.0), textureCoordinateFix, posV[6], posV[7], 0.4, 0.8);\n }\n float nose_getNoseTipCoarseMask() {\n     return getEllipseMask(vec2(1.0, 1.2), textureCoordinateFix, posV[8], posV[7], 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisMask() {\n     return getEllipseMask(vec2(2.0, 1.0), textureCoordinateFix, posV[4], posV[5], 0.5, 1.2);\n }\n float nose_getNoseVerticalAxisFineMask() {\n     return getEllipseMask(vec2(2.5, 0.8), textureCoordinateFix, posV[4], posV[5], 0.5, 1.2);\n }\n float nose_getLipsMask(vec2 sigmaScaling, float a1, float a2) {\n     return getEllipseMask3(sigmaScaling, textureCoordinateFix, posV[9], posV[10], a1, a2);\n }\n\n vec2 nose_getScaledNosePoint(vec2 originalPoint, vec2 center, float scale) {\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n\n vec2 getNoseDiff() {\n     float noseNegativeRegionsMask = (1.0 - eye_getLeftEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - eye_getRightEyeFineMask(vec2(0.8), 0.5, 1.2)) * (1.0 - nose_getLipsMask(vec2(1.8), 0.5, 1.0));\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.5), 0.5, 1.2) * noseNegativeRegionsMask;\n     float noseTipFineMask = nose_getNoseTipFineMask() * noseNegativeRegionsMask;\n     float noseTipCoarseMask = nose_getNoseTipCoarseMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisMask = nose_getNoseVerticalAxisMask() * noseNegativeRegionsMask;\n     float noseVertivalAxisFineMask = nose_getNoseVerticalAxisFineMask() * noseNegativeRegionsMask;\n     vec2 displacedNosePoint = textureCoordinateFix;\n\n     vec2 noseOutlineWidthPoint = nose_getScaledNosePoint(displacedNosePoint, posV[4], 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseOutlineWidthPoint, paramV[6] * noseTipCoarseMask*(1.0-noseVertivalAxisFineMask));\n\n     vec2 noseBridgeWidthPoint = nose_getScaledNosePoint(displacedNosePoint, posV[4], 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseBridgeWidthPoint, paramV[7] * noseVertivalAxisMask);\n\n\n     vec2 noseSizePoint = nose_getScaledNosePoint(displacedNosePoint, posV[4], 0.3);\n     displacedNosePoint = mix(displacedNosePoint, noseSizePoint, paramV[5] * noseMask);\n\n\n     const float kNoseLiftingYRatio = 0.05518821053;\n     vec2 noseLiftingVector = vec2(0.0, -kNoseLiftingYRatio * posV[5].y);\n     noseLiftingVector = vec2(dot(noseLiftingVector, vec2(cos_t, -sin_t)), dot(noseLiftingVector, vec2(sin_t, cos_t)));\n     vec2 nosePositionPoint = displacedNosePoint + noseLiftingVector;\n     displacedNosePoint = mix(displacedNosePoint, nosePositionPoint, paramV[8] * noseMask);\n\n     vec2 noseTipPoint = posV[6] + vec2(0.4) * (displacedNosePoint - posV[6]);\n     displacedNosePoint = mix(displacedNosePoint, noseTipPoint, paramV[9] * noseTipFineMask);\n\n\n     vec2 diffPosition = displacedNosePoint - textureCoordinateFix;\n     return diffPosition;\n }\n vec2 lips_getScaledLipsPoint(in vec2 originalPoint, in vec2 scalingFactors, in float scalingCoefficient, in float lipsMask) {\n     if (scalingCoefficient == 0.0) {\n         return originalPoint;\n     }\n     vec2 lipsScaledPoint = posV[9] + scalingFactors * (originalPoint - posV[9]);\n     return mix(originalPoint, lipsScaledPoint, scalingCoefficient * lipsMask);\n }\n\n vec2 lips_getScaledLipsPoint2(vec2 originalPoint, vec2 center, float theta, float scale) {\n     float sin_t = sin(theta);\n     float cos_t = cos(theta);\n     vec2 v = originalPoint - center;\n     float d = dot(v, vec2(cos_t, sin_t));\n     d = d * scale;\n     vec2 dv = d * vec2(cos_t, sin_t);\n\n     return originalPoint+dv;\n }\n vec2 lips_getTransformYFactors() {\n     const float kDistanceYRatio = 0.1;\n     return kDistanceYRatio * (posV[4] - posV[9]) / 2.0;\n }\n float lips_face_getFaceMaskLeft2(vec2 point) {\n     return getEllipseMask2(vec2(0.8, 1.8), point, posV[16], posV[15], 0.6, 1.2, posV[17].x);\n }\n float lips_face_getFaceMaskRight2(vec2 point) {\n     return getEllipseMask2(vec2(0.8, 1.8), point, posV[19], posV[18], 0.6, 1.2, posV[17].y);\n }\n\n vec2 getLipsDiff() {\n     const float kScalingFactor = 1.3;\n     vec2 originalPosition = textureCoordinateFix;\n     float noseMask = nose_getNoseMask(vec2(1.0, 1.2), 0.5, 1.0);\n     float faceCoarseMaskLeft2   = lips_face_getFaceMaskLeft2(textureCoordinateFix);\n     float faceCoarseMaskRight2   = lips_face_getFaceMaskRight2(textureCoordinateFix);\n     float lipsNegativeMask = min((1.0 - noseMask), min((1.0 - faceCoarseMaskLeft2), (1.0 - faceCoarseMaskRight2)));\n     float lipsMask = nose_getLipsMask(vec2(1.2, 1.2), 0.7, 1.1) * lipsNegativeMask;\n//     float lipsMask1 = nose_getLipsMask(vec2(1.2, 1.1), 0.8, 0.9) * lipsNegativeMask;\n     float lipsMask2 = nose_getLipsMask(vec2(1.2, 0.8), 0.8, 1.2) * lipsNegativeMask;\n     vec2 displacedLipsPoint = textureCoordinateFix;\n\n//     const vec2 kLipsWidthFactors = vec2(kScalingFactor, 1.0);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, posV[9], angles.z, 0.3), paramV[11] * lipsMask);\n\n\n//     const vec2 kLipsHeightFactors = vec2(1.0, kScalingFactor);\n     displacedLipsPoint = mix(displacedLipsPoint, lips_getScaledLipsPoint2(displacedLipsPoint, posV[9], kPi/2.0 + angles.z, 0.3), paramV[12] * lipsMask);\n\n\n     const vec2 kLipsSizeFactors = vec2(kScalingFactor, kScalingFactor);\n     displacedLipsPoint = lips_getScaledLipsPoint(displacedLipsPoint, kLipsSizeFactors, paramV[10], lipsMask);\n\n\n     vec2 lipsYFactors = lips_getTransformYFactors();\n     vec2 lipsTransformYPoint = displacedLipsPoint + lipsYFactors;\n     displacedLipsPoint = mix(displacedLipsPoint, lipsTransformYPoint, paramV[13] * lipsMask2);\n\n     vec2 diffPosition = displacedLipsPoint - textureCoordinateFix;\n     return diffPosition;\n }\n\n float brow_getLeftEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), textureCoordinateFix, posV[11], posV[12], 0.7, 1.0);\n }\n\n float brow_getRightEyebrowMask() {\n     return getEllipseMask(vec2(1.4, 0.8), textureCoordinateFix, posV[13], posV[14], 0.7, 1.0);\n }\n\n float brow_getLeftEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), textureCoordinateFix, posV[11], posV[12], 0.6, 1.0);\n }\n\n float brow_getRightEyebrowMask2() {\n     return getEllipseMask(vec2(1.0, 0.7), textureCoordinateFix, posV[13], posV[14], 0.6, 1.0);\n }\n vec2 brow_getEyebrowDistanceFactors() {\n     const float kEyesDistanceXRatio = 0.03662283339;\n     return kEyesDistanceXRatio * vec2(posV[11].x - posV[13].x, posV[11].y - posV[13].y);\n }\n vec2 brow_getEyebrowHeightFactors() {\n     const float kEyesDistanceXRatio = 0.14;\n     return kEyesDistanceXRatio * (posV[11] + posV[13] - posV[1] - posV[3]) / 2.0;\n }\n vec2 getEyebrowDiff() {\n     float _noseNegativeMask    = 1.0 - nose_getNoseMask(vec2(3.0, 0.9), 0.7, 0.9);\n     float _leftEyeNegativeMask = 1.0 - eye_getLeftEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float _rightEyeNegativeMask = 1.0 - eye_getRightEyeFineMask(vec2(1.5, 1.5), 0.6, 0.9);\n     float leftEyebrowMask   = brow_getLeftEyebrowMask() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask  = brow_getRightEyebrowMask() * _rightEyeNegativeMask * _noseNegativeMask;\n     float leftEyebrowMask2   = brow_getLeftEyebrowMask2() * _leftEyeNegativeMask * _noseNegativeMask;\n     float rightEyebrowMask2  = brow_getRightEyebrowMask2() * _rightEyeNegativeMask * _noseNegativeMask;\n     vec2 displacedEyebrowPoint   = textureCoordinateFix;\n\n     // rotate\n\n     vec2 leftEyebrow2DTiltPoint = posV[11] + rotate2DPoint(displacedEyebrowPoint - posV[11], -paramV[16]);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyebrow2DTiltPoint, leftEyebrowMask2);\n     vec2 rightEyebrow2DTiltPoint = posV[13] + rotate2DPoint(displacedEyebrowPoint - posV[13], paramV[16]);\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrow2DTiltPoint, rightEyebrowMask2);\n\n\n     // distance\n     vec2 eyebrowDistanceFactors = brow_getEyebrowDistanceFactors();\n     vec2 leftEyeBrowDistancePoint = displacedEyebrowPoint + paramV[15] * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowDistancePoint, leftEyebrowMask);\n     vec2 rightEyebrowDistancePoint = displacedEyebrowPoint - paramV[15] * eyebrowDistanceFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowDistancePoint, rightEyebrowMask);\n\n\n     vec2 eyebrowHeightFactors = brow_getEyebrowHeightFactors();\n     vec2 leftEyeBrowHeightPoint = displacedEyebrowPoint + paramV[14] * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, leftEyeBrowHeightPoint, leftEyebrowMask);\n     vec2 rightEyebrowHeightPoint = displacedEyebrowPoint + paramV[14] * eyebrowHeightFactors;\n     displacedEyebrowPoint = mix(displacedEyebrowPoint, rightEyebrowHeightPoint, rightEyebrowMask);\n\n     vec2 diffPosition = displacedEyebrowPoint - textureCoordinateFix;\n     return diffPosition;\n }\n\n void main(){\n     vec2 trueDiff = vec2(0.0, 0.0);\n\n     vec4 texDiff = texture2D(inputImageTexture, textureCoordinate);\n     trueDiff = (texDiff.xy * 255.0 + texDiff.zw) / 127.5 - 1.0;   //diff of raw\n     if (trueDiff.x < -0.9 && trueDiff.y < -0.9){\n         trueDiff = vec2(0.0, 0.0);\n     }\n\n     textureCoordinateFix = (textureCoordinate * size - 0.5) / (size - 1.0);\n     vec2 diffPosition = getEyeDiff() + getNoseDiff() + getLipsDiff() + getEyebrowDiff() + trueDiff;\n     diffPosition = 0.5 * (diffPosition + 1.0) * 255.0;\n     vec2 a = floor(diffPosition) / 255.0;\n     vec2 b = fract(diffPosition);\n     gl_FragColor = vec4(a,b);\n\n }"));
    initParams();
  }
  
  public void ApplyGLSLFilter()
  {
    initParams();
    super.ApplyGLSLFilter();
    setDrawMode(AEOpenRenderConfig.DRAW_MODE.TRIANGLE_STRIP);
  }
  
  public void getparamV()
  {
    float[] arrayOfFloat = this.paramV1;
    arrayOfFloat[0] = this.eyesSize;
    arrayOfFloat[1] = this.eyesWidth;
    arrayOfFloat[2] = this.eyesHeight;
    arrayOfFloat[3] = this.eyesTiltAngle;
    arrayOfFloat[4] = this.eyesDistance;
    arrayOfFloat[5] = this.noseSize;
    arrayOfFloat[6] = this.noseOutlineWidth;
    arrayOfFloat[7] = this.noseBridgeWidth;
    arrayOfFloat[8] = this.nosePosition;
    arrayOfFloat[9] = this.noseTipSize;
    arrayOfFloat[10] = this.lipsSize;
    arrayOfFloat[11] = this.lipsWidth;
    arrayOfFloat[12] = this.lipsHeight;
    arrayOfFloat[13] = this.lipsYPosition;
    arrayOfFloat[14] = this.eyebrowHeight;
    arrayOfFloat[15] = this.eyebrowDistance;
    arrayOfFloat[16] = this.eyebrowTiltAngle;
  }
  
  public void initAttribParams()
  {
    setPositions(mFullscreenVerticesPortrait, false);
    setTexCords(mInitTextureCoordinatesPortrait, false);
    setCoordNum(8257);
  }
  
  public void initParams()
  {
    addParam(new UniformParam.Float2sParam("posV", this.posV1));
    getparamV();
    addParam(new UniformParam.Float1sParam("paramV", this.paramV1));
    addParam(new UniformParam.FloatsParam("angles", this.angles));
    addParam(new UniformParam.FloatsParam("size", this.size));
    float f = (float)Math.cos(this.angles[2]);
    addParam(new UniformParam.FloatParam("sin_t", (float)Math.sin(this.angles[2])));
    addParam(new UniformParam.FloatParam("cos_t", f));
  }
  
  public void setInitMesh(float[] paramArrayOfFloat1, float[] paramArrayOfFloat2)
  {
    mFullscreenVerticesPortrait = paramArrayOfFloat1;
    mInitTextureCoordinatesPortrait = paramArrayOfFloat2;
  }
  
  public void setParam(Map<String, Object> paramMap)
  {
    if (paramMap.containsKey("posV1")) {
      this.posV1 = ((float[])paramMap.get("posV1"));
    }
    if (paramMap.containsKey("eyebrowHeight")) {
      this.eyebrowHeight = (((Float)paramMap.get("eyebrowHeight")).floatValue() * 0.006F);
    }
    if (paramMap.containsKey("eyebrowDistance")) {
      this.eyebrowDistance = (((Float)paramMap.get("eyebrowDistance")).floatValue() * 0.009F);
    }
    if (paramMap.containsKey("eyebrowAngle")) {
      this.eyebrowTiltAngle = (((Float)paramMap.get("eyebrowAngle")).floatValue() * 0.0017F);
    }
    if (paramMap.containsKey("eyesWidth")) {
      this.eyesWidth = (((Float)paramMap.get("eyesWidth")).floatValue() * -0.003F);
    }
    if (paramMap.containsKey("eyesHeight")) {
      this.eyesHeight = (((Float)paramMap.get("eyesHeight")).floatValue() * -0.004F);
    }
    if (paramMap.containsKey("eyesSize")) {
      this.eyesSize = (((Float)paramMap.get("eyesSize")).floatValue() * -0.0032F);
    }
    if (paramMap.containsKey("eyesTiltAngle")) {
      this.eyesTiltAngle = (((Float)paramMap.get("eyesTiltAngle")).floatValue() * 0.001F);
    }
    if (paramMap.containsKey("eyesDistance")) {
      this.eyesDistance = (((Float)paramMap.get("eyesDistance")).floatValue() * 0.016F);
    }
    if (paramMap.containsKey("noseSize")) {
      this.noseSize = (((Float)paramMap.get("noseSize")).floatValue() * 0.006F);
    }
    if (paramMap.containsKey("noseOutlineWidth")) {
      this.noseOutlineWidth = (((Float)paramMap.get("noseOutlineWidth")).floatValue() * 0.01F);
    }
    if (paramMap.containsKey("noseBridgeWidth")) {
      this.noseBridgeWidth = (((Float)paramMap.get("noseBridgeWidth")).floatValue() * 0.008F);
    }
    if (paramMap.containsKey("nosePosition")) {
      this.nosePosition = (((Float)paramMap.get("nosePosition")).floatValue() * 0.008F);
    }
    if (paramMap.containsKey("noseTipSize")) {
      this.noseTipSize = (((Float)paramMap.get("noseTipSize")).floatValue() * -0.02F);
    }
    if (paramMap.containsKey("lipsSize")) {
      this.lipsSize = (((Float)paramMap.get("lipsSize")).floatValue() * -0.003F);
    }
    if (paramMap.containsKey("lipsHeight")) {
      this.lipsHeight = (((Float)paramMap.get("lipsHeight")).floatValue() * -0.008F);
    }
    float f;
    if (paramMap.containsKey("lipsWidth"))
    {
      this.lipsWidth = (((Float)paramMap.get("lipsWidth")).floatValue() * -0.0038F);
      f = this.lipsWidth;
      if (f < 0.0F) {
        this.lipsWidth = (f * 0.8F);
      }
    }
    if (paramMap.containsKey("lipsYPosition"))
    {
      this.lipsYPosition = (((Float)paramMap.get("lipsYPosition")).floatValue() * -0.01F);
      f = this.lipsYPosition;
      if (f < 0.0F) {
        this.lipsYPosition = (f * 1.4F);
      }
    }
    if (paramMap.containsKey("angles")) {
      this.angles = ((float[])paramMap.get("angles"));
    }
    if (paramMap.containsKey("size")) {
      this.size = ((float[])paramMap.get("size"));
    }
    initParams();
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes15.jar
 * Qualified Name:     com.tencent.ttpic.filter.ReshapeEyeNoseLips_new
 * JD-Core Version:    0.7.0.1
 */