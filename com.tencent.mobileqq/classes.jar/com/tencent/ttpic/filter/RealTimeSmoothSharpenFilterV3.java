package com.tencent.ttpic.filter;

import com.tencent.aekit.openrender.UniformParam.Float2fParam;
import com.tencent.aekit.openrender.UniformParam.FloatParam;
import com.tencent.aekit.openrender.UniformParam.TextureParam;
import com.tencent.filter.BaseFilter;

public class RealTimeSmoothSharpenFilterV3
  extends BaseFilter
{
  private static final String FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n varying highp vec2 textureCoordsLU;\n varying highp vec2 textureCoordsU;\n varying highp vec2 textureCoordsRU;\n varying highp vec2 textureCoordsL;\n varying highp vec2 textureCoordsR;\n varying highp vec2 textureCoordsLD;\n varying highp vec2 textureCoordsD;\n varying highp vec2 textureCoordsRD;\n uniform sampler2D inputImageTexture;\n uniform sampler2D inputImageTexture2;\n uniform highp vec2 stepSize;\n uniform highp float sharpFactor;\n \n const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n \n lowp vec3 sharpenColor(lowp vec3 mixColor, lowp vec3 iColor, highp float mixAlpha) {\n     highp vec2 stepX_1 = vec2(stepSize.x, 0.0);\n     highp vec2 stepY_1 = vec2(0.0, stepSize.y);\n     highp vec2 stepX_2 = vec2(2.0 * stepSize.x, 0.0);\n     highp vec2 stepY_2 = vec2(0.0, 2.0 * stepSize.y);\n     \n     highp vec3 uColor = texture2D(inputImageTexture, textureCoordsU).rgb;\n     highp vec3 lColor = texture2D(inputImageTexture, textureCoordsL).rgb;\n     highp vec3 rColor = texture2D(inputImageTexture, textureCoordsR).rgb;\n     highp vec3 dColor = texture2D(inputImageTexture, textureCoordsD).rgb;\n     highp vec3 luColor = texture2D(inputImageTexture, textureCoordsLU).rgb;\n     highp vec3 ruColor = texture2D(inputImageTexture, textureCoordsRU).rgb;\n     highp vec3 ldColor = texture2D(inputImageTexture, textureCoordsLD).rgb;\n     highp vec3 rdColor = texture2D(inputImageTexture, textureCoordsRD).rgb;\n     \n     highp vec3 sumColor = vec3(0.0);//iColor.rgb;\n     sumColor += uColor;\n     sumColor += lColor;\n     sumColor += rColor;\n     sumColor += dColor;\n     sumColor += luColor;\n     sumColor += ruColor;\n     sumColor += ldColor;\n     sumColor += rdColor;\n     sumColor += texture2D(inputImageTexture, textureCoordinate+stepY_2).rgb;\n     sumColor += texture2D(inputImageTexture, textureCoordinate-stepX_2).rgb;\n     sumColor += texture2D(inputImageTexture, textureCoordinate+stepX_2).rgb;\n     sumColor += texture2D(inputImageTexture, textureCoordinate-stepY_2).rgb;\n     highp vec3 meanColor =  sumColor / 12.0;\n     \n     highp vec3 hPass = iColor.rgb - meanColor;\n     highp float iLum = dot(iColor, luminanceWeighting);\n     highp float mLum = dot((sumColor + iColor) / 13.0, luminanceWeighting);\n     highp float hFactor = pow(min(0.03125, abs(iLum - mLum)) / 0.03125, 2.0);\n     highp vec3 sColor = clamp((mixColor + hPass * hFactor * mixAlpha), vec3(0.0), vec3(1.0));\n     \n     return sColor;\n }\n \n lowp vec3 rgb2hsv(lowp vec3 c) {\n     lowp vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n     highp vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n     highp vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n     highp float d = q.x - min(q.w, q.y);\n     highp float e = 1.0e-10;\n     lowp vec3 hsv = vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n     return hsv;\n }\n \n void main() {\n     lowp vec4 iColor = texture2D(inputImageTexture, textureCoordinate);\n     lowp vec4 varColor = texture2D(inputImageTexture2, textureCoordinate);\n     \n     mediump float diffFactor = (1.0 - varColor.r / (varColor.r + 0.1));\n     lowp vec3 hsv = rgb2hsv(iColor.rgb);\n     mediump float p1 = clamp((iColor.r - 0.2) * 4.0, 0.0, 1.0);\n     mediump float p2_left = (0.18 - clamp(hsv.x, 0.16, 0.18)) / 0.02;\n     mediump float p2_right = 1.0 - (0.91 - clamp(hsv.x, 0.89, 0.91)) / 0.02;\n     mediump float p2_value = 1.0 - (0.3 - clamp(hsv.z, 0.2, 0.3)) / 0.1;\n     mediump float p2 = min(max(p2_left, p2_right), p2_value);\n     mediump float p = max(p1, p2);\n     mediump float kMin = diffFactor * p * varColor.b;\n     \n     lowp vec3 sColor = sharpenColor(iColor.rgb, iColor.rgb, sharpFactor * (1.0 - kMin));\n     \n     gl_FragColor = vec4(sColor, iColor.a);\n }\n";
  private static final String VERTEX_SHADER = "attribute vec4 position;\n attribute vec4 inputTextureCoordinate;\n \n uniform vec2 stepSize;\n \n varying vec2 textureCoordinate;\n varying vec2 textureCoordsLU;\n varying vec2 textureCoordsU;\n varying vec2 textureCoordsRU;\n varying vec2 textureCoordsL;\n varying vec2 textureCoordsR;\n varying vec2 textureCoordsLD;\n varying vec2 textureCoordsD;\n varying vec2 textureCoordsRD;\n \n void main()\n {\n     highp float stepX = stepSize.x;\n     highp float stepY = stepSize.y;\n     \n     gl_Position = position;\n     textureCoordinate = inputTextureCoordinate.xy;\n     textureCoordsLU = vec2(textureCoordinate.x-stepX, textureCoordinate.y+stepY);\n     textureCoordsU = vec2(textureCoordinate.x, textureCoordinate.y+stepY);\n     textureCoordsRU = vec2(textureCoordinate.x+stepX, textureCoordinate.y+stepY);\n     textureCoordsL = vec2(textureCoordinate.x-stepX, textureCoordinate.y);\n     textureCoordsR = vec2(textureCoordinate.x+stepX, textureCoordinate.y);\n     textureCoordsLD = vec2(textureCoordinate.x-stepX, textureCoordinate.y-stepY);\n     textureCoordsD = vec2(textureCoordinate.x, textureCoordinate.y-stepY);\n     textureCoordsRD = vec2(textureCoordinate.x+stepX, textureCoordinate.y-stepY);\n }\n";
  
  public RealTimeSmoothSharpenFilterV3()
  {
    super("attribute vec4 position;\n attribute vec4 inputTextureCoordinate;\n \n uniform vec2 stepSize;\n \n varying vec2 textureCoordinate;\n varying vec2 textureCoordsLU;\n varying vec2 textureCoordsU;\n varying vec2 textureCoordsRU;\n varying vec2 textureCoordsL;\n varying vec2 textureCoordsR;\n varying vec2 textureCoordsLD;\n varying vec2 textureCoordsD;\n varying vec2 textureCoordsRD;\n \n void main()\n {\n     highp float stepX = stepSize.x;\n     highp float stepY = stepSize.y;\n     \n     gl_Position = position;\n     textureCoordinate = inputTextureCoordinate.xy;\n     textureCoordsLU = vec2(textureCoordinate.x-stepX, textureCoordinate.y+stepY);\n     textureCoordsU = vec2(textureCoordinate.x, textureCoordinate.y+stepY);\n     textureCoordsRU = vec2(textureCoordinate.x+stepX, textureCoordinate.y+stepY);\n     textureCoordsL = vec2(textureCoordinate.x-stepX, textureCoordinate.y);\n     textureCoordsR = vec2(textureCoordinate.x+stepX, textureCoordinate.y);\n     textureCoordsLD = vec2(textureCoordinate.x-stepX, textureCoordinate.y-stepY);\n     textureCoordsD = vec2(textureCoordinate.x, textureCoordinate.y-stepY);\n     textureCoordsRD = vec2(textureCoordinate.x+stepX, textureCoordinate.y-stepY);\n }\n", "varying highp vec2 textureCoordinate;\n varying highp vec2 textureCoordsLU;\n varying highp vec2 textureCoordsU;\n varying highp vec2 textureCoordsRU;\n varying highp vec2 textureCoordsL;\n varying highp vec2 textureCoordsR;\n varying highp vec2 textureCoordsLD;\n varying highp vec2 textureCoordsD;\n varying highp vec2 textureCoordsRD;\n uniform sampler2D inputImageTexture;\n uniform sampler2D inputImageTexture2;\n uniform highp vec2 stepSize;\n uniform highp float sharpFactor;\n \n const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n \n lowp vec3 sharpenColor(lowp vec3 mixColor, lowp vec3 iColor, highp float mixAlpha) {\n     highp vec2 stepX_1 = vec2(stepSize.x, 0.0);\n     highp vec2 stepY_1 = vec2(0.0, stepSize.y);\n     highp vec2 stepX_2 = vec2(2.0 * stepSize.x, 0.0);\n     highp vec2 stepY_2 = vec2(0.0, 2.0 * stepSize.y);\n     \n     highp vec3 uColor = texture2D(inputImageTexture, textureCoordsU).rgb;\n     highp vec3 lColor = texture2D(inputImageTexture, textureCoordsL).rgb;\n     highp vec3 rColor = texture2D(inputImageTexture, textureCoordsR).rgb;\n     highp vec3 dColor = texture2D(inputImageTexture, textureCoordsD).rgb;\n     highp vec3 luColor = texture2D(inputImageTexture, textureCoordsLU).rgb;\n     highp vec3 ruColor = texture2D(inputImageTexture, textureCoordsRU).rgb;\n     highp vec3 ldColor = texture2D(inputImageTexture, textureCoordsLD).rgb;\n     highp vec3 rdColor = texture2D(inputImageTexture, textureCoordsRD).rgb;\n     \n     highp vec3 sumColor = vec3(0.0);//iColor.rgb;\n     sumColor += uColor;\n     sumColor += lColor;\n     sumColor += rColor;\n     sumColor += dColor;\n     sumColor += luColor;\n     sumColor += ruColor;\n     sumColor += ldColor;\n     sumColor += rdColor;\n     sumColor += texture2D(inputImageTexture, textureCoordinate+stepY_2).rgb;\n     sumColor += texture2D(inputImageTexture, textureCoordinate-stepX_2).rgb;\n     sumColor += texture2D(inputImageTexture, textureCoordinate+stepX_2).rgb;\n     sumColor += texture2D(inputImageTexture, textureCoordinate-stepY_2).rgb;\n     highp vec3 meanColor =  sumColor / 12.0;\n     \n     highp vec3 hPass = iColor.rgb - meanColor;\n     highp float iLum = dot(iColor, luminanceWeighting);\n     highp float mLum = dot((sumColor + iColor) / 13.0, luminanceWeighting);\n     highp float hFactor = pow(min(0.03125, abs(iLum - mLum)) / 0.03125, 2.0);\n     highp vec3 sColor = clamp((mixColor + hPass * hFactor * mixAlpha), vec3(0.0), vec3(1.0));\n     \n     return sColor;\n }\n \n lowp vec3 rgb2hsv(lowp vec3 c) {\n     lowp vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n     highp vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n     highp vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n     highp float d = q.x - min(q.w, q.y);\n     highp float e = 1.0e-10;\n     lowp vec3 hsv = vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n     return hsv;\n }\n \n void main() {\n     lowp vec4 iColor = texture2D(inputImageTexture, textureCoordinate);\n     lowp vec4 varColor = texture2D(inputImageTexture2, textureCoordinate);\n     \n     mediump float diffFactor = (1.0 - varColor.r / (varColor.r + 0.1));\n     lowp vec3 hsv = rgb2hsv(iColor.rgb);\n     mediump float p1 = clamp((iColor.r - 0.2) * 4.0, 0.0, 1.0);\n     mediump float p2_left = (0.18 - clamp(hsv.x, 0.16, 0.18)) / 0.02;\n     mediump float p2_right = 1.0 - (0.91 - clamp(hsv.x, 0.89, 0.91)) / 0.02;\n     mediump float p2_value = 1.0 - (0.3 - clamp(hsv.z, 0.2, 0.3)) / 0.1;\n     mediump float p2 = min(max(p2_left, p2_right), p2_value);\n     mediump float p = max(p1, p2);\n     mediump float kMin = diffFactor * p * varColor.b;\n     \n     lowp vec3 sColor = sharpenColor(iColor.rgb, iColor.rgb, sharpFactor * (1.0 - kMin));\n     \n     gl_FragColor = vec4(sColor, iColor.a);\n }\n");
    initParams();
  }
  
  private void initParams()
  {
    addParam(new UniformParam.Float2fParam("stepSize", 0.0009259259F, 0.0006944445F));
    addParam(new UniformParam.TextureParam("inputImageTexture2", 0, 33986));
    addParam(new UniformParam.FloatParam("sharpFactor", 0.7F));
  }
  
  public void setSharpenFactor(float paramFloat)
  {
    addParam(new UniformParam.FloatParam("sharpFactor", paramFloat));
  }
  
  public void setStepSize(float paramFloat1, float paramFloat2)
  {
    addParam(new UniformParam.Float2fParam("stepSize", paramFloat1, paramFloat2));
  }
  
  public void setVarianceMask(int paramInt)
  {
    addParam(new UniformParam.TextureParam("inputImageTexture2", paramInt, 33986));
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes15.jar
 * Qualified Name:     com.tencent.ttpic.filter.RealTimeSmoothSharpenFilterV3
 * JD-Core Version:    0.7.0.1
 */