package com.tencent.TMG.opengl.glrenderer;

import android.graphics.Bitmap;
import android.graphics.Rect;
import android.graphics.RectF;
import android.opengl.GLU;
import android.opengl.GLUtils;
import android.opengl.Matrix;
import android.util.Log;
import com.tencent.TMG.opengl.texture.BasicTexture;
import com.tencent.TMG.opengl.utils.IntArray;
import com.tencent.TMG.opengl.utils.Utils;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.util.ArrayList;
import javax.microedition.khronos.opengles.GL10;
import javax.microedition.khronos.opengles.GL11;
import javax.microedition.khronos.opengles.GL11Ext;
import junit.framework.Assert;

public class GLES11Canvas
  implements GLCanvas
{
  private static final float[] BOX_COORDINATES = { 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F, 0.0F, 0.0F, 1.0F, 1.0F, 0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F, 1.0F, 0.0F };
  private static final int MSCALE_X = 0;
  private static final int MSCALE_Y = 5;
  private static final int MSKEW_X = 4;
  private static final int MSKEW_Y = 1;
  private static final int OFFSET_DRAW_LINE = 4;
  private static final int OFFSET_DRAW_RECT = 6;
  private static final int OFFSET_FILL_RECT = 0;
  private static final float OPAQUE_ALPHA = 0.95F;
  private static final String TAG = "GLCanvasImp";
  private static GLId mGLId = new GLES11Id();
  private static float[] sCropRect = new float[4];
  private float mAlpha;
  private boolean mBlendEnabled = true;
  private int mBoxCoords;
  int mCountDrawLine;
  int mCountDrawMesh;
  int mCountFillRect;
  int mCountTextureOES;
  int mCountTextureRect;
  private final IntArray mDeleteBuffers = new IntArray();
  private final RectF mDrawTextureSourceRect = new RectF();
  private final RectF mDrawTextureTargetRect = new RectF();
  private GL11 mGL;
  private GLES11Canvas.GLState mGLState;
  private final float[] mMapPointsBuffer = new float[4];
  private final float[] mMatrixValues = new float[16];
  private GLES11Canvas.ConfigState mRecycledRestoreAction;
  private final ArrayList<GLES11Canvas.ConfigState> mRestoreStack = new ArrayList();
  private final float[] mTempMatrix = new float[32];
  private final float[] mTextureColor = new float[4];
  private final float[] mTextureMatrixValues = new float[16];
  private final IntArray mUnboundTextures = new IntArray();
  
  public GLES11Canvas(GL11 paramGL11)
  {
    this.mGL = paramGL11;
    this.mGLState = new GLES11Canvas.GLState(paramGL11);
    FloatBuffer localFloatBuffer = allocateDirectNativeOrderBuffer(BOX_COORDINATES.length * 32 / 8).asFloatBuffer();
    Object localObject = BOX_COORDINATES;
    localFloatBuffer.put((float[])localObject, 0, localObject.length).position(0);
    localObject = new int[1];
    mGLId.glGenBuffers(1, (int[])localObject, 0);
    this.mBoxCoords = localObject[0];
    paramGL11.glBindBuffer(34962, this.mBoxCoords);
    paramGL11.glBufferData(34962, localFloatBuffer.capacity() * 4, localFloatBuffer, 35044);
    paramGL11.glVertexPointer(2, 5126, 0, 0);
    paramGL11.glTexCoordPointer(2, 5126, 0, 0);
    paramGL11.glClientActiveTexture(33985);
    paramGL11.glTexCoordPointer(2, 5126, 0, 0);
    paramGL11.glClientActiveTexture(33984);
    paramGL11.glEnableClientState(32888);
  }
  
  private static ByteBuffer allocateDirectNativeOrderBuffer(int paramInt)
  {
    return ByteBuffer.allocateDirect(paramInt).order(ByteOrder.nativeOrder());
  }
  
  private boolean bindTexture(BasicTexture paramBasicTexture)
  {
    if (!paramBasicTexture.onBind(this)) {
      return false;
    }
    int i = paramBasicTexture.getTarget();
    this.mGLState.setTextureTarget(i);
    this.mGL.glBindTexture(i, paramBasicTexture.getId()[0]);
    return true;
  }
  
  private static void convertCoordinate(RectF paramRectF1, RectF paramRectF2, BasicTexture paramBasicTexture)
  {
    int i = paramBasicTexture.getTextureWidth();
    int j = paramBasicTexture.getTextureHeight();
    float f1 = paramRectF1.left;
    float f2 = i;
    paramRectF1.left = (f1 / f2);
    paramRectF1.right /= f2;
    f1 = paramRectF1.top;
    f2 = j;
    paramRectF1.top = (f1 / f2);
    paramRectF1.bottom /= f2;
  }
  
  private void drawBoundTexture(BasicTexture paramBasicTexture, int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    if (isMatrixRotatedOrFlipped(this.mMatrixValues))
    {
      setTextureCoords(0.0F, 0.0F, paramBasicTexture.getSourceWidth() / paramBasicTexture.getTextureWidth(), paramBasicTexture.getSourceHeight() / paramBasicTexture.getTextureHeight());
      textureRect(paramInt1, paramInt2, paramInt3, paramInt4);
      return;
    }
    paramBasicTexture = mapPoints(this.mMatrixValues, paramInt1, paramInt2 + paramInt4, paramInt1 + paramInt3, paramInt2);
    paramInt1 = (int)(paramBasicTexture[0] + 0.5F);
    paramInt2 = (int)(paramBasicTexture[1] + 0.5F);
    paramInt3 = (int)(paramBasicTexture[2] + 0.5F) - paramInt1;
    paramInt4 = (int)(paramBasicTexture[3] + 0.5F) - paramInt2;
    if ((paramInt3 > 0) && (paramInt4 > 0))
    {
      ((GL11Ext)this.mGL).glDrawTexiOES(paramInt1, paramInt2, 0, paramInt3, paramInt4);
      this.mCountTextureOES += 1;
    }
  }
  
  private void drawMixed(BasicTexture paramBasicTexture, int paramInt1, float paramFloat1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, float paramFloat2)
  {
    if (paramFloat1 <= 0.01F)
    {
      drawTexture(paramBasicTexture, paramInt2, paramInt3, paramInt4, paramInt5, paramFloat2);
      return;
    }
    if (paramFloat1 >= 1.0F)
    {
      fillRect(paramInt2, paramInt3, paramInt4, paramInt5, paramInt1);
      return;
    }
    GLES11Canvas.GLState localGLState = this.mGLState;
    boolean bool;
    if ((this.mBlendEnabled) && ((!paramBasicTexture.isOpaque()) || (!Utils.isOpaque(paramInt1)) || (paramFloat2 < 0.95F))) {
      bool = true;
    } else {
      bool = false;
    }
    localGLState.setBlendEnabled(bool);
    if (!bindTexture(paramBasicTexture)) {
      return;
    }
    this.mGLState.setTexEnvMode(34160);
    setMixedColor(paramInt1, paramFloat1, paramFloat2);
    drawBoundTexture(paramBasicTexture, paramInt2, paramInt3, paramInt4, paramInt5);
    this.mGLState.setTexEnvMode(7681);
  }
  
  private void drawTexture(BasicTexture paramBasicTexture, int paramInt1, int paramInt2, int paramInt3, int paramInt4, float paramFloat)
  {
    if (paramInt3 > 0)
    {
      if (paramInt4 <= 0) {
        return;
      }
      GLES11Canvas.GLState localGLState = this.mGLState;
      boolean bool;
      if ((this.mBlendEnabled) && ((!paramBasicTexture.isOpaque()) || (paramFloat < 0.95F))) {
        bool = true;
      } else {
        bool = false;
      }
      localGLState.setBlendEnabled(bool);
      if (!bindTexture(paramBasicTexture)) {
        return;
      }
      this.mGLState.setTextureAlpha(paramFloat);
      drawBoundTexture(paramBasicTexture, paramInt1, paramInt2, paramInt3, paramInt4);
    }
  }
  
  private void freeRestoreConfig(GLES11Canvas.ConfigState paramConfigState)
  {
    paramConfigState.mNextFree = this.mRecycledRestoreAction;
    this.mRecycledRestoreAction = paramConfigState;
  }
  
  private static boolean isMatrixRotatedOrFlipped(float[] paramArrayOfFloat)
  {
    float f = Math.abs(paramArrayOfFloat[4]);
    boolean bool = false;
    if ((f > 1.0E-005F) || (Math.abs(paramArrayOfFloat[1]) > 1.0E-005F) || (paramArrayOfFloat[0] < -1.0E-005F) || (paramArrayOfFloat[5] > 1.0E-005F)) {
      bool = true;
    }
    return bool;
  }
  
  private float[] mapPoints(float[] paramArrayOfFloat, int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    float[] arrayOfFloat = this.mMapPointsBuffer;
    float f1 = paramArrayOfFloat[0];
    float f2 = paramInt1;
    float f3 = paramArrayOfFloat[4];
    float f4 = paramInt2;
    float f5 = paramArrayOfFloat[12];
    float f6 = paramArrayOfFloat[1];
    float f7 = paramArrayOfFloat[5];
    float f8 = paramArrayOfFloat[13];
    float f9 = paramArrayOfFloat[3] * f2 + paramArrayOfFloat[7] * f4 + paramArrayOfFloat[15];
    arrayOfFloat[0] = ((f1 * f2 + f3 * f4 + f5) / f9);
    arrayOfFloat[1] = ((f6 * f2 + f7 * f4 + f8) / f9);
    f1 = paramArrayOfFloat[0];
    f2 = paramInt3;
    f3 = paramArrayOfFloat[4];
    f4 = paramInt4;
    f5 = paramArrayOfFloat[12];
    f6 = paramArrayOfFloat[1];
    f7 = paramArrayOfFloat[5];
    f8 = paramArrayOfFloat[13];
    f9 = paramArrayOfFloat[3] * f2 + paramArrayOfFloat[7] * f4 + paramArrayOfFloat[15];
    arrayOfFloat[2] = ((f1 * f2 + f3 * f4 + f5) / f9);
    arrayOfFloat[3] = ((f6 * f2 + f7 * f4 + f8) / f9);
    return arrayOfFloat;
  }
  
  private GLES11Canvas.ConfigState obtainRestoreConfig()
  {
    GLES11Canvas.ConfigState localConfigState = this.mRecycledRestoreAction;
    if (localConfigState != null)
    {
      this.mRecycledRestoreAction = localConfigState.mNextFree;
      return localConfigState;
    }
    return new GLES11Canvas.ConfigState(null);
  }
  
  private void restoreTransform()
  {
    System.arraycopy(this.mTempMatrix, 0, this.mMatrixValues, 0, 16);
  }
  
  private void saveTransform()
  {
    System.arraycopy(this.mMatrixValues, 0, this.mTempMatrix, 0, 16);
  }
  
  private void setMixedColor(int paramInt, float paramFloat1, float paramFloat2)
  {
    float f = (1.0F - paramFloat1) * paramFloat2;
    paramFloat1 = paramFloat2 * paramFloat1 / (1.0F - f) * (paramInt >>> 24) / 65025.0F;
    setTextureColor((paramInt >>> 16 & 0xFF) * paramFloat1, (paramInt >>> 8 & 0xFF) * paramFloat1, (paramInt & 0xFF) * paramFloat1, f);
    GL11 localGL11 = this.mGL;
    localGL11.glTexEnvfv(8960, 8705, this.mTextureColor, 0);
    localGL11.glTexEnvf(8960, 34161, 34165.0F);
    localGL11.glTexEnvf(8960, 34162, 34165.0F);
    localGL11.glTexEnvf(8960, 34177, 34166.0F);
    localGL11.glTexEnvf(8960, 34193, 768.0F);
    localGL11.glTexEnvf(8960, 34185, 34166.0F);
    localGL11.glTexEnvf(8960, 34201, 770.0F);
    localGL11.glTexEnvf(8960, 34178, 34166.0F);
    localGL11.glTexEnvf(8960, 34194, 770.0F);
    localGL11.glTexEnvf(8960, 34186, 34166.0F);
    localGL11.glTexEnvf(8960, 34202, 770.0F);
  }
  
  private void setTextureColor(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    float[] arrayOfFloat = this.mTextureColor;
    arrayOfFloat[0] = paramFloat1;
    arrayOfFloat[1] = paramFloat2;
    arrayOfFloat[2] = paramFloat3;
    arrayOfFloat[3] = paramFloat4;
  }
  
  private void setTextureCoords(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    this.mGL.glMatrixMode(5890);
    float[] arrayOfFloat = this.mTextureMatrixValues;
    arrayOfFloat[0] = (paramFloat3 - paramFloat1);
    arrayOfFloat[5] = (paramFloat4 - paramFloat2);
    arrayOfFloat[10] = 1.0F;
    arrayOfFloat[12] = paramFloat1;
    arrayOfFloat[13] = paramFloat2;
    arrayOfFloat[15] = 1.0F;
    this.mGL.glLoadMatrixf(arrayOfFloat, 0);
    this.mGL.glMatrixMode(5888);
  }
  
  private void setTextureCoords(RectF paramRectF)
  {
    setTextureCoords(paramRectF.left, paramRectF.top, paramRectF.right, paramRectF.bottom);
  }
  
  private void setTextureCoords(float[] paramArrayOfFloat)
  {
    this.mGL.glMatrixMode(5890);
    this.mGL.glLoadMatrixf(paramArrayOfFloat, 0);
    this.mGL.glMatrixMode(5888);
  }
  
  private void textureRect(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    GL11 localGL11 = this.mGL;
    saveTransform();
    translate(paramFloat1, paramFloat2);
    scale(paramFloat3, paramFloat4, 1.0F);
    localGL11.glLoadMatrixf(this.mMatrixValues, 0);
    localGL11.glDrawArrays(5, 0, 4);
    restoreTransform();
    this.mCountTextureRect += 1;
  }
  
  private int uploadBuffer(Buffer paramBuffer, int paramInt)
  {
    int[] arrayOfInt = new int[1];
    mGLId.glGenBuffers(arrayOfInt.length, arrayOfInt, 0);
    int i = arrayOfInt[0];
    this.mGL.glBindBuffer(34962, i);
    this.mGL.glBufferData(34962, paramBuffer.capacity() * paramInt, paramBuffer, 35044);
    return i;
  }
  
  public void clearBuffer()
  {
    this.mGL.glClearColor(0.0F, 0.0F, 0.0F, 1.0F);
    this.mGL.glClear(16384);
  }
  
  public void clearBuffer(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    this.mGL.glClearColor(paramFloat1, paramFloat2, paramFloat3, paramFloat4);
    this.mGL.glClear(16384);
  }
  
  public void deleteBuffer(int paramInt)
  {
    synchronized (this.mUnboundTextures)
    {
      this.mDeleteBuffers.add(paramInt);
      return;
    }
  }
  
  public void deleteRecycledResources()
  {
    synchronized (this.mUnboundTextures)
    {
      IntArray localIntArray2 = this.mUnboundTextures;
      if (localIntArray2.size() > 0)
      {
        mGLId.glDeleteTextures(this.mGL, localIntArray2.size(), localIntArray2.getInternalArray(), 0);
        localIntArray2.clear();
      }
      localIntArray2 = this.mDeleteBuffers;
      if (localIntArray2.size() > 0)
      {
        mGLId.glDeleteBuffers(this.mGL, localIntArray2.size(), localIntArray2.getInternalArray(), 0);
        localIntArray2.clear();
      }
      return;
    }
  }
  
  public void drawLine(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, GLPaint paramGLPaint)
  {
    GL11 localGL11 = this.mGL;
    this.mGLState.setColorMode(paramGLPaint.getColor(), this.mAlpha);
    this.mGLState.setLineWidth(paramGLPaint.getLineWidth());
    saveTransform();
    translate(paramFloat1, paramFloat2);
    scale(paramFloat3 - paramFloat1, paramFloat4 - paramFloat2, 1.0F);
    localGL11.glLoadMatrixf(this.mMatrixValues, 0);
    localGL11.glDrawArrays(3, 4, 2);
    restoreTransform();
    this.mCountDrawLine += 1;
  }
  
  public void drawMesh(BasicTexture paramBasicTexture, int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    float f = this.mAlpha;
    if (!bindTexture(paramBasicTexture)) {
      return;
    }
    GLES11Canvas.GLState localGLState = this.mGLState;
    boolean bool;
    if ((this.mBlendEnabled) && ((!paramBasicTexture.isOpaque()) || (f < 0.95F))) {
      bool = true;
    } else {
      bool = false;
    }
    localGLState.setBlendEnabled(bool);
    this.mGLState.setTextureAlpha(f);
    setTextureCoords(0.0F, 0.0F, 1.0F, 1.0F);
    saveTransform();
    translate(paramInt1, paramInt2);
    this.mGL.glLoadMatrixf(this.mMatrixValues, 0);
    this.mGL.glBindBuffer(34962, paramInt3);
    this.mGL.glVertexPointer(2, 5126, 0, 0);
    this.mGL.glBindBuffer(34962, paramInt4);
    this.mGL.glTexCoordPointer(2, 5126, 0, 0);
    this.mGL.glBindBuffer(34963, paramInt5);
    this.mGL.glDrawElements(5, paramInt6, 5121, 0);
    this.mGL.glBindBuffer(34962, this.mBoxCoords);
    this.mGL.glVertexPointer(2, 5126, 0, 0);
    this.mGL.glTexCoordPointer(2, 5126, 0, 0);
    restoreTransform();
    this.mCountDrawMesh += 1;
  }
  
  public void drawMixed(BasicTexture paramBasicTexture, int paramInt1, float paramFloat, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    drawMixed(paramBasicTexture, paramInt1, paramFloat, paramInt2, paramInt3, paramInt4, paramInt5, this.mAlpha);
  }
  
  public void drawMixed(BasicTexture paramBasicTexture, int paramInt, float paramFloat, RectF paramRectF1, RectF paramRectF2)
  {
    if (paramRectF2.width() > 0.0F)
    {
      if (paramRectF2.height() <= 0.0F) {
        return;
      }
      if (paramFloat <= 0.01F)
      {
        drawTexture(paramBasicTexture, paramRectF1, paramRectF2);
        return;
      }
      if (paramFloat >= 1.0F)
      {
        fillRect(paramRectF2.left, paramRectF2.top, paramRectF2.width(), paramRectF2.height(), paramInt);
        return;
      }
      float f = this.mAlpha;
      this.mDrawTextureSourceRect.set(paramRectF1);
      this.mDrawTextureTargetRect.set(paramRectF2);
      paramRectF1 = this.mDrawTextureSourceRect;
      paramRectF2 = this.mDrawTextureTargetRect;
      GLES11Canvas.GLState localGLState = this.mGLState;
      boolean bool;
      if ((this.mBlendEnabled) && ((!paramBasicTexture.isOpaque()) || (!Utils.isOpaque(paramInt)) || (f < 0.95F))) {
        bool = true;
      } else {
        bool = false;
      }
      localGLState.setBlendEnabled(bool);
      if (!bindTexture(paramBasicTexture)) {
        return;
      }
      this.mGLState.setTexEnvMode(34160);
      setMixedColor(paramInt, paramFloat, f);
      convertCoordinate(paramRectF1, paramRectF2, paramBasicTexture);
      setTextureCoords(paramRectF1);
      textureRect(paramRectF2.left, paramRectF2.top, paramRectF2.width(), paramRectF2.height());
      this.mGLState.setTexEnvMode(7681);
    }
  }
  
  public void drawRect(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, GLPaint paramGLPaint)
  {
    GL11 localGL11 = this.mGL;
    this.mGLState.setColorMode(paramGLPaint.getColor(), this.mAlpha);
    this.mGLState.setLineWidth(paramGLPaint.getLineWidth());
    saveTransform();
    translate(paramFloat1, paramFloat2);
    scale(paramFloat3, paramFloat4, 1.0F);
    localGL11.glLoadMatrixf(this.mMatrixValues, 0);
    localGL11.glDrawArrays(2, 6, 4);
    restoreTransform();
    this.mCountDrawLine += 1;
  }
  
  public void drawTexture(BasicTexture paramBasicTexture, int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    drawTexture(paramBasicTexture, paramInt1, paramInt2, paramInt3, paramInt4, this.mAlpha);
  }
  
  public void drawTexture(BasicTexture paramBasicTexture, RectF paramRectF1, RectF paramRectF2)
  {
    if (paramRectF2.width() > 0.0F)
    {
      if (paramRectF2.height() <= 0.0F) {
        return;
      }
      this.mDrawTextureSourceRect.set(paramRectF1);
      this.mDrawTextureTargetRect.set(paramRectF2);
      paramRectF1 = this.mDrawTextureSourceRect;
      paramRectF2 = this.mDrawTextureTargetRect;
      GLES11Canvas.GLState localGLState = this.mGLState;
      boolean bool;
      if ((this.mBlendEnabled) && ((!paramBasicTexture.isOpaque()) || (this.mAlpha < 0.95F))) {
        bool = true;
      } else {
        bool = false;
      }
      localGLState.setBlendEnabled(bool);
      if (!bindTexture(paramBasicTexture)) {
        return;
      }
      convertCoordinate(paramRectF1, paramRectF2, paramBasicTexture);
      setTextureCoords(paramRectF1);
      this.mGLState.setTextureAlpha(this.mAlpha);
      textureRect(paramRectF2.left, paramRectF2.top, paramRectF2.width(), paramRectF2.height());
    }
  }
  
  public void drawTexture(BasicTexture paramBasicTexture, float[] paramArrayOfFloat, int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    GLES11Canvas.GLState localGLState = this.mGLState;
    boolean bool;
    if ((this.mBlendEnabled) && ((!paramBasicTexture.isOpaque()) || (this.mAlpha < 0.95F))) {
      bool = true;
    } else {
      bool = false;
    }
    localGLState.setBlendEnabled(bool);
    if (!bindTexture(paramBasicTexture)) {
      return;
    }
    setTextureCoords(paramArrayOfFloat);
    this.mGLState.setTextureAlpha(this.mAlpha);
    textureRect(paramInt1, paramInt2, paramInt3, paramInt4);
  }
  
  public void dumpStatisticsAndClear()
  {
    String str = String.format("MESH:%d, TEX_OES:%d, TEX_RECT:%d, FILL_RECT:%d, LINE:%d", new Object[] { Integer.valueOf(this.mCountDrawMesh), Integer.valueOf(this.mCountTextureRect), Integer.valueOf(this.mCountTextureOES), Integer.valueOf(this.mCountFillRect), Integer.valueOf(this.mCountDrawLine) });
    this.mCountDrawMesh = 0;
    this.mCountTextureRect = 0;
    this.mCountTextureOES = 0;
    this.mCountFillRect = 0;
    this.mCountDrawLine = 0;
    Log.d("GLCanvasImp", str);
  }
  
  public void fillRect(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, int paramInt)
  {
    this.mGLState.setColorMode(paramInt, this.mAlpha);
    GL11 localGL11 = this.mGL;
    saveTransform();
    translate(paramFloat1, paramFloat2);
    scale(paramFloat3, paramFloat4, 1.0F);
    localGL11.glLoadMatrixf(this.mMatrixValues, 0);
    localGL11.glDrawArrays(5, 0, 4);
    restoreTransform();
    this.mCountFillRect += 1;
  }
  
  public float getAlpha()
  {
    return this.mAlpha;
  }
  
  public void getBounds(Rect paramRect, int paramInt1, int paramInt2, int paramInt3, int paramInt4) {}
  
  public GLId getGLId()
  {
    return mGLId;
  }
  
  public void initializeTexture(BasicTexture paramBasicTexture, Bitmap paramBitmap)
  {
    int i = paramBasicTexture.getTarget();
    this.mGL.glBindTexture(i, paramBasicTexture.getId()[0]);
    GLUtils.texImage2D(i, 0, paramBitmap, 0);
  }
  
  public void initializeTextureSize(BasicTexture paramBasicTexture, int paramInt1, int paramInt2)
  {
    int i = paramBasicTexture.getTarget();
    this.mGL.glBindTexture(i, paramBasicTexture.getId()[0]);
    int j = paramBasicTexture.getTextureWidth();
    int k = paramBasicTexture.getTextureHeight();
    this.mGL.glTexImage2D(i, 0, paramInt1, j, k, 0, paramInt1, paramInt2, null);
  }
  
  public void multiplyAlpha(float paramFloat)
  {
    boolean bool;
    if ((paramFloat >= 0.0F) && (paramFloat <= 1.0F)) {
      bool = true;
    } else {
      bool = false;
    }
    Assert.assertTrue(bool);
    this.mAlpha *= paramFloat;
  }
  
  public void multiplyMatrix(float[] paramArrayOfFloat, int paramInt)
  {
    float[] arrayOfFloat = this.mTempMatrix;
    Matrix.multiplyMM(arrayOfFloat, 0, this.mMatrixValues, 0, paramArrayOfFloat, paramInt);
    System.arraycopy(arrayOfFloat, 0, this.mMatrixValues, 0, 16);
  }
  
  public void recoverFromLightCycle() {}
  
  public void restore()
  {
    if (!this.mRestoreStack.isEmpty())
    {
      Object localObject = this.mRestoreStack;
      localObject = (GLES11Canvas.ConfigState)((ArrayList)localObject).remove(((ArrayList)localObject).size() - 1);
      ((GLES11Canvas.ConfigState)localObject).restore(this);
      freeRestoreConfig((GLES11Canvas.ConfigState)localObject);
      return;
    }
    throw new IllegalStateException();
  }
  
  public void rotate(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    if (paramFloat1 == 0.0F) {
      return;
    }
    float[] arrayOfFloat = this.mTempMatrix;
    Matrix.setRotateM(arrayOfFloat, 0, paramFloat1, paramFloat2, paramFloat3, paramFloat4);
    Matrix.multiplyMM(arrayOfFloat, 16, this.mMatrixValues, 0, arrayOfFloat, 0);
    System.arraycopy(arrayOfFloat, 16, this.mMatrixValues, 0, 16);
  }
  
  public void save()
  {
    save(-1);
  }
  
  public void save(int paramInt)
  {
    GLES11Canvas.ConfigState localConfigState = obtainRestoreConfig();
    if ((paramInt & 0x1) != 0) {
      localConfigState.mAlpha = this.mAlpha;
    } else {
      localConfigState.mAlpha = -1.0F;
    }
    if ((paramInt & 0x2) != 0) {
      System.arraycopy(this.mMatrixValues, 0, localConfigState.mMatrix, 0, 16);
    } else {
      localConfigState.mMatrix[0] = (1.0F / -1.0F);
    }
    this.mRestoreStack.add(localConfigState);
  }
  
  public void scale(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    Matrix.scaleM(this.mMatrixValues, 0, paramFloat1, paramFloat2, paramFloat3);
  }
  
  public void setAlpha(float paramFloat)
  {
    boolean bool;
    if ((paramFloat >= 0.0F) && (paramFloat <= 1.0F)) {
      bool = true;
    } else {
      bool = false;
    }
    Assert.assertTrue(bool);
    this.mAlpha = paramFloat;
  }
  
  public void setSize(int paramInt1, int paramInt2)
  {
    boolean bool;
    if ((paramInt1 >= 0) && (paramInt2 >= 0)) {
      bool = true;
    } else {
      bool = false;
    }
    Assert.assertTrue(bool);
    this.mAlpha = 1.0F;
    Object localObject = this.mGL;
    ((GL11)localObject).glViewport(0, 0, paramInt1, paramInt2);
    ((GL11)localObject).glMatrixMode(5889);
    ((GL11)localObject).glLoadIdentity();
    float f1 = paramInt1;
    float f2 = paramInt2;
    GLU.gluOrtho2D((GL10)localObject, 0.0F, f1, 0.0F, f2);
    ((GL11)localObject).glMatrixMode(5888);
    ((GL11)localObject).glLoadIdentity();
    localObject = this.mMatrixValues;
    Matrix.setIdentityM((float[])localObject, 0);
    Matrix.translateM((float[])localObject, 0, 0.0F, f2, 0.0F);
    Matrix.scaleM((float[])localObject, 0, 1.0F, -1.0F, 1.0F);
  }
  
  public void setTextureParameters(BasicTexture paramBasicTexture)
  {
    int i = paramBasicTexture.getSourceWidth();
    int j = paramBasicTexture.getSourceHeight();
    float[] arrayOfFloat = sCropRect;
    arrayOfFloat[0] = 0.0F;
    arrayOfFloat[1] = j;
    arrayOfFloat[2] = i;
    arrayOfFloat[3] = (-j);
    i = paramBasicTexture.getTarget();
    this.mGL.glBindTexture(i, paramBasicTexture.getId()[0]);
    this.mGL.glTexParameterfv(i, 35741, sCropRect, 0);
    this.mGL.glTexParameteri(i, 10242, 33071);
    this.mGL.glTexParameteri(i, 10243, 33071);
    this.mGL.glTexParameterf(i, 10241, 9729.0F);
    this.mGL.glTexParameterf(i, 10240, 9729.0F);
  }
  
  public void texSubImage2D(BasicTexture paramBasicTexture, int paramInt1, int paramInt2, Bitmap paramBitmap, int paramInt3, int paramInt4)
  {
    int i = paramBasicTexture.getTarget();
    this.mGL.glBindTexture(i, paramBasicTexture.getId()[0]);
    GLUtils.texSubImage2D(i, 0, paramInt1, paramInt2, paramBitmap, paramInt3, paramInt4);
  }
  
  public void translate(float paramFloat1, float paramFloat2)
  {
    float[] arrayOfFloat = this.mMatrixValues;
    arrayOfFloat[12] += arrayOfFloat[0] * paramFloat1 + arrayOfFloat[4] * paramFloat2;
    arrayOfFloat[13] += arrayOfFloat[1] * paramFloat1 + arrayOfFloat[5] * paramFloat2;
    arrayOfFloat[14] += arrayOfFloat[2] * paramFloat1 + arrayOfFloat[6] * paramFloat2;
    arrayOfFloat[15] += arrayOfFloat[3] * paramFloat1 + arrayOfFloat[7] * paramFloat2;
  }
  
  public void translate(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    Matrix.translateM(this.mMatrixValues, 0, paramFloat1, paramFloat2, paramFloat3);
  }
  
  public boolean unloadTexture(BasicTexture paramBasicTexture)
  {
    synchronized (this.mUnboundTextures)
    {
      if (!paramBasicTexture.isLoaded()) {
        return false;
      }
      this.mUnboundTextures.add(paramBasicTexture.getId()[0]);
      return true;
    }
  }
  
  public int uploadBuffer(ByteBuffer paramByteBuffer)
  {
    return uploadBuffer(paramByteBuffer, 1);
  }
  
  public int uploadBuffer(FloatBuffer paramFloatBuffer)
  {
    return uploadBuffer(paramFloatBuffer, 4);
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes2.jar
 * Qualified Name:     com.tencent.TMG.opengl.glrenderer.GLES11Canvas
 * JD-Core Version:    0.7.0.1
 */