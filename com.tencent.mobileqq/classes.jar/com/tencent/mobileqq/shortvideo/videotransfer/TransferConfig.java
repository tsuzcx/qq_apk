package com.tencent.mobileqq.shortvideo.videotransfer;

public class TransferConfig
{
  private static final String FRAGMENT_SHADER_BLUR = "precision highp float;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nvarying highp vec2 singleStepOffset;\nconst int GAUSSIAN_WEIGHT_NUMBERS = 21;\nuniform float weight[GAUSSIAN_WEIGHT_NUMBERS]; \nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getBlur(float time, sampler2D texture, vec2 coordinate){\n    vec3 sum = vec3(0.0);\n    vec4 fragColor=texture2D(texture,coordinate);\n    sum += texture2D(texture, coordinate.xy).rgb * weight[0];\n\n    for (int i = 1; i <= GAUSSIAN_WEIGHT_NUMBERS; i++) {\n        vec2 blurCoordinate1 = textureCoordinate.xy + singleStepOffset*float(i)* time; \n        vec2 blurCoordinate2 = textureCoordinate.xy - singleStepOffset*float(i)* time; \n        sum += texture2D(texture, blurCoordinate1).rgb * weight[i];\n        sum += texture2D(texture, blurCoordinate2).rgb * weight[i];\n    }\n    return vec4(sum,fragColor.a);\n}void main()\n{\n   float animationTime = getAnimationTime();\n   if (animationTime > 0.0 && animationTime < 0.99) {\n       vec4 c1 = vec4(0.0);\n       vec4 c2 = vec4(0.0);\n       if(animationTime>0.0 && animationTime<=0.4){\n           c2 = getBlur(smoothstep(0.0 , 0.4, animationTime), inputImageTexture2, textureCoordinate);\n           gl_FragColor = c2;\n       }else{\n           c2 = getBlur(smoothstep(0.0 , 0.4, animationTime), inputImageTexture2, textureCoordinate);\n           c1 = getBlur(1.0-smoothstep(0.4 , 0.99, animationTime), inputImageTexture, textureCoordinate);\n           gl_FragColor = vec4(mix(c2.rgb, c1.rgb, smoothstep(0.4 , 0.99, animationTime)),1.0);\n       }    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}";
  private static final String FRAGMENT_SHADER_ERASE = "\n//输入参数\n// @param: duration：1.0s\n\nprecision highp float;\n\nvarying vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\nuniform vec2 inputImageTextureSize;\n\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTexture2Size;\n\nuniform vec3 iResolution;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nfloat TextureChangeTime = 0.4;\nfloat ImageRepeatCount1 = 0.4;\nfloat ImageRepeatCount2 = 2.0;\nfloat SpeedPowValue = 5.0;\nfloat MinimaxBlurMaxStrength1 = 0.2;\nfloat MinimaxBlurMaxStrength2 = 0.08;\nfloat RGBShiftMaxStrength = 0.005;\nfloat RGBShiftSpeedPowValue = 2.0;\nfloat SampleNumber = 20.0;\n\nmat4 blurStripYBegin1 =  mat4(0.0, 0.0, 0.0, 0.0,\n                              0.3, 0.2, 0.4, 0.35,\n                              0.6, 0.5, 0.6, 0.40,\n                              0.8, 0.7, 0.8, 0.7);\n\nmat4 blurStripYBegin2 =  mat4(0.0, 0.1, 0.0, 0.0,\n                              0.5, 0.15, 0.3, 0.10,\n                              0.6, 0.45, 0.5, 0.50,\n                              0.8, 0.7, 0.8, 0.85);\n\nmat4 blurStripYBegin3 =  mat4(0.2, 0.1, 0.0, 0.0,\n                              0.4, 0.4, 0.4, 0.35,\n                              0.45, 0.55, 0.6, 0.55,\n                              0.7, 0.7, 0.8, 0.8);\n\nmat4 blurStripYLength1 = mat4(0.05, 0.2, 0.2, 0.3,\n                              0.2, 0.3, 0.2, 0.3,\n                              0.3, 0.2, 0.3, 0.4,\n                              0.1, 0.25, 0.2, 0.3);\n\nmat4 blurStripYLength2 = mat4(0.3, 0.2, 0.2, 0.3,\n                              0.2, 0.3, 0.2, 0.3,\n                              0.05, 0.2, 0.3, 0.4,\n                              0.2, 0.3, 0.2, 0.3);\n\nmat4 blurStripYLength3 = mat4(0.1, 0.2, 0.2, 0.3,\n                              0.3, 0.2, 0.2, 0.3,\n                              0.05, 0.2, 0.3, 0.4,\n                              0.3, 0.2, 0.2, 0.3);\n\nmat4 blurStripXBegin =   mat4(0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0);\n\nmat4 blurStripXLength = mat4(1.0, 1.0, 1.0, 1.0,\n                             1.0, 1.0, 1.0, 1.0,\n                             1.0, 1.0, 1.0, 1.0,\n                             1.0, 1.0, 1.0, 1.0);\n\nmat4 blurStripValue1 =   mat4(1.0, -1.0, 1.0, 1.0,\n                             -1.0, -1.0, -1.0, -1.0,\n                              1.0, 1.0, -1.0, 1.0,\n                             -1.0, -1.0, 1.0, 1.0);\n\nmat4 blurStripValue2 =   mat4(1.0, 1.0, -1.0, 1.0,\n                             -1.0, -1.0, 1.0, -1.0,\n                             -1.0, 1.0, -1.0, 1.0,\n                              1.0, 1.0, 1.0, 1.0);\n\nmat4 blurStripValue3 =   mat4(-1.0, -1.0, -1.0, 1.0,\n                              1.0, -1.0, 1.0, -1.0,\n                              -1.0, 1.0, -1.0, 1.0,\n                              1.0, -1.0, 1.0, -1.0);\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nfloat adjustTextureCoordinateIfOutOfRange(float coordinateValue)\n{\n    float adjustValue = mod(abs(coordinateValue), 2.0);\n    if (adjustValue > 1.0)\n        adjustValue =  2.0 - adjustValue;\n    return adjustValue;\n}\n\nvec2 getImageTextureSize(float animationTime)\n{\n    //return iResolution.xy;\n    if (animationTime < TextureChangeTime)\n        return inputImageTexture2Size;\n    else\n        return inputImageTextureSize;\n}\n\nfloat getMinimaxBlurMaxStrength(float animationTime)\n{\n    if (animationTime < TextureChangeTime)\n        return MinimaxBlurMaxStrength1;\n    else\n        return MinimaxBlurMaxStrength2;\n}\n\n//滚动\n\nvec2 getScroll(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 outputTextureCoordinate = inputTextureCoordinate;\n    if (animationTime < TextureChangeTime)\n        outputTextureCoordinate.x += pow(animationTime, SpeedPowValue) * pow(1.0/TextureChangeTime, SpeedPowValue) * ImageRepeatCount1;\n    else\n        outputTextureCoordinate.x += pow((1.0 - animationTime), SpeedPowValue) * pow(1.0/(1.0-TextureChangeTime), SpeedPowValue) * ImageRepeatCount2 * (-1.0);\n    return outputTextureCoordinate;\n}\n\n//Color\n\nvec4 getColor(sampler2D imageTexture, vec2 inputTextureCoordinate)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    textureCoordinateUse.x = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.x);\n    textureCoordinateUse.y = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.y);\n    return texture2D(imageTexture, textureCoordinateUse);\n}\n\nvec4 getColorWithRGBShift(sampler2D imageTexture, vec2 inputTextureCoordinate, float animationTime)\n{\n    float shiftTime = animationTime;\n    if (animationTime > TextureChangeTime)\n        shiftTime = 1.0 - animationTime;\n    vec2 shiftCoord = inputTextureCoordinate;\n    shiftCoord.x += pow(shiftTime, RGBShiftSpeedPowValue) * pow(2.0, RGBShiftSpeedPowValue) * RGBShiftMaxStrength;\n    vec4 colorR = getColor(imageTexture, shiftCoord);\n    vec4 colorGB = getColor(imageTexture, inputTextureCoordinate);\n    return vec4(colorR.r, colorGB.g, colorGB.b, 1.0);\n}\n\n//Minimax模糊\n\nfloat rand(vec2 inputTextureCoordinate)\n{\n    return fract(sin(dot(inputTextureCoordinate.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat brightOfColor(vec4 color)\n{\n    return color.r + color.g + color.b;\n}\n\nvec4 maxBrightColor(vec4 color1, vec4 color2)\n{\n    if (brightOfColor(color1) > brightOfColor(color2))\n        return color1;\n    else\n        return color2;\n}\n\nvec4 minBrightColor(vec4 color1, vec4 color2)\n{\n    if (brightOfColor(color1) > brightOfColor(color2))\n        return color2;\n    else\n        return color1;\n}\n\nvec4 maxValueBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed, float animationTime)\n{\n    float imageSideLength = getImageTextureSize(animationTime).x;\n    vec2 blurStrength = getMinimaxBlurMaxStrength(animationTime) * speed;\n    float sampleRatio = float(ceil((imageSideLength * abs(blurStrength.x)) / SampleNumber));\n    sampleRatio = max(sampleRatio, 1.0);\n    vec4 maxColor = vec4(0.0);\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= SampleNumber; t++) {\n        float percent = (t + offset) / SampleNumber;\n        vec2 sampleCoord = inputTextureCoordinate + blurStrength * percent;\n        sampleCoord.x = floor(sampleCoord.x * imageSideLength / sampleRatio) * sampleRatio / imageSideLength;\n        sampleCoord.y = inputTextureCoordinate.y;\n        maxColor = maxBrightColor(maxColor, getColorWithRGBShift(imageTexture, sampleCoord, animationTime));\n    }\n    return maxColor;\n}\n\nvec4 minValueBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed, float animationTime)\n{\n    float imageSideLength = getImageTextureSize(animationTime).x;\n    vec2 blurStrength = getMinimaxBlurMaxStrength(animationTime) * speed;\n    float sampleRatio = float(ceil((imageSideLength * abs(blurStrength.x)) / SampleNumber));\n    sampleRatio = max(sampleRatio, 1.0);\n    vec4 minColor = vec4(1.0);\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= SampleNumber; t++) {\n    float percent = (t + offset) / SampleNumber;\n        vec2 sampleCoord = inputTextureCoordinate + blurStrength * percent;\n        sampleCoord.x = floor(sampleCoord.x * imageSideLength / sampleRatio) * sampleRatio / imageSideLength;\n        sampleCoord.y = inputTextureCoordinate.y;\n        minColor = minBrightColor(minColor, getColorWithRGBShift(imageTexture, sampleCoord, animationTime));\n    }\n    return minColor;\n}\n\nfloat getMaskValue(vec2 textureCoordinate,  float animationTime)\n{\n    float maskTime = animationTime;\n    if (maskTime > TextureChangeTime)\n        maskTime = 1.0 - maskTime;\n\n    int timeIndex = int(floor(maskTime * 2.0 * 4.0));\n    if (timeIndex > 3)\n        timeIndex = 3;\n\n    int matIndex = int(floor(fract(textureCoordinate.y / 0.5) * 2.0 * 3.0));\n    mat4 blurStripYBegin = blurStripYBegin1;\n    mat4 blurStripValue = blurStripValue1;\n    mat4 blurStripYLength = blurStripYLength1;\n    if (matIndex == 1) {\n        blurStripYBegin = blurStripYBegin2;\n        blurStripYLength = blurStripYLength2;\n        blurStripValue = blurStripValue2;\n    } else if (matIndex == 2) {\n        blurStripYBegin = blurStripYBegin3;\n        blurStripYLength = blurStripYLength3;\n        blurStripValue = blurStripValue3;\n    }\n\n    float yOffset = fract(textureCoordinate.y * 2.0 * 3.0);\n\n    int rowIndex = -1;\n    for (int i = 0; i < 4; i++) {\n    float yBeign = blurStripYBegin[i][timeIndex];\n    if (yOffset < yBeign)\n        break;\n    else\n        rowIndex = i;\n    }\n\n    if (rowIndex < 0)\n        return 0.0;\n\n    float stripEnd = blurStripYBegin[rowIndex][timeIndex] + blurStripYLength[rowIndex][timeIndex];\n    if (yOffset < blurStripYBegin[rowIndex][timeIndex] + blurStripYLength[rowIndex][timeIndex] && textureCoordinate.x > blurStripXBegin[rowIndex][timeIndex] && textureCoordinate.x < blurStripXBegin[rowIndex][timeIndex] + blurStripXLength[rowIndex][timeIndex])\n        return blurStripValue[rowIndex][timeIndex];\n    else\n        return 0.0;\n}\n\nvec4 minimaxBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 originTextureCoordinate, vec2 speed, float animationTime)\n{\n    int maskValue = int(getMaskValue(originTextureCoordinate, animationTime));\n    if (maskValue > 0) {\n        return maxValueBlur(imageTexture, inputTextureCoordinate, speed, animationTime);\n    } else if (maskValue < 0) {\n        return minValueBlur(imageTexture, inputTextureCoordinate, speed * 0.25, animationTime);\n    } else {\n        return maxValueBlur(imageTexture, inputTextureCoordinate, speed * 0.25, animationTime);\n    }\n}\n\n//main\n\nvoid main()\n{\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n        vec2 textureCoordinateUse = textureCoordinate ;\n        textureCoordinateUse = getScroll(textureCoordinateUse, animationTime);\n        \n        float timeInterval = 0.0001;\n        if (animationTime < TextureChangeTime && animationTime + timeInterval > TextureChangeTime)\n            timeInterval = TextureChangeTime - animationTime;\n        \n        vec2 textureCoordinateNext = getScroll(textureCoordinate, animationTime - timeInterval);\n        vec2 speed = (textureCoordinateNext - textureCoordinateUse) / timeInterval;\n        \n        if (animationTime < TextureChangeTime)\n            gl_FragColor = minimaxBlur(inputImageTexture2, textureCoordinateUse, textureCoordinate, speed, animationTime);\n        else\n            gl_FragColor = minimaxBlur(inputImageTexture, textureCoordinateUse, textureCoordinate, speed, animationTime);\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n";
  private static final String FRAGMENT_SHADER_FADE = "precision highp float;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTextureSize;\nuniform vec2 inputImageTexture2Size;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nvarying vec2 textureCoordinate;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvoid main()\n{\n   float animationTime = getAnimationTime();\n   if (animationTime > 0.0) {\n       vec4 textureColor1 = texture2D(inputImageTexture, textureCoordinate);\n       vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate);\n       gl_FragColor = vec4(mix(textureColor2.rgb, textureColor1.rgb, animationTime), 1.0);\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}";
  private static final String FRAGMENT_SHADER_FADE2 = "precision highp float;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTextureSize;\nuniform vec2 inputImageTexture2Size;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nvarying vec2 textureCoordinate;\nconst int passes = 6;\nfloat intensity = 0.02;\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getBlur(float time, sampler2D texture, vec2 coordinate){\n   vec4 c1 = vec4(0.0);\n   float disp = intensity*time;\n   for (int xi=0; xi<passes; xi++)\n    {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++)\n        {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D( texture, coordinate + d*v);\n        }\n    }\n   c1 /= float(passes*passes);\n   return c1;\n}void main()\n{\n   float animationTime = getAnimationTime();\n   if (animationTime > 0.0 && animationTime < 0.99) {\n       vec4 c1 = vec4(0.0);\n       vec4 c2 = vec4(0.0);\n       if(animationTime>0.0 && animationTime<=0.4){\n           c2 = getBlur(smoothstep(0.0 , 0.4, animationTime), inputImageTexture2, textureCoordinate);\n           gl_FragColor = c2;\n       }else{\n           c2 = getBlur(smoothstep(0.0 , 0.4, animationTime), inputImageTexture2, textureCoordinate);\n           c1 = getBlur(1.0-smoothstep(0.4 , 0.99, animationTime), inputImageTexture, textureCoordinate);\n           gl_FragColor = vec4(mix(c2.rgb, c1.rgb, smoothstep(0.4 , 0.99, animationTime)),1.0);\n       }    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}";
  private static final String FRAGMENT_SHADER_FADE_BLACK = "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nvec3 color = vec3(0.0);\nfloat colorPhase = 0.4 ; \n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, uv);\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  return mix(\n    mix(vec4(color, 1.0), fromCol, smoothstep(1.0-colorPhase, 0.0, time)),\n    mix(vec4(color, 1.0), toCol, smoothstep(colorPhase, 1.0, time)),\n    time);\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}";
  private static final String FRAGMENT_SHADER_FILTER_CUT = "precision mediump float;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nuniform vec4 commonParamVec4;\nint motionDirection = 1; //1=左,2=右\nconst float scale = 0.04;\n\n//F-滤镜参数\n\nconst mat4 F_FilterColorMapIn =  mat4(0.0, 100.0, 200.0, 250.0,\n                                      0.0, 39.0, 92.0, 184.0,\n                                      0.0, 114.0, 198.0, 254.0,\n                                      0.0, 90.0, 205.0, 254.0);\n\nconst mat4 F_FilterColorMapOut =  mat4(0.0, 100.0, 200.0, 250.0,\n                                       0.0, 40.0, 119.0, 210.0,\n                                       6.0, 118.0, 213.0, 254.0,\n                                       0.0, 120.0, 227.0, 254.0);\n\n//iOS\n//const mat4 F_FilterColorMapIn =  mat4(0.0, 33.0, 111.0, 208.0,\n//                                      0.0, 39.0, 99.0, 182.0,\n//                                      0.0, 123.0, 208.0, 254.0,\n//                                      0.0, 115.0, 205.0, 254.0);\n//\n//const mat4 F_FilterColorMapOut =  mat4(22.0, 33.0, 161.0, 226.0,\n//                                       0.0, 40.0, 113.0, 229.0,\n//                                       4.0, 112.0, 214.0, 254.0,\n//                                       0.0, 135.0, 227.0, 254.0);\n\n//草木绿-滤镜参数\n\nconst mat4 GrassGreen_FilterColorMapIn =  mat4(0.0, 100.0, 200.0, 250.0,\n                                               0.0, 50.0, 200.0, 254.0,\n                                               0.0, 28.0, 103.0, 189.0,\n                                               0.0, 8.0, 54.0, 149.0);\n\nconst mat4 GrassGreen_FilterColorMapOut =  mat4(0.0, 100.0, 200.0, 250.0,\n                                                0.0, 50.0, 200.0, 254.0,\n                                                14.0, 31.0, 128.0, 198.0,\n                                                0.0, 17.0, 54.0, 164.0);\n\n//iOS\n//const mat4 GrassGreen_FilterColorMapIn =  mat4(0.0, 10.0, 37.0, 122.0,\n//                                               0.0, 50.0, 200.0, 254.0,\n//                                               0.0, 28.0, 103.0, 189.0,\n//                                               0.0, 8.0, 54.0, 149.0);\n//\n//const mat4 GrassGreen_FilterColorMapOut =  mat4(19.0, 19.0, 40.0, 141.0,\n//                                                0.0, 50.0, 200.0, 254.0,\n//                                                14.0, 31.0, 128.0, 198.0,\n//                                                0.0, 17.0, 54.0, 164.0);\n\nfloat calculateColor(float colorIn1, float colorOut1, float colorIn2, float colorOut2, float sourceColorIn255)\n{\n    return colorOut1 + (sourceColorIn255 - colorIn1) * (colorOut2 - colorOut1) / (colorIn2 - colorIn1);\n}\n\nfloat replaceColor(vec4 colorMapIn, vec4 colorMapOut, float sourceColorIn255)\n{\n    if (sourceColorIn255 < colorMapIn[1]) {\n        return calculateColor(colorMapIn[0], colorMapOut[0], colorMapIn[1], colorMapOut[1], sourceColorIn255);\n    } else if (sourceColorIn255 < colorMapIn[2]) {\n        return calculateColor(colorMapIn[1], colorMapOut[1], colorMapIn[2], colorMapOut[2], sourceColorIn255);\n    } else if (sourceColorIn255 < colorMapIn[3]) {\n        return calculateColor(colorMapIn[2], colorMapOut[2], colorMapIn[3], colorMapOut[3], sourceColorIn255);\n    } else {\n        return calculateColor(colorMapIn[3], colorMapOut[3], 255.0, 255.0, sourceColorIn255);\n    }\n}\n\n//滤镜F\nvec4 colorFilter1(vec4 sourceColor)\n{\n    vec4 resultColor = sourceColor * 255.0;\n    \n    //R通道\n    resultColor[0] = replaceColor(F_FilterColorMapIn[1], F_FilterColorMapOut[1], resultColor[0]);\n    //resultColor[0] = replaceColor(F_FilterColorMapIn[0], F_FilterColorMapOut[0], resultColor[0]);\n    \n    //G通道\n    resultColor[1] = replaceColor(F_FilterColorMapIn[2], F_FilterColorMapOut[2], resultColor[1]);\n    //resultColor[1] = replaceColor(F_FilterColorMapIn[0], F_FilterColorMapOut[0], resultColor[1]);\n    \n    //B通道\n    resultColor[2] = replaceColor(F_FilterColorMapIn[3], F_FilterColorMapOut[3], resultColor[2]);\n    //resultColor[2] = replaceColor(F_FilterColorMapIn[0], F_FilterColorMapOut[0], resultColor[2]);\n    \n    return resultColor / 255.0;\n}\n\n//滤镜草木绿\nvec4 colorFilter2(vec4 sourceColor)\n{\n    vec4 resultColor = sourceColor * 255.0;\n    \n    //R通道\n    //resultColor[0] = replaceColor(GrassGreen_FilterColorMapIn[0], GrassGreen_FilterColorMapOut[0], resultColor[0]);\n    \n    //G通道\n    resultColor[1] = replaceColor(GrassGreen_FilterColorMapIn[2], GrassGreen_FilterColorMapOut[2], resultColor[1]);\n    //resultColor[1] = replaceColor(GrassGreen_FilterColorMapIn[0], GrassGreen_FilterColorMapOut[0], resultColor[1]);\n    \n    //B通道\n    resultColor[2] = replaceColor(GrassGreen_FilterColorMapIn[3], GrassGreen_FilterColorMapOut[3], resultColor[2]);\n    //resultColor[2] = replaceColor(GrassGreen_FilterColorMapIn[0], GrassGreen_FilterColorMapOut[0], resultColor[2]);\n    \n    return resultColor / 255.0;\n}\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec2 zoom(vec2 uv, float amount, vec2 move) {\n    return 0.5 + ((uv - 0.5) * (1.0-amount)) + move;\n}\n\nvec4 getCutColRev(float time)\n{\n    vec4 col;\n    //line1 y=-6x+b\n    float dis = 28.0 * time;\n    float d = (1.0 - textureCoordinate.y) - (-6.0 * textureCoordinate.x + dis);\n    if (d > 0.0) {\n        vec4 textureColor = texture2D(inputImageTexture2, textureCoordinate);\n        vec4 s = mix(vec4(0.0), textureColor, 0.9);\n        col = mix(s, textureColor, smoothstep(0.0, 0.5, abs(d)));\n    } else {\n        //line2 y=6x+b\n        if(time>0.7){\n            dis=-7.0;\n        }else{\n            float a = time-0.7;\n            dis=28.0*a*a-6.0;\n        }\n        float m = -scale*time;\n        d = (1.0 - textureCoordinate.y) - (6.0 * textureCoordinate.x + dis);\n        if (d < 0.0){\n            vec4 textureColor = texture2D(inputImageTexture, zoom(textureCoordinate, scale, vec2(m, 0.0)));\n            vec4 col2 = colorFilter1(textureColor);\n            vec4 s = mix(vec4(0.0), col2, 0.9);\n            col = mix(s, col2, smoothstep(0.0, 0.5, abs(d)));\n        } else {\n            //line3 y=-6x+b\n            float a = time - 1.0;\n            dis=-14.28*a*a+7.0;\n            d = (1.0 - textureCoordinate.y) - (-6.0 * textureCoordinate.x + dis);\n            vec4 col2;\n            if(d>0.0){\n                vec4 textureColor = texture2D(inputImageTexture, zoom(textureCoordinate, scale, vec2(m, scale/2.0)));\n                col2 = colorFilter2(textureColor);\n                vec4 s = mix(vec4(0.0), col2, 0.9);\n                col = mix(s, col2, smoothstep(0.0, 0.5, abs(d)));\n            }else{\n                float d = -0.05*time+0.05;\n                vec2 t;\n                t.y= textureCoordinate.y;\n                if(textureCoordinate.x > 1.0 - d){\n                    t.x=-textureCoordinate.x+2.0-d;\n                }else{\n                    t.x=textureCoordinate.x+d;\n                }\n                vec4 textureColor2 = texture2D(inputImageTexture, t);\n                col = textureColor2;\n            }\n        }\n    }\n    return col;\n}\n\nvec4 getCutCol(float time)\n{\n    vec4 col;\n    //line1 y=6x+b (0.0~0.25)\n    float dis = 28.0 * time - 6.0;\n    float d = (1.0 - textureCoordinate.y) - (6.0 * textureCoordinate.x + dis);\n    if (d > 0.0) {\n        vec4 textureColor = texture2D(inputImageTexture2, textureCoordinate);\n        vec4 s = mix(vec4(0.0), textureColor, 0.9);\n        col = mix(s, textureColor, smoothstep(0.0, 0.5, abs(d)));\n    } else {\n        //line2 y=-6x+b (0.2~0.7)\n        if(time>0.7){\n            dis = -1.0;\n        } else {\n            float a = time - 0.7;\n            dis = 28.0*a*a;\n        }\n        \n        d = (1.0 - textureCoordinate.y) - (-6.0 * textureCoordinate.x + dis);\n        float m = scale*time;\n        if (d < 0.0){\n            vec4 textureColor = texture2D(inputImageTexture, zoom(textureCoordinate, scale, vec2(m, 0.0)));\n            vec4 col2 = colorFilter1(textureColor);\n            vec4 s = mix(vec4(0.0), col2, 0.9);\n            col = mix(s, col2, smoothstep(0.0, 0.5, abs(d)));\n        } else {\n            //line3 y=6x+b (0.3~1)\n            float a = time-1.0;\n            dis = -14.28*a*a+1.0;\n            d = (1.0 - textureCoordinate.y) - (6.0 * textureCoordinate.x + dis);\n            vec4 col2;\n            if(d>0.0){\n                vec4 textureColor = texture2D(inputImageTexture, zoom(textureCoordinate, scale, vec2(m, -scale/2.0)));\n                col2 = colorFilter2(textureColor);\n                vec4 s = mix(vec4(0.0), col2, 0.9);\n                col = mix(s, col2, smoothstep(0.0, 0.5, abs(d)));\n            }else{\n                float d = -0.05*time+0.05;\n                vec2 t;\n                t.y= textureCoordinate.y;\n                if(textureCoordinate.x < d){\n                    t.x=-textureCoordinate.x+d;\n                }else{\n                    t.x=textureCoordinate.x-d;\n                }\n                vec4 textureColor2 = texture2D(inputImageTexture, t);\n                col = textureColor2;\n            }\n        }\n    }\n    return col;\n}\n\nvoid main()\n{\n    float time = getAnimationTime();\n    if (time > 0.0 && time < 0.99) {\n        motionDirection = int(commonParamVec4.x);\n        if (motionDirection == 1){\n            gl_FragColor = getCutCol(time);\n        }else{\n            gl_FragColor = getCutColRev(time);\n        }\n    }else{\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n";
  private static final String FRAGMENT_SHADER_FILTER_RECOMBINE_FRAGMENT = "precision highp float;  // 必须使用 highp，否则 iOS 中精度判断有错\n\nuniform sampler2D inputImageTexture; \nuniform sampler2D inputImageTexture2;\nvarying vec2 textureCoordinate;\nuniform vec4 commonParamVec4;\nuniform vec3 iResolution;\n\nuniform float time;\nuniform vec2 timeRange;     // start, duration\n\n\nfloat A(float aA1, float aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfloat B(float aA1, float aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfloat C(float aA1) {\n    return 3.0 * aA1;\n}\n\nfloat GetSlope(float aT, float aA1, float aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfloat CalcBezier(float aT, float aA1, float aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\nfloat GetTForX(float aX, float mX1, float mX2) {\n    float aGuessT = aX;\n    for (int i = 0; i < 4; ++i) {\n        float currentSlope = GetSlope(aGuessT, mX1, mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        float currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\n\n/*\n * @param aX: 传入时间变量\n * @param mX1/mY1/mX2/mY2: 贝塞尔曲线四个值\n * 说明: 这个函数以上的其他函数都是本函数使用的辅助函数\n */\nfloat KeySpline(float aX, float mX1, float mY1, float mX2, float mY2) {\n    if (mX1 == mY1 && mX2 == mY2) return aX; // linear\n    return CalcBezier(GetTForX(aX, mX1, mX2), mY1, mY2);\n}\n\n/*\n * 说明: 通过 timeRange 和 time 计算得出 0~1 的时间变量\n */\nfloat getAnimationTime() {\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0) {\n        return animationTime;\n    }\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\n/*\n * @param _scale: 缩放程度\n * 说明: 缩放函数\n */\nmat2 scaleUv(vec2 _scale){\n    return mat2(_scale.x, 0., 0., _scale.y);\n}\n\n/*\n * @param _uv: 当前坐标\n * @param rotation: 旋转弧度\n * @param mid: 旋转中心点\n * @param direction: 1顺时针，-1逆时针\n * 说明：旋转函数\n */\nvec2 rotateUv(vec2 _uv, float rotation, vec2 mid, float direction) {\n    mid.y *= iResolution.y/iResolution.x;\n    rotation *= -direction;\n    return vec2(\n        cos(rotation) * (_uv.x - mid.x) + sin(rotation) * (_uv.y - mid.y) + mid.x,\n        cos(rotation) * (_uv.y - mid.y) - sin(rotation) * (_uv.x - mid.x) + mid.y\n    );\n}\n\n/*\n * @param _uv: 当前坐标\n * @param texture: 贴图\n * @param _t: 传入当前时间（模糊逐渐消失，若传0则一直模糊）\n * 说明：线性模糊\n */\nvec4 blur(vec2 _uv, sampler2D texture, float _t) {\n    float disp = 0.;\n    float intensity = .1;\n    const int passes = 6;\n    vec4 c1 = vec4(0.0);\n    \n    if (_t == 0.) {\n        disp = intensity*(0.5-distance(0.5, .1));\n    } else {\n        disp = intensity*(0.5-distance(0.5, (.1-_t*.1)));\n    }\n\n    for (int xi=0; xi<passes; xi++) {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++) {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(texture, _uv + d*v);\n        }\n    }\n    c1 /= float(passes*passes);\n    return c1;\n}\n\n/*\n * @param _uv: 当前坐标\n * @param position: 光斑位置 x,y\n * @param speed: 运动方向 x,y\n * @param size: 光斑大小 w,h\n * @param resolution: 分辨率\n * @param color: rgb 颜色值\n * @param t: 传入当前时间\n * 说明：绘制光斑\n */\nvec3 drawLeaks(vec2 _uv, vec2 position, vec2 speed, vec2 size, vec3 resolution, vec3 color, float t, vec2 range) {\n    vec2 leakst = _uv;\n    vec2 newsize = normalize(size);\n    newsize /= abs(newsize.x) + abs(newsize.y);\n\n    leakst -= .5;                           // 坐标系居中\n    leakst.x *= resolution.x/resolution.y;  // 等比例缩放\n\n    leakst.x -= position.x;                 // 位置调整x\n    leakst.y -= position.y;                 // 位置调整y\n\n    leakst.x -= speed.x * t * 10.;          // 运动速率x\n    leakst.y -= speed.y * t * 10.;          // 运动速率y\n\n    if (newsize.x < newsize.y)              // 大小比例调整\n        leakst.y *= newsize.x / newsize.y;  \n    if (newsize.x > newsize.y)\n        leakst.x *= newsize.y / newsize.x;\n\n    float angle = atan(leakst.y, leakst.x); // 笛卡尔转极坐标\n    float radius = length(leakst);\n\n    vec3 finalColor = vec3(smoothstep(range.x, range.y, radius))*color*(1.-t);   // 预设size&上色\n    return finalColor;\n}\n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvoid main() {\n    vec2 st = textureCoordinate;                    // 保留原始坐标\n    vec2 myst = textureCoordinate;                  // 用于坐标计算\n    float ratio = iResolution.x / iResolution.y;    // 屏幕比例\n\n    float animationTime = getAnimationTime();\n\n    float easingTime = 0.;\n    if (animationTime >= 0.7) {\n        float t = smoothstep(.7, 1., animationTime);\n        easingTime = KeySpline(t, .47,.01,.22,.99);\n    }\n\n    float r;\n    float mediumRotation = 30./180.*3.14159;\n\n    vec3 leakColor = drawLeaks(myst, vec2(-.8, -.8), vec2(.05, 0.1), \n                        vec2(.5, .5), iResolution, \n                        vec3(175./255., 104./255., 34./255.)*2.5, animationTime, vec2(.5, .2));\n    \n    vec3 leakColor2 = drawLeaks(myst, vec2(-.4, .9), vec2(.05, -.05), \n                        vec2(.5, .4), iResolution, \n                        vec3(166./255., 66./255., 65./255.)*2.2, animationTime, vec2(.3, .1));\n\n\n    if (animationTime < .7) {\n        myst -= .5;\n        myst *= scaleUv(vec2(1.-animationTime*.1));\n        myst += .5;\n        vec3 texelColor = texture2D(inputImageTexture2, myst).rgb;\n\n        gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n    }\n    else {\n\n        if (easingTime <= 0.5) {\n            myst -= .5;\n            myst *= scaleUv(vec2(1.-.7*.1));\n            myst += .5;\n            r = mediumRotation * easingTime; \n        } else {\n            r = -(mediumRotation*.5) + mediumRotation*(easingTime-.5);\n        }\n\n        myst.y *= 1./ratio;\n\n        // 左1（垂直）\n        if (textureCoordinate.x < .3 && textureCoordinate.y < .2) {\n            myst = rotateUv(myst, r, vec2(.6, .2), -1.);\n        }\n        // 上2（中间）\n        else if (textureCoordinate.x > .4 && textureCoordinate.x < .6 && textureCoordinate.y < .3 && textureCoordinate.y < .1) {\n            myst = rotateUv(myst, r, vec2(1., .8), -1.);\n        }\n        // 左2（垂直）\n        else if (textureCoordinate.x < .4 && textureCoordinate.y > .2 && textureCoordinate.y < .3) {\n            myst = rotateUv(myst, r, vec2(.4, .3), -1.);\n        }\n        // 左4（垂直）\n        else if (textureCoordinate.x < .3 && textureCoordinate.y > .4 && textureCoordinate.y < .8) {\n            myst = rotateUv(myst, r, vec2(.5, .3), -1.);\n        }\n        // 左3（垂直）\n        else if (textureCoordinate.x < .6 && textureCoordinate.y > .3 && textureCoordinate.y < .5) {\n            myst = rotateUv(myst, r, vec2(1., .3), -1.);\n        }\n        // 左5（垂直）\n        else if (textureCoordinate.x < .3 && textureCoordinate.y > .8) {\n            myst = rotateUv(myst, r, vec2(-.5, .2), -1.);\n        }\n        // 上（中间）\n        else if (textureCoordinate.x > .3 && textureCoordinate.x < .7 && textureCoordinate.y < .2) {\n            myst = rotateUv(myst, r, vec2(.8, .5), -1.);\n        }\n        // 右1（垂直）\n        else if (textureCoordinate.x > .7  && textureCoordinate.y < .2) {\n            myst = rotateUv(myst, r, vec2(.5, .2), -1.);\n        }\n        // 右2（垂直）\n        else if (textureCoordinate.x > .6 && textureCoordinate.y > .2 && textureCoordinate.y < .3) {\n            myst = rotateUv(myst, r, vec2(1.5, .5), -1.);\n        }\n        // 右3（垂直）\n        else if (textureCoordinate.x > .7 && textureCoordinate.y > .3 && textureCoordinate.y < .4) {\n            myst = rotateUv(myst, r, vec2(.2, .7), -1.);\n        }\n        // 右4（垂直）\n        else if (textureCoordinate.x > .7 && textureCoordinate.y > .4 && textureCoordinate.y < .8) {\n            myst = rotateUv(myst, r, vec2(.8, .1), -1.);\n        }\n        // 右5（垂直）\n        else if (textureCoordinate.x > .7 && textureCoordinate.y > .8) {\n            myst = rotateUv(myst, r, vec2(.5, .7), -1.);\n        }\n        // 其余\n        else {\n            myst = rotateUv(myst, r, vec2(.2, .2), -1.);\n        }\n        myst.y *= ratio;\n\n        if (easingTime <= .5) {\n            vec3 texelColor = blur(myst, inputImageTexture2, .5-easingTime).rgb;\n            gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n        }\n        else {\n            vec3 texelColor = blur(myst, inputImageTexture, animationTime).rgb;\n            gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n        }\n    }\n}";
  private static final String FRAGMENT_SHADER_FILTER_RECOMBINE_PARALLEX = "precision highp float;  // 必须使用 highp，否则 iOS 中精度判断有错\n\nuniform sampler2D inputImageTexture; \nuniform sampler2D inputImageTexture2;\nvarying vec2 textureCoordinate;\nuniform vec4 commonParamVec4;\nuniform vec3 iResolution;\n\nuniform float time;\nuniform vec2 timeRange;     // start, duration\n\n\nfloat A(float aA1, float aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfloat B(float aA1, float aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfloat C(float aA1) {\n    return 3.0 * aA1;\n}\n\nfloat GetSlope(float aT, float aA1, float aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfloat CalcBezier(float aT, float aA1, float aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\nfloat GetTForX(float aX, float mX1, float mX2) {\n    float aGuessT = aX;\n    for (int i = 0; i < 4; ++i) {\n        float currentSlope = GetSlope(aGuessT, mX1, mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        float currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\n\n/*\n * @param aX: 传入时间变量\n * @param mX1/mY1/mX2/mY2: 贝塞尔曲线四个值\n * 说明: 这个函数以上的其他函数都是本函数使用的辅助函数\n */\nfloat KeySpline(float aX, float mX1, float mY1, float mX2, float mY2) {\n    if (mX1 == mY1 && mX2 == mY2) return aX; // linear\n    return CalcBezier(GetTForX(aX, mX1, mX2), mY1, mY2);\n}\n\n\n/*\n * 说明: 通过 timeRange 和 time 计算得出 0~1 的时间变量\n */\nfloat getAnimationTime() {\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0) {\n        return animationTime;\n    }\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\n/*\n * @param _scale: 缩放程度\n * 说明: 缩放函数\n */\nmat2 scaleUv(vec2 _scale){\n    return mat2(_scale.x, 0., 0., _scale.y);\n}\n\n/*\n * @param _uv: 当前坐标\n * @param texture: 贴图\n * @param _t: 传入当前时间（模糊逐渐消失，若传0则一直模糊）\n * 说明：线性模糊\n */\nvec4 blur(vec2 _uv, sampler2D texture, float _t) {\n    float disp = 0.;\n    float intensity = .1;\n    const int passes = 6;\n    vec4 c1 = vec4(0.0);\n    \n    if (_t == 0.) {\n        disp = intensity*(0.5-distance(0.5, .1));\n    } else {\n        disp = intensity*(0.5-distance(0.5, (.1-_t*.1)));\n    }\n\n    for (int xi=0; xi<passes; xi++) {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++) {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(texture, _uv + d*v);\n        }\n    }\n    c1 /= float(passes*passes);\n    return c1;\n}\n\n/*\n * @param _uv: 当前坐标\n * @param position: 光斑位置 x,y\n * @param speed: 运动方向 x,y\n * @param size: 光斑大小 w,h\n * @param resolution: 分辨率\n * @param color: rgb 颜色值\n * @param t: 传入当前时间\n * 说明：绘制光斑\n */\nvec3 drawLeaks(vec2 _uv, vec2 position, vec2 speed, vec2 size, vec3 resolution, vec3 color, float t, vec2 range) {\n    vec2 leakst = _uv;\n    vec2 newsize = normalize(size);\n    newsize /= abs(newsize.x) + abs(newsize.y);\n\n    leakst -= .5;                           // 坐标系居中\n    leakst.x *= resolution.x/resolution.y;  // 等比例缩放\n\n    leakst.x -= position.x;                 // 位置调整x\n    leakst.y -= position.y;                 // 位置调整y\n\n    leakst.x -= speed.x * t * 10.;          // 运动速率x\n    leakst.y -= speed.y * t * 10.;          // 运动速率y\n\n    if (newsize.x < newsize.y)              // 大小比例调整\n        leakst.y *= newsize.x / newsize.y;  \n    if (newsize.x > newsize.y)\n        leakst.x *= newsize.y / newsize.x;\n\n    float angle = atan(leakst.y, leakst.x); // 笛卡尔转极坐标\n    float radius = length(leakst);\n\n    vec3 finalColor = vec3(smoothstep(range.x, range.y, radius))*color*(1.-t);   // 预设size&上色\n    return finalColor;\n}\n\nvoid main() {\n    vec2 st = textureCoordinate;                    // 保留原始坐标\n    vec2 myst = textureCoordinate;                  // 用于坐标计算\n    float ratio = iResolution.x / iResolution.y;    // 屏幕比例\n\n    float animationTime = getAnimationTime();\n\n    float easingTime = 0.;\n    if (animationTime >= .5) {\n        float t = smoothstep(.5, 1., animationTime);\n        easingTime = KeySpline(t, .47,.01,.22,.99);\n    }\n\n    float direction = -commonParamVec4.x;\n\n    vec3 leakColor = drawLeaks(myst, vec2(-.7*direction, .4*direction), vec2(.05*direction, -.02*direction), \n                        vec2(.3, .3), iResolution, \n                        vec3(185./255., 120./255., 83./255.)*2., animationTime, vec2(.5, .1));\n\n    vec3 leakColor2 = drawLeaks(myst, vec2(-.1*direction, -.8*direction), vec2(.05*direction, .05*direction), \n                        vec2(.5, .3), iResolution, \n                        vec3(139./255., 74./255., 74./255.)*1.5, animationTime, vec2(.3, .1));\n\n\n    float smoothness = 0.001;   // 边界抗锯齿\n    float stepWidth = .1;       // 每个斜块的宽度（有两个条件判断组成）\n    float moveLoop = 1.;        // 偏移量\n\n    float a = smoothstep(stepWidth*9., stepWidth*9.+smoothness, st.y);\n    float b = smoothstep(stepWidth*8.5, stepWidth*8.5+smoothness, st.y);\n    float c = smoothstep(stepWidth*8., stepWidth*8.+smoothness, st.y);\n    float d = smoothstep(stepWidth*5.5, stepWidth*5.5+smoothness, st.y);\n    float e = smoothstep(stepWidth*4.5, stepWidth*4.5+smoothness, st.y);\n    float f = smoothstep(stepWidth*4.2, stepWidth*4.2+smoothness, st.y);\n    float g = smoothstep(stepWidth*3., stepWidth*3.+smoothness, st.y);\n    float h = smoothstep(stepWidth*2.5, stepWidth*2.5+smoothness, st.y);\n    float i = smoothstep(stepWidth*1.5, stepWidth*1.5+smoothness, st.y);\n    float j = smoothstep(stepWidth*1., stepWidth*1.+smoothness, st.y);\n    float k = smoothstep(stepWidth*0., stepWidth*0.+smoothness, st.y);\n\n    // 放大\n    if (animationTime < .5) {\n        myst -= .5;\n        myst *= scaleUv(vec2(1.-animationTime*.1));\n        myst += .5;\n\n        vec3 texelColor = texture2D(inputImageTexture2, myst).rgb;\n        gl_FragColor = vec4(texelColor + leakColor + leakColor2, 1.);\n    }\n    // 横切 & 竖切\n    else {\n\n        float flag = 0.;       // 是否回退\n        if (easingTime > .7) {\n            flag = 1.;\n        }\n\n        if (myst.y < a) {\n            myst.y += flag > 0. ? (1.2-easingTime*1.2)*direction : (-easingTime*1.2*moveLoop)*direction;\n        }\n        else if (myst.y > a && myst.y <= b) {\n            myst.y += flag > 0. ? (.6-easingTime*.6)*direction : (-easingTime*.6*moveLoop)*direction;\n        }\n        else if (myst.y > b && myst.y <= c) {\n            myst.y += flag > 0. ? (.6-easingTime*.6)*direction : (-easingTime*.6*moveLoop)*direction;\n        }\n        else if (myst.y > c && myst.y <= d) {\n            myst.y += flag > 0. ? (.7-easingTime*.7)*direction : (-easingTime*.7*moveLoop)*direction;\n        }\n        else if (myst.y > d && myst.y <= e) {\n            myst.y += flag > 0. ? (.8-easingTime*.8)*direction : (-easingTime*.8*moveLoop)*direction;\n        }\n        else if (myst.y > e && myst.y <= f) {\n            myst.y += flag > 0. ? (.6-easingTime*.6)*direction : (-easingTime*.6*moveLoop)*direction;\n        }\n        else if (myst.y > f && myst.y <= g) {\n            myst.y += flag > 0. ? (.6-easingTime*.6)*direction : (-easingTime*.6*moveLoop)*direction;\n        }\n        else if (myst.y > g && myst.y <= h) {\n            myst.y += flag > 0. ? (.8-easingTime*.8)*direction : (-easingTime*.8*moveLoop)*direction;\n        }\n        else if (myst.y > h && myst.y <= i) {\n            myst.y += flag > 0. ? (1.2-easingTime*1.2)*direction : (-easingTime*1.2*moveLoop)*direction;\n        }\n        else if (myst.y > i && myst.y <= j) {\n            myst.y += flag > 0. ? (1.2-easingTime*1.2)*direction : (-easingTime*1.2*moveLoop)*direction;\n        }\n        else if (myst.y > j && myst.y <= k) {\n            myst.y += flag > 0. ? (.7-easingTime*.7)*direction : (-easingTime*.7*moveLoop)*direction;\n        }\n\n        myst = fract(myst);\n\n        if (easingTime <= .7) {\n            myst -= .5;\n            myst *= scaleUv(vec2(1.-.5*.1));\n            myst += .5;\n\n            vec3 texelColor = blur(myst, inputImageTexture2, .5-easingTime).rgb;\n            gl_FragColor = vec4(texelColor + leakColor + leakColor2, 1.);\n        } else {\n            vec3 texelColor = blur(myst, inputImageTexture, easingTime).rgb;\n            gl_FragColor = vec4(texelColor + leakColor + leakColor2, 1.);\n        }\n    }\n}";
  private static final String FRAGMENT_SHADER_FILTER_RECOMBINE_SKEW = "precision highp float;  // 必须使用 highp，否则 iOS 中精度判断有错\n\nuniform sampler2D inputImageTexture; \nuniform sampler2D inputImageTexture2;\nvarying vec2 textureCoordinate;\nuniform vec4 commonParamVec4;\nuniform vec3 iResolution;\n\nuniform float time;\nuniform vec2 timeRange;     // start, duration\n\n\nfloat A(float aA1, float aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfloat B(float aA1, float aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfloat C(float aA1) {\n    return 3.0 * aA1;\n}\n\nfloat GetSlope(float aT, float aA1, float aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfloat CalcBezier(float aT, float aA1, float aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\nfloat GetTForX(float aX, float mX1, float mX2) {\n    float aGuessT = aX;\n    for (int i = 0; i < 4; ++i) {\n        float currentSlope = GetSlope(aGuessT, mX1, mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        float currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\n\n/*\n * @param aX: 传入时间变量\n * @param mX1/mY1/mX2/mY2: 贝塞尔曲线四个值\n * 说明: 这个函数以上的其他函数都是本函数使用的辅助函数\n */\nfloat KeySpline(float aX, float mX1, float mY1, float mX2, float mY2) {\n    if (mX1 == mY1 && mX2 == mY2) return aX; // linear\n    return CalcBezier(GetTForX(aX, mX1, mX2), mY1, mY2);\n}\n\n/*\n * 说明: 通过 timeRange 和 time 计算得出 0~1 的时间变量\n */\nfloat getAnimationTime() {\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0) {\n        return animationTime;\n    }\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\n/*\n * @param _scale: 缩放程度\n * 说明: 缩放函数\n */\nmat2 scaleUv(vec2 _scale){\n    return mat2(_scale.x, 0., 0., _scale.y);\n}\n\n/*\n * @param _uv: 当前坐标\n * @param texture: 贴图\n * @param _t: 传入当前时间（模糊逐渐消失，若传0则一直模糊）\n * 说明：线性模糊\n */\nvec4 blur(vec2 _uv, sampler2D texture, float _t) {\n    float disp = 0.;\n    float intensity = .1;\n    const int passes = 6;\n    vec4 c1 = vec4(0.0);\n    \n    if (_t == 0.) {\n        disp = intensity*(0.5-distance(0.5, .1));\n    } else {\n        disp = intensity*(0.5-distance(0.5, (.1-_t*.1)));\n    }\n\n    for (int xi=0; xi<passes; xi++) {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++) {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(texture, _uv + d*v);\n        }\n    }\n    c1 /= float(passes*passes);\n    return c1;\n}\n\n/*\n * @param _uv: 当前坐标\n * @param position: 光斑位置 x,y\n * @param speed: 运动方向 x,y\n * @param size: 光斑大小 w,h\n * @param resolution: 分辨率\n * @param color: rgb 颜色值\n * @param t: 传入当前时间\n * 说明：绘制光斑\n */\nvec3 drawLeaks(vec2 _uv, vec2 position, vec2 speed, vec2 size, vec3 resolution, vec3 color, float t, vec2 range) {\n    vec2 leakst = _uv;\n    vec2 newsize = normalize(size);\n    newsize /= abs(newsize.x) + abs(newsize.y);\n\n    leakst -= .5;                           // 坐标系居中\n    leakst.x *= resolution.x/resolution.y;  // 等比例缩放\n\n    leakst.x -= position.x;                 // 位置调整x\n    leakst.y -= position.y;                 // 位置调整y\n\n    leakst.x -= speed.x * t * 10.;          // 运动速率x\n    leakst.y -= speed.y * t * 10.;          // 运动速率y\n\n    if (newsize.x < newsize.y)              // 大小比例调整\n        leakst.y *= newsize.x / newsize.y;  \n    if (newsize.x > newsize.y)\n        leakst.x *= newsize.y / newsize.x;\n\n    float angle = atan(leakst.y, leakst.x); // 笛卡尔转极坐标\n    float radius = length(leakst);\n\n    vec3 finalColor = vec3(smoothstep(range.x, range.y, radius))*color*(1.-t);   // 预设size&上色\n    return finalColor;\n}\n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvoid main() {\n    vec2 st = textureCoordinate;                    // 保留原始坐标\n    vec2 myst = textureCoordinate;                  // 用于坐标计算\n    float ratio = iResolution.x / iResolution.y;    // 屏幕比例\n\n    float animationTime = getAnimationTime();\n\n    float easingTime = 0.;\n    if (animationTime >= .5) {\n        float t = smoothstep(.5, 1., animationTime);\n        easingTime = KeySpline(t, .47,.01,.22,.99);\n    }\n\n    float direction = -commonParamVec4.x;\n    \n    vec3 leakColor = drawLeaks(myst, vec2(-.7*direction, -.4*direction), vec2(.05*direction, .08*direction), \n                        vec2(.6, .5), iResolution, \n                        vec3(166./255., 66./255., 65./255.)*2., animationTime, vec2(.3, .2));\n    \n    vec3 leakColor2 = drawLeaks(myst, vec2(0.*direction, .9*direction), vec2(-.02*direction, -0.04*direction), \n                        vec2(.4, .3), iResolution, \n                        vec3(109./255., 142./255., 93./255.)*1.5, animationTime, vec2(.4, .2));\n\n    float smoothness = 0.001;   // 边界抗锯齿\n    float stepWidth = 0.3;      // 每个斜块的宽度（有两个条件判断组成）\n    float moveLoop = 3.;        // 偏移量\n    float isReverse = 0.;       // 是否回退\n    float x = commonParamVec4.x < 0. ? st.x : (1.-st.x);\n\n    float a = smoothstep(x+stepWidth/2.*6., x+stepWidth/2.*6.+smoothness, st.y);\n    float b = smoothstep(x+stepWidth/2.*5., x+stepWidth/2.*5.+smoothness, st.y);\n    float c = smoothstep(x+stepWidth/2.*4., x+stepWidth/2.*4.+smoothness, st.y);\n    float d = smoothstep(x+stepWidth/2.*3., x+stepWidth/2.*3.+smoothness, st.y);\n    float e = smoothstep(x+stepWidth/2.*2., x+stepWidth/2.*2.+smoothness, st.y);\n    float f = smoothstep(x+stepWidth/2.*1., x+stepWidth/2.*1.+smoothness, st.y);\n    float g = smoothstep(x+stepWidth/2.*0., x+stepWidth/2.*0.+smoothness, st.y);\n    float h = smoothstep(x+stepWidth/2.*-1., x+stepWidth/2.*-1.+smoothness, st.y);\n    float i = smoothstep(x+stepWidth/2.*-2., x+stepWidth/2.*-2.+smoothness, st.y);\n    float j = smoothstep(x+stepWidth/2.*-3., x+stepWidth/2.*-3.+smoothness, st.y);\n    float k = smoothstep(x+stepWidth/2.*-4., x+stepWidth/2.*-4.+smoothness, st.y);\n    float l = smoothstep(x+stepWidth/2.*-5., x+stepWidth/2.*-5.+smoothness, st.y);\n    float m = smoothstep(x+stepWidth/2.*-6., x+stepWidth/2.*-6.+smoothness, st.y);\n    float n = smoothstep(x+stepWidth/2.*-7., x+stepWidth/2.*-7.+smoothness, st.y);\n    \n    if (animationTime < .5) {\n        myst -= .5;\n        myst *= scaleUv(vec2(1.-animationTime*.1));\n        myst += .5;\n        vec3 texelColor = texture2D(inputImageTexture2, myst).rgb;\n        gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n    }\n    else {\n        if (easingTime > 0.5) {\n            isReverse = 1.;\n        }\n        if (myst.x*myst.y <= a) {\n            myst.x += isReverse > 0. ? .1-easingTime*.1 : -easingTime*.1*moveLoop;\n            myst.y += isReverse > 0. ? (.1-easingTime*.1)*direction : -easingTime*.1*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > a && myst.x*myst.y <= b) {\n            myst.x += isReverse > 0. ? .2-easingTime*.2 : -easingTime*.2*moveLoop;\n            myst.y += isReverse > 0. ? (.2-easingTime*.2)*direction : -easingTime*.2*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > b && myst.x*myst.y <= c) {\n            myst.x += isReverse > 0. ? .3-easingTime*.3 : -easingTime*.3*moveLoop;\n            myst.y += isReverse > 0. ? (.3-easingTime*.3)*direction : -easingTime*.3*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > c && myst.x*myst.y <= d) {\n            myst.x += isReverse > 0. ? .4-easingTime*.4 : -easingTime*.4*moveLoop;\n            myst.y += isReverse > 0. ? (.4-easingTime*.4)*direction : -easingTime*.4*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > d && myst.x*myst.y <= e) {\n            myst.x += isReverse > 0. ? .5-easingTime*.5 : -easingTime*.5*moveLoop;\n            myst.y += isReverse > 0. ? (.5-easingTime*.5)*direction : -easingTime*.5*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > e && myst.x*myst.y <= f) {\n            myst.x += isReverse > 0. ? .6-easingTime*.6 : -easingTime*.6*moveLoop;\n            myst.y += isReverse > 0. ? (.6-easingTime*.6)*direction : -easingTime*.6*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > f && myst.x*myst.y <= g) {\n            myst.x += isReverse > 0. ? .8-easingTime*.8 : -easingTime*.8*moveLoop;\n            myst.y += isReverse > 0. ? (.8-easingTime*.8)*direction : -easingTime*.8*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > g && myst.x*myst.y <= h) {\n            myst.x += isReverse > 0. ? 1.-easingTime : -easingTime*moveLoop;\n            myst.y += isReverse > 0. ? (1.-easingTime)*direction : -easingTime*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > h && myst.x*myst.y <= i) {\n            myst.x += isReverse > 0. ? .8-easingTime*.8 : -easingTime*.8*moveLoop;\n            myst.y += isReverse > 0. ? (.8-easingTime*.8)*direction : -easingTime*.8*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > i && myst.x*myst.y <= j) {\n            myst.x += isReverse > 0. ? .6-easingTime*.6 : -easingTime*.6*moveLoop;\n            myst.y += isReverse > 0. ? (.6-easingTime*.6)*direction : -easingTime*.6*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > j && myst.x*myst.y <= k) {\n            myst.x += isReverse > 0. ? .5-easingTime*.5 : -easingTime*.5*moveLoop;\n            myst.y += isReverse > 0. ? (.5-easingTime*.5)*direction : -easingTime*.5*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > k && myst.x*myst.y <= l) {\n            myst.x += isReverse > 0. ? .4-easingTime*.4 : -easingTime*.4*moveLoop;\n            myst.y += isReverse > 0. ? (.4-easingTime*.4)*direction : -easingTime*.4*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > l && myst.x*myst.y <= m) {\n            myst.x += isReverse > 0. ? .3-easingTime*.3 : -easingTime*.3*moveLoop;\n            myst.y += isReverse > 0. ? (.3-easingTime*.3)*direction : -easingTime*.3*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > m && myst.x*myst.y <= n) {\n            myst.x += isReverse > 0. ? .2-easingTime*.2 : -easingTime*.2*moveLoop;\n            myst.y += isReverse > 0. ? (.2-easingTime*.2)*direction : -easingTime*.2*moveLoop*direction;\n        }\n        \n        myst = fract(myst);\n\n        if (easingTime <= .5) {\n            myst -= .5;\n            myst *= scaleUv(vec2(1.-.5*.1));\n            myst += .5;\n\n            vec3 texelColor = blur(myst, inputImageTexture2, .5-easingTime).rgb;\n            gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n        }\n        else {\n            vec3 texelColor = blur(myst, inputImageTexture, easingTime).rgb;\n            gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n        }\n    }\n}";
  private static final String FRAGMENT_SHADER_FILTER_REVERSE = "precision highp float;  // 必须使用 highp，否则 iOS 中精度判断有错\n\nuniform sampler2D inputImageTexture; \nuniform sampler2D inputImageTexture2;\nvarying vec2 textureCoordinate;\nuniform vec4 commonParamVec4;\nuniform vec3 iResolution;\n\nuniform float time;\nuniform vec2 timeRange;     // start, duration\n\nconst float RotateMaxAngle = 270.0;\nconst float SpeedPowValue = 2.0;\nconst float MotionBlurMaxStrength = .5;\nconst float MaxStretchRatio = 4.;\nconst float StretchSpeedPowValue = 3.0;\n\n\nfloat A(float aA1, float aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfloat B(float aA1, float aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfloat C(float aA1) {\n    return 3.0 * aA1;\n}\n\nfloat GetSlope(float aT, float aA1, float aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfloat CalcBezier(float aT, float aA1, float aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\nfloat GetTForX(float aX, float mX1, float mX2) {\n    float aGuessT = aX;\n    for (int i = 0; i < 4; ++i) {\n        float currentSlope = GetSlope(aGuessT, mX1, mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        float currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\n\n/*\n * @param aX: 传入时间变量\n * @param mX1/mY1/mX2/mY2: 贝塞尔曲线四个值\n * 说明: 这个函数以上的其他函数都是本函数使用的辅助函数\n */\nfloat KeySpline(float aX, float mX1, float mY1, float mX2, float mY2) {\n    if (mX1 == mY1 && mX2 == mY2) return aX; // linear\n    return CalcBezier(GetTForX(aX, mX1, mX2), mY1, mY2);\n}\n\n/*\n * 说明: 通过 timeRange 和 time 计算得出 0~1 的时间变量\n */\nfloat getAnimationTime() {\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\n/*\n * @param _scale: 缩放程度\n * 说明: 缩放函数\n */\nmat2 scaleUv(vec2 _scale){\n    return mat2(_scale.x, 0., 0., _scale.y);\n}\n\n/*\n * @param _uv: 当前坐标\n * @param rotation: 旋转弧度\n * @param mid: 旋转中心点\n * @param direction: 1顺时针，-1逆时针\n * 说明：旋转函数\n */\nvec2 rotateUv(vec2 _uv, float rotation, vec2 mid, float _direction) {\n    mid.y *= iResolution.y/iResolution.x;\n    rotation *= -_direction;\n    return vec2(\n        cos(rotation) * (_uv.x - mid.x) + sin(rotation) * (_uv.y - mid.y) + mid.x,\n        cos(rotation) * (_uv.y - mid.y) - sin(rotation) * (_uv.x - mid.x) + mid.y\n    );\n}\n\n/*\n * @param _uv: 当前坐标\n * @param texture: 贴图\n * @param _t: 传入当前时间（模糊逐渐消失，若传0则一直模糊）\n * 说明：线性模糊\n */\nvec4 Blur(vec2 _uv, sampler2D texture, float t) {\n    float disp = 0.;\n    float intensity = .1;\n    const int passes = 6;\n    vec4 c1 = vec4(0.0);\n    \n    if (t == 0.) {\n        disp = intensity*(0.5-distance(0.5, .1));\n    } else {\n        disp = intensity*(0.5-distance(0.5, (.1-t*.1)));\n    }\n\n    for (int xi=0; xi<passes; xi++) {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++) {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(texture, _uv + d*v);\n        }\n    }\n    c1 /= float(passes*passes);\n\n    return c1;\n}\n\nfloat rand(vec2 _st) {\n    return fract(sin(dot(_st.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor(sampler2D texture, vec2 _st) {\n    vec2 stUse = _st;\n    stUse.x = fract(_st.x);\n    stUse.y = fract(_st.y);\n    return texture2D(texture, stUse);\n}\n\nvec4 motionBlur(sampler2D texture, vec2 _st, vec2 speed) {\n    vec2 texCoord = _st.xy / vec2(1.0).xy;\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    float offset = rand(_st);\n    for (float t = 0.0; t <= 15.0; t++) {\n        float percent = (t + offset) / 15.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += getColor(texture, texCoord + speed * percent).rgb * weight;\n        total += weight;\n    }\n    return vec4(color / total, 1.0);\n}\n\nvec2 stretchUv(vec2 _st, float t, int direction) {\n    vec2 stUse = _st;\n    float stretchRatio;\n\n    float currentMaxStretchRatio = 1.0;\n    if (t < 0.5)\n        currentMaxStretchRatio = .4*pow(t, StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n    else\n        currentMaxStretchRatio = .4*pow((1.0 - t), StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n\n    // 居左\n    if (direction == 1) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) * (1.-_st.x) + 1.0;\n        stUse.y = (_st.y - 0.5) / stretchRatio + 0.5;\n    }\n    // 居右\n    else if (direction == 2) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) * _st.x+ 1.0;\n        stUse.y = (_st.y - 0.5) / stretchRatio + 0.5;\n    }\n    // 居上\n    else if (direction == 3) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) * _st.y + 1.0;\n        stUse.x = (_st.x - 0.5) / stretchRatio + 0.5;\n    }\n    // 居下\n    else if (direction == 4) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) * (1.-_st.y) + 1.0;\n        stUse.x = (_st.x - 0.5) / stretchRatio + 0.5;\n    }\n    // 垂直\n    else if (direction == 5) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) + 1.0;\n        stUse.y = (_st.y - 0.5) / stretchRatio + 0.5;\n    }\n    // 水平\n    else if (direction == 6) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) + 1.0;\n        stUse.x = (_st.x - 0.5) / stretchRatio + 0.5;\n    }\n\n    return stUse; \n}\n\nfloat normpdf(float x) {\n    return exp(-25.*pow(x-.5, 2.))*.5;\n}\n\nvoid main() {\n    vec2 st = textureCoordinate;                    // 保留原始坐标\n    vec2 myst = textureCoordinate;                  // 用于坐标计算\n    float ratio = iResolution.x / iResolution.y;    // 屏幕比例\n    float direction = commonParamVec4.x;            // 方向：1顺时针、0逆时针\n    vec2 rotateCenter = direction == -1. ? vec2(1., 1.) : vec2(0., 1.);\n    int stretch = direction == -1. ? 1 : 2;\n\n    float animationTime = getAnimationTime();\n    float animationTime2 = smoothstep(.2, 1., animationTime);\n    float easingTime = KeySpline(animationTime2, .45,.01,.12,1.2);    // rotate\n    float easingTime2 = KeySpline(animationTime2, 0.,.45,.9,.56);     // vertical stretch\n    float easingTime3 = KeySpline(animationTime2, 0.,.68,.94,.56);    // side & top stretch\n    float easingTime4 = KeySpline(animationTime2, .44,.44,.46,.99);   // blur\n    \n    float blur = normpdf(easingTime4);\n\n    float currentRotation = 0.;\n    float rotation = RotateMaxAngle/180.*3.14159;\n\n    float size = 1.;\n    float amount = 0.;\n    float darkness = 0.;\n\n    float h = size / iResolution.x;\n    float v = size / iResolution.y;\n\n    if (animationTime < .4) {\n        myst -= .5;\n        myst *= scaleUv(vec2(1.-animationTime*.15));\n        myst += .5;\n    }\n\n    if (animationTime < .2) {\n        gl_FragColor = texture2D(inputImageTexture2, myst);\n    }\n    else {\n        myst = stretchUv(myst, easingTime3, stretch);   // 两侧拉伸\n        myst = stretchUv(myst, easingTime3, 3);         // 顶部拉伸\n        myst = stretchUv(myst, easingTime2, 5);         // 垂直拉伸\n\n        if (easingTime >= .95) {\n            easingTime -= 0.001;\n        }\n\n        if (easingTime <= .3) {\n            currentRotation = rotation * easingTime * direction;\n        } else {\n            currentRotation = (-rotation + rotation * easingTime) * direction;\n        }\n\n        // 当前帧进行旋转\n        vec2 mystCurrent = myst;\n        mystCurrent.y *= 1./ratio;\n        mystCurrent = rotateUv(mystCurrent, currentRotation, rotateCenter, -1.);\n        mystCurrent.y *= ratio;\n\n\n        // 以 fps=60 作为间隔，计算出实际帧速率\n        float timeInterval = 0.001;\n        if (animationTime < 0.5 && animationTime + timeInterval > 0.5)\n            timeInterval = 0.5 - animationTime;\n\n\n        if (easingTime <= .3) {\n            currentRotation = rotation * (easingTime+timeInterval) * direction;\n        } else {\n            currentRotation = (-rotation + rotation * (easingTime+timeInterval)) * direction;\n        }\n\n\n        // 下一帧帧进行旋转\n        vec2 mystNext = myst;\n        mystNext.y *= 1./ratio;\n        mystNext = rotateUv(mystNext, currentRotation, rotateCenter, -1.);\n        mystNext.y *= ratio;\n\n\n        // 得到单位坐标方向\n        vec2 speed  = (mystNext - mystCurrent) / timeInterval * blur * MotionBlurMaxStrength;\n\n\n        if (easingTime <= .5)  {\n            gl_FragColor = motionBlur(inputImageTexture2, mystCurrent, speed);\n        }\n        else {\n            vec4 blurColor = motionBlur(inputImageTexture, mystCurrent, speed);\n            // gl_FragColor = blurColor; \n            if (animationTime >= .4) {\n                vec4 sum = vec4(0.0);\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x - 2.0 * h, mystCurrent.y))- darkness)) * 0.12245;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x - 1.0 * h, mystCurrent.y))- darkness)) * 0.1531;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y))- darkness)) * 0.1633;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x + 1.0 * h, mystCurrent.y))- darkness)) * 0.1531;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x + 2.0 * h, mystCurrent.y))- darkness)) * 0.12245;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y - 2.0 * v))- darkness)) * 0.12245;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y - 1.0 * v))- darkness)) * 0.1531;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y))- darkness)) * 0.1633;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y + 1.0 * v))- darkness)) * 0.1531;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y + 2.0 * v))- darkness)) * 0.12245;\n                \n                if (animationTime <= .7) {\n                    amount = smoothstep(.4, .7, animationTime);\n                } else {\n                    amount = smoothstep(.95, .7, animationTime);\n                }\n\n                vec4 filterColor = blurColor + max(sum, 0.) * amount * 1.5;\n                gl_FragColor = filterColor;\n            }\n        }\n    }\n}";
  private static final String FRAGMENT_SHADER_HEYSEA_1 = "//输入参数\n// @param: duration：1.2s\n\nprecision highp float;\n\nvarying vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\nuniform vec2 inputImageTextureSize;\n\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTexture2Size;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nuniform vec4 commonParamVec4;\n\nint motionDirection = 1; //1=上左,2=上右,3=下左,4=下右\n\nconst float ImageRepeatCount = 2.0;\nconst float RotateMaxAngle = 45.0;\nconst float SpeedPowValue = 5.0;\nconst float MotionBlurMaxStrength = 0.05;\nconst float MaxStretchRatio = 3.5;\nconst float StretchSpeedPowValue = 3.0;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nfloat adjustTextureCoordinateIfOutOfRange(float coordinateValue)\n{\n    float adjustValue = mod(abs(coordinateValue), 2.0);\n    if (adjustValue > 1.0)\n        adjustValue =  2.0 - adjustValue;\n    return adjustValue;\n}\n\nvoid setMotionDirection(float directionParam)\n{\n    motionDirection = int(directionParam);\n    if (motionDirection != 1 && motionDirection != 2 && motionDirection != 3 && motionDirection != 4)\n        motionDirection = 1;\n}\n\nfloat isMotionUp()\n{\n    if (motionDirection == 1 || motionDirection == 2)\n        return 1.0;\n    else\n        return -1.0;\n}\n\nfloat isMotionLeft()\n{\n    if (motionDirection == 1 || motionDirection == 3)\n        return 1.0;\n    else\n        return -1.0;\n}\n\n//滚动\n\nvec2 getScroll(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 outputTextureCoordinate = inputTextureCoordinate;\n    if (animationTime < 0.5)\n        outputTextureCoordinate.y += pow(animationTime, SpeedPowValue) * pow(2.0, SpeedPowValue) * ImageRepeatCount * isMotionUp();\n    else\n        outputTextureCoordinate.x += pow((1.0 - animationTime), SpeedPowValue) * pow(2.0, SpeedPowValue) * ImageRepeatCount * (-1.0) * isMotionLeft();\n    return outputTextureCoordinate;\n}\n\n//旋转\n\nfloat getRotateAngleFromTime(float animationTime)\n{\n    if (animationTime < 0.5)\n        return pow(animationTime, SpeedPowValue) * pow(2.0, SpeedPowValue) * RotateMaxAngle * isMotionUp() * isMotionLeft();\n    else\n        return pow((1.0 - animationTime), SpeedPowValue) * pow(2.0, SpeedPowValue) * RotateMaxAngle * (-1.0) * isMotionUp() * isMotionLeft();\n}\n\nvec2 getRotate(vec2 inputTextureCoordinate, float angle, vec2 rotateCenter)\n{\n    vec2 textureCoordinateUse;\n    float degree = radians(angle);\n    float c = cos(degree);\n    float s = sin(degree);\n    textureCoordinateUse.x = (inputTextureCoordinate.x - rotateCenter.x) * c - (inputTextureCoordinate.y - rotateCenter.y) * s + rotateCenter.x;\n    textureCoordinateUse.y = (inputTextureCoordinate.x - rotateCenter.x) * s + (inputTextureCoordinate.y - rotateCenter.y) * c + rotateCenter.y;\n    return textureCoordinateUse;\n}\n\n//运动模糊\n\nfloat rand (vec2 inputTextureCoordinate)\n{\n    return fract(sin(dot(inputTextureCoordinate.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor(sampler2D imageTexture, vec2 inputTextureCoordinate)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    textureCoordinateUse.x = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.x);\n    textureCoordinateUse.y = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.y);\n    return texture2D(imageTexture, textureCoordinateUse);\n}\n\nvec4 motionBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed)\n{\n    vec2 texCoord = inputTextureCoordinate.xy / vec2(1.0).xy;\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= 20.0; t++) {\n        float percent = (t + offset) / 20.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += getColor(imageTexture, texCoord + speed * percent).rgb * weight;\n        total += weight;\n    }\n    return vec4(color / total, 1.0);\n}\n\nvec2 getMotionTransition(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 textureCoordinateUse = getScroll(inputTextureCoordinate, animationTime);\n    float angle = getRotateAngleFromTime(animationTime);\n    vec2 rotateCenter = getScroll(vec2(0.5, 0.5), animationTime);\n    textureCoordinateUse = getRotate(textureCoordinateUse, angle, rotateCenter);\n    return textureCoordinateUse;\n}\n\n//拉伸\n\nvec2 getStretchTransition(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    float currentMaxStretchRatio = 1.0;\n    if (animationTime < 0.5)\n        currentMaxStretchRatio = pow(animationTime, StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n    else\n        currentMaxStretchRatio = pow((1.0 - animationTime), StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n    float stretchRatio = (currentMaxStretchRatio - 1.0) * (1.0 - inputTextureCoordinate.y) + 1.0;\n    textureCoordinateUse.x = (inputTextureCoordinate.x - 0.5) / stretchRatio + 0.5;\n    return textureCoordinateUse;\n}\n\n//main\n\nvoid main()\n{\n    setMotionDirection(commonParamVec4.x);\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n        vec2 textureCoordinateUse = getStretchTransition(textureCoordinate, animationTime);\n        textureCoordinateUse = getMotionTransition(textureCoordinateUse, animationTime);\n        \n        float timeInterval = 0.0001;\n        if (animationTime < 0.5 && animationTime + timeInterval > 0.5)\n            timeInterval = 0.5 - animationTime;\n        vec2 textureCoordinateNext = getStretchTransition(textureCoordinate, animationTime + timeInterval);\n        textureCoordinateNext = getMotionTransition(textureCoordinateNext, animationTime + timeInterval);\n        vec2 speed = (textureCoordinateNext - textureCoordinateUse) / timeInterval * MotionBlurMaxStrength;\n        \n        if (animationTime < 0.5)\n            gl_FragColor = motionBlur(inputImageTexture2, textureCoordinateUse, speed);\n        else\n            gl_FragColor = motionBlur(inputImageTexture, textureCoordinateUse, speed);\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n\n";
  private static final String FRAGMENT_SHADER_SLIP = "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvoid main()\n{\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n\tfloat x = animationTime - 1.0;\n\tanimationTime = x * x * x + 1.0;\n        float divide = 1.0 - animationTime;\n\tif (textureCoordinate.x < divide) {\n\t\tgl_FragColor = texture2D(inputImageTexture2, textureCoordinate.xy + vec2(animationTime, 0.0));\n\t} else {\n\t\tfloat dis = 0.2 * (1.0 - animationTime);\n\t\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate.xy - vec2(divide - dis, 0.0));\n  \t}\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}";
  private static final String FRAGMENT_SHADER_SPEED_OUT = "precision highp float;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform vec2 inputImageTextureSize;\n\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTexture2Size;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nuniform vec4 commonParamVec4;\n\nint motionDirection = 1; //1=上,2=下,3=左,4=右,5=上左,6=上右,7=下左,8=下右\n\nconst float SpeedPowValue = 4.0;\nconst float MotionBlurMaxStrength = 0.07;\nconst float TextureChangeTime = 0.4;\nconst float ImageRepeatCount1 = 2.5;\nconst float ImageRepeatCount2 = 1.0;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nfloat adjustTextureCoordinateIfOutOfRange(float coordinateValue)\n{\n    float adjustValue = mod(abs(coordinateValue), 2.0);\n    if (adjustValue > 1.0)\n        adjustValue =  2.0 - adjustValue;\n    return adjustValue;\n}\n\nvoid setMotionDirection(float directionParam)\n{\n    motionDirection = int(directionParam);\n    if (motionDirection < 1 || motionDirection > 8)\n        motionDirection = 3;\n}\n\nfloat motionXWeight()\n{\n    if (motionDirection == 3 || motionDirection == 5 || motionDirection == 7)\n        return 1.0;\n    else if (motionDirection == 4 || motionDirection == 6 || motionDirection == 8)\n        return -1.0;\n    else\n        return 0.0;\n}\n\nfloat motionYWeight()\n{\n    if (motionDirection == 1 || motionDirection == 5 || motionDirection == 6)\n        return 1.0;\n    else if (motionDirection == 2 || motionDirection == 7 || motionDirection == 8)\n        return -1.0;\n    else\n        return 0.0;\n}\n\n//滚动\n\nvec2 getScroll(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 outputTextureCoordinate = inputTextureCoordinate;\n    if (animationTime < TextureChangeTime) {\n        float moveValue = pow(animationTime, SpeedPowValue) * pow(1.0/TextureChangeTime, SpeedPowValue) * ImageRepeatCount1;\n        outputTextureCoordinate.x += moveValue * motionXWeight();\n        outputTextureCoordinate.y += moveValue * motionYWeight();\n    }\n    else {\n        float moveValue = (-1.0) * pow((1.0 - animationTime), SpeedPowValue) * pow(1.0/(1.0-TextureChangeTime), SpeedPowValue) * ImageRepeatCount2;\n        outputTextureCoordinate.x += moveValue * motionXWeight();\n        outputTextureCoordinate.y += moveValue * motionYWeight();\n    }\n    return outputTextureCoordinate;\n}\n\n//运动模糊\n\nfloat rand (vec2 inputTextureCoordinate)\n{\n    return fract(sin(dot(inputTextureCoordinate.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor(sampler2D imageTexture, vec2 inputTextureCoordinate)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    textureCoordinateUse.x = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.x);\n    textureCoordinateUse.y = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.y);\n    return texture2D(imageTexture, textureCoordinateUse);\n}\n\nvec4 motionBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed)\n{\n    vec2 texCoord = inputTextureCoordinate.xy / vec2(1.0).xy;\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= 20.0; t++) {\n        float percent = (t + offset) / 20.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += getColor(imageTexture, texCoord + speed * percent).rgb * weight;\n        total += weight;\n    }\n    return vec4(color / total, 1.0);\n}\n\n//main\n\nvoid main()\n{\n    setMotionDirection(commonParamVec4.x);\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n        vec2 textureCoordinateUse = getScroll(textureCoordinate, animationTime);\n        \n        float timeInterval = 0.0001;\n        if (animationTime < TextureChangeTime && animationTime + timeInterval > TextureChangeTime)\n            timeInterval = TextureChangeTime - animationTime;\n        vec2 textureCoordinateNext = getScroll(textureCoordinate, animationTime + timeInterval);\n        vec2 speed = (textureCoordinateNext - textureCoordinateUse) / timeInterval * MotionBlurMaxStrength;\n        \n        if (animationTime < TextureChangeTime)\n            gl_FragColor = motionBlur(inputImageTexture2, textureCoordinateUse, speed);\n        else\n            gl_FragColor = motionBlur(inputImageTexture, textureCoordinateUse, speed);\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n\n";
  private static final String FRAGMENT_SHADER_TEST = "precision highp float;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTextureSize;\nuniform vec2 inputImageTexture2Size;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nvarying vec2 textureCoordinate;\nvoid main()\n{\nhighp vec2 size = inputImageTextureSize - inputImageTexture2Size;\nif (time > timeRange.x && time < timeRange.y + timeRange.x)\n{\nsize.x = 0.5;\nsize.y = 0.5;\n}\nelse\n{\nsize.x = 0.5;\nsize.y = 0.5;\n};\ngl_FragColor = texture2D(inputImageTexture, textureCoordinate) * size.x + texture2D(inputImageTexture2, textureCoordinate) * size.y;\n}";
  private static final String FRAGMENT_SHADER_WHITE_LIGHT = "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  float phase = time < 0.5 ? time * 2.0 : (time - 0.5) * 2.0;\n  vec4 c = time < 0.5 ? texture2D(inputImageTexture2, textureCoordinate) : texture2D(inputImageTexture, textureCoordinate);\n  vec4 mixCol = vec4(1.0 , 1.0 , 1.0 , 1.0);\n  return c + (time < 0.5 ? mix(vec4(0.0), mixCol, phase) : mix(mixCol, vec4(0.0), phase));\n}\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}";
  private static final String FRAGMENT_SHADER_WIPE = "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nvec2 direction = vec2(1.0, 1.0);\nfloat smoothness = 0.5;\n \nconst vec2 center = vec2(0.5, 0.5);\n \n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, uv);\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  vec2 v = normalize(direction);\n  v /= abs(v.x)+abs(v.y);\n  float d = v.x * center.x + v.y * center.y;\n  float m = (1.0-step(time, 0.0)) * (1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d-0.5+time*(1.+smoothness))));\n  return mix(fromCol, toCol, m);\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}";
  private static final String FRAGMENT_SHADER_ZOOM = "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nfloat nQuick = 0.8;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec2 zoom(vec2 uv, float amount) {\n  return 0.5 + ((uv - 0.5) * (1.0-amount));\t\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, zoom(uv, smoothstep(0.0, nQuick, time)));\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  return mix(fromCol,toCol,smoothstep(0.4, 1.0, time));\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}";
  public static final int ID_ERASE = 3;
  public static final int ID_FADE = 4;
  public static final int ID_FADE_BLACK = 5;
  public static final int ID_FILTER_CUT = 11;
  public static final int ID_FILTER_RECOMBINE = 13;
  public static final int ID_FILTER_REVERSE = 12;
  public static final int ID_MAGIC_SWITCH = 1;
  public static final int ID_NONE = -1;
  public static final int ID_SCENE_DAZZLE = 2;
  public static final int ID_SLIP = 9;
  public static final int ID_SPEED_OUT = 10;
  public static final int ID_WHITE_LIGHT = 8;
  public static final int ID_WIPE = 7;
  public static final int ID_ZOOM = 6;
  private static final String VERTEX_SHADER_BlUR = "uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvarying vec2 singleStepOffset;\nuniform vec2 texelOffset;\n\nvoid main()\n{\n    gl_Position = position;\n    textureCoordinate = inputTextureCoordinate.xy;\n    vec2 xStep = vec2(1.0, 0.0);\n    singleStepOffset = texelOffset * xStep;\n}";
  private static final String VERTEX_SHADER_BlUR2 = "uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvarying vec2 singleStepOffset;\nuniform vec2 texelOffset;\n\nvoid main()\n{\n    gl_Position = position;\n    textureCoordinate = inputTextureCoordinate.xy;\n    vec2 yStep = vec2(0.0, 1.0);\n    singleStepOffset = texelOffset * yStep;\n}";
  private static final String VERTEX_SHADER_TEST = "uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}";
  
  public static int getConfigCount()
  {
    return 1;
  }
  
  public static TransferConfig.ConfigData getConfigData(int paramInt)
  {
    TransferConfig.ConfigData localConfigData = new TransferConfig.ConfigData();
    switch (paramInt)
    {
    default: 
      localConfigData.mID = -1;
      return localConfigData;
    case 13: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;  // 必须使用 highp，否则 iOS 中精度判断有错\n\nuniform sampler2D inputImageTexture; \nuniform sampler2D inputImageTexture2;\nvarying vec2 textureCoordinate;\nuniform vec4 commonParamVec4;\nuniform vec3 iResolution;\n\nuniform float time;\nuniform vec2 timeRange;     // start, duration\n\n\nfloat A(float aA1, float aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfloat B(float aA1, float aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfloat C(float aA1) {\n    return 3.0 * aA1;\n}\n\nfloat GetSlope(float aT, float aA1, float aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfloat CalcBezier(float aT, float aA1, float aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\nfloat GetTForX(float aX, float mX1, float mX2) {\n    float aGuessT = aX;\n    for (int i = 0; i < 4; ++i) {\n        float currentSlope = GetSlope(aGuessT, mX1, mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        float currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\n\n/*\n * @param aX: 传入时间变量\n * @param mX1/mY1/mX2/mY2: 贝塞尔曲线四个值\n * 说明: 这个函数以上的其他函数都是本函数使用的辅助函数\n */\nfloat KeySpline(float aX, float mX1, float mY1, float mX2, float mY2) {\n    if (mX1 == mY1 && mX2 == mY2) return aX; // linear\n    return CalcBezier(GetTForX(aX, mX1, mX2), mY1, mY2);\n}\n\n/*\n * 说明: 通过 timeRange 和 time 计算得出 0~1 的时间变量\n */\nfloat getAnimationTime() {\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0) {\n        return animationTime;\n    }\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\n/*\n * @param _scale: 缩放程度\n * 说明: 缩放函数\n */\nmat2 scaleUv(vec2 _scale){\n    return mat2(_scale.x, 0., 0., _scale.y);\n}\n\n/*\n * @param _uv: 当前坐标\n * @param rotation: 旋转弧度\n * @param mid: 旋转中心点\n * @param direction: 1顺时针，-1逆时针\n * 说明：旋转函数\n */\nvec2 rotateUv(vec2 _uv, float rotation, vec2 mid, float direction) {\n    mid.y *= iResolution.y/iResolution.x;\n    rotation *= -direction;\n    return vec2(\n        cos(rotation) * (_uv.x - mid.x) + sin(rotation) * (_uv.y - mid.y) + mid.x,\n        cos(rotation) * (_uv.y - mid.y) - sin(rotation) * (_uv.x - mid.x) + mid.y\n    );\n}\n\n/*\n * @param _uv: 当前坐标\n * @param texture: 贴图\n * @param _t: 传入当前时间（模糊逐渐消失，若传0则一直模糊）\n * 说明：线性模糊\n */\nvec4 blur(vec2 _uv, sampler2D texture, float _t) {\n    float disp = 0.;\n    float intensity = .1;\n    const int passes = 6;\n    vec4 c1 = vec4(0.0);\n    \n    if (_t == 0.) {\n        disp = intensity*(0.5-distance(0.5, .1));\n    } else {\n        disp = intensity*(0.5-distance(0.5, (.1-_t*.1)));\n    }\n\n    for (int xi=0; xi<passes; xi++) {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++) {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(texture, _uv + d*v);\n        }\n    }\n    c1 /= float(passes*passes);\n    return c1;\n}\n\n/*\n * @param _uv: 当前坐标\n * @param position: 光斑位置 x,y\n * @param speed: 运动方向 x,y\n * @param size: 光斑大小 w,h\n * @param resolution: 分辨率\n * @param color: rgb 颜色值\n * @param t: 传入当前时间\n * 说明：绘制光斑\n */\nvec3 drawLeaks(vec2 _uv, vec2 position, vec2 speed, vec2 size, vec3 resolution, vec3 color, float t, vec2 range) {\n    vec2 leakst = _uv;\n    vec2 newsize = normalize(size);\n    newsize /= abs(newsize.x) + abs(newsize.y);\n\n    leakst -= .5;                           // 坐标系居中\n    leakst.x *= resolution.x/resolution.y;  // 等比例缩放\n\n    leakst.x -= position.x;                 // 位置调整x\n    leakst.y -= position.y;                 // 位置调整y\n\n    leakst.x -= speed.x * t * 10.;          // 运动速率x\n    leakst.y -= speed.y * t * 10.;          // 运动速率y\n\n    if (newsize.x < newsize.y)              // 大小比例调整\n        leakst.y *= newsize.x / newsize.y;  \n    if (newsize.x > newsize.y)\n        leakst.x *= newsize.y / newsize.x;\n\n    float angle = atan(leakst.y, leakst.x); // 笛卡尔转极坐标\n    float radius = length(leakst);\n\n    vec3 finalColor = vec3(smoothstep(range.x, range.y, radius))*color*(1.-t);   // 预设size&上色\n    return finalColor;\n}\n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvoid main() {\n    vec2 st = textureCoordinate;                    // 保留原始坐标\n    vec2 myst = textureCoordinate;                  // 用于坐标计算\n    float ratio = iResolution.x / iResolution.y;    // 屏幕比例\n\n    float animationTime = getAnimationTime();\n\n    float easingTime = 0.;\n    if (animationTime >= 0.7) {\n        float t = smoothstep(.7, 1., animationTime);\n        easingTime = KeySpline(t, .47,.01,.22,.99);\n    }\n\n    float r;\n    float mediumRotation = 30./180.*3.14159;\n\n    vec3 leakColor = drawLeaks(myst, vec2(-.8, -.8), vec2(.05, 0.1), \n                        vec2(.5, .5), iResolution, \n                        vec3(175./255., 104./255., 34./255.)*2.5, animationTime, vec2(.5, .2));\n    \n    vec3 leakColor2 = drawLeaks(myst, vec2(-.4, .9), vec2(.05, -.05), \n                        vec2(.5, .4), iResolution, \n                        vec3(166./255., 66./255., 65./255.)*2.2, animationTime, vec2(.3, .1));\n\n\n    if (animationTime < .7) {\n        myst -= .5;\n        myst *= scaleUv(vec2(1.-animationTime*.1));\n        myst += .5;\n        vec3 texelColor = texture2D(inputImageTexture2, myst).rgb;\n\n        gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n    }\n    else {\n\n        if (easingTime <= 0.5) {\n            myst -= .5;\n            myst *= scaleUv(vec2(1.-.7*.1));\n            myst += .5;\n            r = mediumRotation * easingTime; \n        } else {\n            r = -(mediumRotation*.5) + mediumRotation*(easingTime-.5);\n        }\n\n        myst.y *= 1./ratio;\n\n        // 左1（垂直）\n        if (textureCoordinate.x < .3 && textureCoordinate.y < .2) {\n            myst = rotateUv(myst, r, vec2(.6, .2), -1.);\n        }\n        // 上2（中间）\n        else if (textureCoordinate.x > .4 && textureCoordinate.x < .6 && textureCoordinate.y < .3 && textureCoordinate.y < .1) {\n            myst = rotateUv(myst, r, vec2(1., .8), -1.);\n        }\n        // 左2（垂直）\n        else if (textureCoordinate.x < .4 && textureCoordinate.y > .2 && textureCoordinate.y < .3) {\n            myst = rotateUv(myst, r, vec2(.4, .3), -1.);\n        }\n        // 左4（垂直）\n        else if (textureCoordinate.x < .3 && textureCoordinate.y > .4 && textureCoordinate.y < .8) {\n            myst = rotateUv(myst, r, vec2(.5, .3), -1.);\n        }\n        // 左3（垂直）\n        else if (textureCoordinate.x < .6 && textureCoordinate.y > .3 && textureCoordinate.y < .5) {\n            myst = rotateUv(myst, r, vec2(1., .3), -1.);\n        }\n        // 左5（垂直）\n        else if (textureCoordinate.x < .3 && textureCoordinate.y > .8) {\n            myst = rotateUv(myst, r, vec2(-.5, .2), -1.);\n        }\n        // 上（中间）\n        else if (textureCoordinate.x > .3 && textureCoordinate.x < .7 && textureCoordinate.y < .2) {\n            myst = rotateUv(myst, r, vec2(.8, .5), -1.);\n        }\n        // 右1（垂直）\n        else if (textureCoordinate.x > .7  && textureCoordinate.y < .2) {\n            myst = rotateUv(myst, r, vec2(.5, .2), -1.);\n        }\n        // 右2（垂直）\n        else if (textureCoordinate.x > .6 && textureCoordinate.y > .2 && textureCoordinate.y < .3) {\n            myst = rotateUv(myst, r, vec2(1.5, .5), -1.);\n        }\n        // 右3（垂直）\n        else if (textureCoordinate.x > .7 && textureCoordinate.y > .3 && textureCoordinate.y < .4) {\n            myst = rotateUv(myst, r, vec2(.2, .7), -1.);\n        }\n        // 右4（垂直）\n        else if (textureCoordinate.x > .7 && textureCoordinate.y > .4 && textureCoordinate.y < .8) {\n            myst = rotateUv(myst, r, vec2(.8, .1), -1.);\n        }\n        // 右5（垂直）\n        else if (textureCoordinate.x > .7 && textureCoordinate.y > .8) {\n            myst = rotateUv(myst, r, vec2(.5, .7), -1.);\n        }\n        // 其余\n        else {\n            myst = rotateUv(myst, r, vec2(.2, .2), -1.);\n        }\n        myst.y *= ratio;\n\n        if (easingTime <= .5) {\n            vec3 texelColor = blur(myst, inputImageTexture2, .5-easingTime).rgb;\n            gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n        }\n        else {\n            vec3 texelColor = blur(myst, inputImageTexture, animationTime).rgb;\n            gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n        }\n    }\n}");
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;  // 必须使用 highp，否则 iOS 中精度判断有错\n\nuniform sampler2D inputImageTexture; \nuniform sampler2D inputImageTexture2;\nvarying vec2 textureCoordinate;\nuniform vec4 commonParamVec4;\nuniform vec3 iResolution;\n\nuniform float time;\nuniform vec2 timeRange;     // start, duration\n\n\nfloat A(float aA1, float aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfloat B(float aA1, float aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfloat C(float aA1) {\n    return 3.0 * aA1;\n}\n\nfloat GetSlope(float aT, float aA1, float aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfloat CalcBezier(float aT, float aA1, float aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\nfloat GetTForX(float aX, float mX1, float mX2) {\n    float aGuessT = aX;\n    for (int i = 0; i < 4; ++i) {\n        float currentSlope = GetSlope(aGuessT, mX1, mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        float currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\n\n/*\n * @param aX: 传入时间变量\n * @param mX1/mY1/mX2/mY2: 贝塞尔曲线四个值\n * 说明: 这个函数以上的其他函数都是本函数使用的辅助函数\n */\nfloat KeySpline(float aX, float mX1, float mY1, float mX2, float mY2) {\n    if (mX1 == mY1 && mX2 == mY2) return aX; // linear\n    return CalcBezier(GetTForX(aX, mX1, mX2), mY1, mY2);\n}\n\n/*\n * 说明: 通过 timeRange 和 time 计算得出 0~1 的时间变量\n */\nfloat getAnimationTime() {\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0) {\n        return animationTime;\n    }\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\n/*\n * @param _scale: 缩放程度\n * 说明: 缩放函数\n */\nmat2 scaleUv(vec2 _scale){\n    return mat2(_scale.x, 0., 0., _scale.y);\n}\n\n/*\n * @param _uv: 当前坐标\n * @param texture: 贴图\n * @param _t: 传入当前时间（模糊逐渐消失，若传0则一直模糊）\n * 说明：线性模糊\n */\nvec4 blur(vec2 _uv, sampler2D texture, float _t) {\n    float disp = 0.;\n    float intensity = .1;\n    const int passes = 6;\n    vec4 c1 = vec4(0.0);\n    \n    if (_t == 0.) {\n        disp = intensity*(0.5-distance(0.5, .1));\n    } else {\n        disp = intensity*(0.5-distance(0.5, (.1-_t*.1)));\n    }\n\n    for (int xi=0; xi<passes; xi++) {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++) {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(texture, _uv + d*v);\n        }\n    }\n    c1 /= float(passes*passes);\n    return c1;\n}\n\n/*\n * @param _uv: 当前坐标\n * @param position: 光斑位置 x,y\n * @param speed: 运动方向 x,y\n * @param size: 光斑大小 w,h\n * @param resolution: 分辨率\n * @param color: rgb 颜色值\n * @param t: 传入当前时间\n * 说明：绘制光斑\n */\nvec3 drawLeaks(vec2 _uv, vec2 position, vec2 speed, vec2 size, vec3 resolution, vec3 color, float t, vec2 range) {\n    vec2 leakst = _uv;\n    vec2 newsize = normalize(size);\n    newsize /= abs(newsize.x) + abs(newsize.y);\n\n    leakst -= .5;                           // 坐标系居中\n    leakst.x *= resolution.x/resolution.y;  // 等比例缩放\n\n    leakst.x -= position.x;                 // 位置调整x\n    leakst.y -= position.y;                 // 位置调整y\n\n    leakst.x -= speed.x * t * 10.;          // 运动速率x\n    leakst.y -= speed.y * t * 10.;          // 运动速率y\n\n    if (newsize.x < newsize.y)              // 大小比例调整\n        leakst.y *= newsize.x / newsize.y;  \n    if (newsize.x > newsize.y)\n        leakst.x *= newsize.y / newsize.x;\n\n    float angle = atan(leakst.y, leakst.x); // 笛卡尔转极坐标\n    float radius = length(leakst);\n\n    vec3 finalColor = vec3(smoothstep(range.x, range.y, radius))*color*(1.-t);   // 预设size&上色\n    return finalColor;\n}\n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvoid main() {\n    vec2 st = textureCoordinate;                    // 保留原始坐标\n    vec2 myst = textureCoordinate;                  // 用于坐标计算\n    float ratio = iResolution.x / iResolution.y;    // 屏幕比例\n\n    float animationTime = getAnimationTime();\n\n    float easingTime = 0.;\n    if (animationTime >= .5) {\n        float t = smoothstep(.5, 1., animationTime);\n        easingTime = KeySpline(t, .47,.01,.22,.99);\n    }\n\n    float direction = -commonParamVec4.x;\n    \n    vec3 leakColor = drawLeaks(myst, vec2(-.7*direction, -.4*direction), vec2(.05*direction, .08*direction), \n                        vec2(.6, .5), iResolution, \n                        vec3(166./255., 66./255., 65./255.)*2., animationTime, vec2(.3, .2));\n    \n    vec3 leakColor2 = drawLeaks(myst, vec2(0.*direction, .9*direction), vec2(-.02*direction, -0.04*direction), \n                        vec2(.4, .3), iResolution, \n                        vec3(109./255., 142./255., 93./255.)*1.5, animationTime, vec2(.4, .2));\n\n    float smoothness = 0.001;   // 边界抗锯齿\n    float stepWidth = 0.3;      // 每个斜块的宽度（有两个条件判断组成）\n    float moveLoop = 3.;        // 偏移量\n    float isReverse = 0.;       // 是否回退\n    float x = commonParamVec4.x < 0. ? st.x : (1.-st.x);\n\n    float a = smoothstep(x+stepWidth/2.*6., x+stepWidth/2.*6.+smoothness, st.y);\n    float b = smoothstep(x+stepWidth/2.*5., x+stepWidth/2.*5.+smoothness, st.y);\n    float c = smoothstep(x+stepWidth/2.*4., x+stepWidth/2.*4.+smoothness, st.y);\n    float d = smoothstep(x+stepWidth/2.*3., x+stepWidth/2.*3.+smoothness, st.y);\n    float e = smoothstep(x+stepWidth/2.*2., x+stepWidth/2.*2.+smoothness, st.y);\n    float f = smoothstep(x+stepWidth/2.*1., x+stepWidth/2.*1.+smoothness, st.y);\n    float g = smoothstep(x+stepWidth/2.*0., x+stepWidth/2.*0.+smoothness, st.y);\n    float h = smoothstep(x+stepWidth/2.*-1., x+stepWidth/2.*-1.+smoothness, st.y);\n    float i = smoothstep(x+stepWidth/2.*-2., x+stepWidth/2.*-2.+smoothness, st.y);\n    float j = smoothstep(x+stepWidth/2.*-3., x+stepWidth/2.*-3.+smoothness, st.y);\n    float k = smoothstep(x+stepWidth/2.*-4., x+stepWidth/2.*-4.+smoothness, st.y);\n    float l = smoothstep(x+stepWidth/2.*-5., x+stepWidth/2.*-5.+smoothness, st.y);\n    float m = smoothstep(x+stepWidth/2.*-6., x+stepWidth/2.*-6.+smoothness, st.y);\n    float n = smoothstep(x+stepWidth/2.*-7., x+stepWidth/2.*-7.+smoothness, st.y);\n    \n    if (animationTime < .5) {\n        myst -= .5;\n        myst *= scaleUv(vec2(1.-animationTime*.1));\n        myst += .5;\n        vec3 texelColor = texture2D(inputImageTexture2, myst).rgb;\n        gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n    }\n    else {\n        if (easingTime > 0.5) {\n            isReverse = 1.;\n        }\n        if (myst.x*myst.y <= a) {\n            myst.x += isReverse > 0. ? .1-easingTime*.1 : -easingTime*.1*moveLoop;\n            myst.y += isReverse > 0. ? (.1-easingTime*.1)*direction : -easingTime*.1*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > a && myst.x*myst.y <= b) {\n            myst.x += isReverse > 0. ? .2-easingTime*.2 : -easingTime*.2*moveLoop;\n            myst.y += isReverse > 0. ? (.2-easingTime*.2)*direction : -easingTime*.2*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > b && myst.x*myst.y <= c) {\n            myst.x += isReverse > 0. ? .3-easingTime*.3 : -easingTime*.3*moveLoop;\n            myst.y += isReverse > 0. ? (.3-easingTime*.3)*direction : -easingTime*.3*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > c && myst.x*myst.y <= d) {\n            myst.x += isReverse > 0. ? .4-easingTime*.4 : -easingTime*.4*moveLoop;\n            myst.y += isReverse > 0. ? (.4-easingTime*.4)*direction : -easingTime*.4*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > d && myst.x*myst.y <= e) {\n            myst.x += isReverse > 0. ? .5-easingTime*.5 : -easingTime*.5*moveLoop;\n            myst.y += isReverse > 0. ? (.5-easingTime*.5)*direction : -easingTime*.5*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > e && myst.x*myst.y <= f) {\n            myst.x += isReverse > 0. ? .6-easingTime*.6 : -easingTime*.6*moveLoop;\n            myst.y += isReverse > 0. ? (.6-easingTime*.6)*direction : -easingTime*.6*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > f && myst.x*myst.y <= g) {\n            myst.x += isReverse > 0. ? .8-easingTime*.8 : -easingTime*.8*moveLoop;\n            myst.y += isReverse > 0. ? (.8-easingTime*.8)*direction : -easingTime*.8*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > g && myst.x*myst.y <= h) {\n            myst.x += isReverse > 0. ? 1.-easingTime : -easingTime*moveLoop;\n            myst.y += isReverse > 0. ? (1.-easingTime)*direction : -easingTime*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > h && myst.x*myst.y <= i) {\n            myst.x += isReverse > 0. ? .8-easingTime*.8 : -easingTime*.8*moveLoop;\n            myst.y += isReverse > 0. ? (.8-easingTime*.8)*direction : -easingTime*.8*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > i && myst.x*myst.y <= j) {\n            myst.x += isReverse > 0. ? .6-easingTime*.6 : -easingTime*.6*moveLoop;\n            myst.y += isReverse > 0. ? (.6-easingTime*.6)*direction : -easingTime*.6*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > j && myst.x*myst.y <= k) {\n            myst.x += isReverse > 0. ? .5-easingTime*.5 : -easingTime*.5*moveLoop;\n            myst.y += isReverse > 0. ? (.5-easingTime*.5)*direction : -easingTime*.5*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > k && myst.x*myst.y <= l) {\n            myst.x += isReverse > 0. ? .4-easingTime*.4 : -easingTime*.4*moveLoop;\n            myst.y += isReverse > 0. ? (.4-easingTime*.4)*direction : -easingTime*.4*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > l && myst.x*myst.y <= m) {\n            myst.x += isReverse > 0. ? .3-easingTime*.3 : -easingTime*.3*moveLoop;\n            myst.y += isReverse > 0. ? (.3-easingTime*.3)*direction : -easingTime*.3*moveLoop*direction;\n        }\n        else if (myst.x*myst.y > m && myst.x*myst.y <= n) {\n            myst.x += isReverse > 0. ? .2-easingTime*.2 : -easingTime*.2*moveLoop;\n            myst.y += isReverse > 0. ? (.2-easingTime*.2)*direction : -easingTime*.2*moveLoop*direction;\n        }\n        \n        myst = fract(myst);\n\n        if (easingTime <= .5) {\n            myst -= .5;\n            myst *= scaleUv(vec2(1.-.5*.1));\n            myst += .5;\n\n            vec3 texelColor = blur(myst, inputImageTexture2, .5-easingTime).rgb;\n            gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n        }\n        else {\n            vec3 texelColor = blur(myst, inputImageTexture, easingTime).rgb;\n            gl_FragColor = vec4(blendScreen(texelColor, leakColor+leakColor2), 1.);\n        }\n    }\n}");
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;  // 必须使用 highp，否则 iOS 中精度判断有错\n\nuniform sampler2D inputImageTexture; \nuniform sampler2D inputImageTexture2;\nvarying vec2 textureCoordinate;\nuniform vec4 commonParamVec4;\nuniform vec3 iResolution;\n\nuniform float time;\nuniform vec2 timeRange;     // start, duration\n\n\nfloat A(float aA1, float aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfloat B(float aA1, float aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfloat C(float aA1) {\n    return 3.0 * aA1;\n}\n\nfloat GetSlope(float aT, float aA1, float aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfloat CalcBezier(float aT, float aA1, float aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\nfloat GetTForX(float aX, float mX1, float mX2) {\n    float aGuessT = aX;\n    for (int i = 0; i < 4; ++i) {\n        float currentSlope = GetSlope(aGuessT, mX1, mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        float currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\n\n/*\n * @param aX: 传入时间变量\n * @param mX1/mY1/mX2/mY2: 贝塞尔曲线四个值\n * 说明: 这个函数以上的其他函数都是本函数使用的辅助函数\n */\nfloat KeySpline(float aX, float mX1, float mY1, float mX2, float mY2) {\n    if (mX1 == mY1 && mX2 == mY2) return aX; // linear\n    return CalcBezier(GetTForX(aX, mX1, mX2), mY1, mY2);\n}\n\n\n/*\n * 说明: 通过 timeRange 和 time 计算得出 0~1 的时间变量\n */\nfloat getAnimationTime() {\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0) {\n        return animationTime;\n    }\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\n/*\n * @param _scale: 缩放程度\n * 说明: 缩放函数\n */\nmat2 scaleUv(vec2 _scale){\n    return mat2(_scale.x, 0., 0., _scale.y);\n}\n\n/*\n * @param _uv: 当前坐标\n * @param texture: 贴图\n * @param _t: 传入当前时间（模糊逐渐消失，若传0则一直模糊）\n * 说明：线性模糊\n */\nvec4 blur(vec2 _uv, sampler2D texture, float _t) {\n    float disp = 0.;\n    float intensity = .1;\n    const int passes = 6;\n    vec4 c1 = vec4(0.0);\n    \n    if (_t == 0.) {\n        disp = intensity*(0.5-distance(0.5, .1));\n    } else {\n        disp = intensity*(0.5-distance(0.5, (.1-_t*.1)));\n    }\n\n    for (int xi=0; xi<passes; xi++) {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++) {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(texture, _uv + d*v);\n        }\n    }\n    c1 /= float(passes*passes);\n    return c1;\n}\n\n/*\n * @param _uv: 当前坐标\n * @param position: 光斑位置 x,y\n * @param speed: 运动方向 x,y\n * @param size: 光斑大小 w,h\n * @param resolution: 分辨率\n * @param color: rgb 颜色值\n * @param t: 传入当前时间\n * 说明：绘制光斑\n */\nvec3 drawLeaks(vec2 _uv, vec2 position, vec2 speed, vec2 size, vec3 resolution, vec3 color, float t, vec2 range) {\n    vec2 leakst = _uv;\n    vec2 newsize = normalize(size);\n    newsize /= abs(newsize.x) + abs(newsize.y);\n\n    leakst -= .5;                           // 坐标系居中\n    leakst.x *= resolution.x/resolution.y;  // 等比例缩放\n\n    leakst.x -= position.x;                 // 位置调整x\n    leakst.y -= position.y;                 // 位置调整y\n\n    leakst.x -= speed.x * t * 10.;          // 运动速率x\n    leakst.y -= speed.y * t * 10.;          // 运动速率y\n\n    if (newsize.x < newsize.y)              // 大小比例调整\n        leakst.y *= newsize.x / newsize.y;  \n    if (newsize.x > newsize.y)\n        leakst.x *= newsize.y / newsize.x;\n\n    float angle = atan(leakst.y, leakst.x); // 笛卡尔转极坐标\n    float radius = length(leakst);\n\n    vec3 finalColor = vec3(smoothstep(range.x, range.y, radius))*color*(1.-t);   // 预设size&上色\n    return finalColor;\n}\n\nvoid main() {\n    vec2 st = textureCoordinate;                    // 保留原始坐标\n    vec2 myst = textureCoordinate;                  // 用于坐标计算\n    float ratio = iResolution.x / iResolution.y;    // 屏幕比例\n\n    float animationTime = getAnimationTime();\n\n    float easingTime = 0.;\n    if (animationTime >= .5) {\n        float t = smoothstep(.5, 1., animationTime);\n        easingTime = KeySpline(t, .47,.01,.22,.99);\n    }\n\n    float direction = -commonParamVec4.x;\n\n    vec3 leakColor = drawLeaks(myst, vec2(-.7*direction, .4*direction), vec2(.05*direction, -.02*direction), \n                        vec2(.3, .3), iResolution, \n                        vec3(185./255., 120./255., 83./255.)*2., animationTime, vec2(.5, .1));\n\n    vec3 leakColor2 = drawLeaks(myst, vec2(-.1*direction, -.8*direction), vec2(.05*direction, .05*direction), \n                        vec2(.5, .3), iResolution, \n                        vec3(139./255., 74./255., 74./255.)*1.5, animationTime, vec2(.3, .1));\n\n\n    float smoothness = 0.001;   // 边界抗锯齿\n    float stepWidth = .1;       // 每个斜块的宽度（有两个条件判断组成）\n    float moveLoop = 1.;        // 偏移量\n\n    float a = smoothstep(stepWidth*9., stepWidth*9.+smoothness, st.y);\n    float b = smoothstep(stepWidth*8.5, stepWidth*8.5+smoothness, st.y);\n    float c = smoothstep(stepWidth*8., stepWidth*8.+smoothness, st.y);\n    float d = smoothstep(stepWidth*5.5, stepWidth*5.5+smoothness, st.y);\n    float e = smoothstep(stepWidth*4.5, stepWidth*4.5+smoothness, st.y);\n    float f = smoothstep(stepWidth*4.2, stepWidth*4.2+smoothness, st.y);\n    float g = smoothstep(stepWidth*3., stepWidth*3.+smoothness, st.y);\n    float h = smoothstep(stepWidth*2.5, stepWidth*2.5+smoothness, st.y);\n    float i = smoothstep(stepWidth*1.5, stepWidth*1.5+smoothness, st.y);\n    float j = smoothstep(stepWidth*1., stepWidth*1.+smoothness, st.y);\n    float k = smoothstep(stepWidth*0., stepWidth*0.+smoothness, st.y);\n\n    // 放大\n    if (animationTime < .5) {\n        myst -= .5;\n        myst *= scaleUv(vec2(1.-animationTime*.1));\n        myst += .5;\n\n        vec3 texelColor = texture2D(inputImageTexture2, myst).rgb;\n        gl_FragColor = vec4(texelColor + leakColor + leakColor2, 1.);\n    }\n    // 横切 & 竖切\n    else {\n\n        float flag = 0.;       // 是否回退\n        if (easingTime > .7) {\n            flag = 1.;\n        }\n\n        if (myst.y < a) {\n            myst.y += flag > 0. ? (1.2-easingTime*1.2)*direction : (-easingTime*1.2*moveLoop)*direction;\n        }\n        else if (myst.y > a && myst.y <= b) {\n            myst.y += flag > 0. ? (.6-easingTime*.6)*direction : (-easingTime*.6*moveLoop)*direction;\n        }\n        else if (myst.y > b && myst.y <= c) {\n            myst.y += flag > 0. ? (.6-easingTime*.6)*direction : (-easingTime*.6*moveLoop)*direction;\n        }\n        else if (myst.y > c && myst.y <= d) {\n            myst.y += flag > 0. ? (.7-easingTime*.7)*direction : (-easingTime*.7*moveLoop)*direction;\n        }\n        else if (myst.y > d && myst.y <= e) {\n            myst.y += flag > 0. ? (.8-easingTime*.8)*direction : (-easingTime*.8*moveLoop)*direction;\n        }\n        else if (myst.y > e && myst.y <= f) {\n            myst.y += flag > 0. ? (.6-easingTime*.6)*direction : (-easingTime*.6*moveLoop)*direction;\n        }\n        else if (myst.y > f && myst.y <= g) {\n            myst.y += flag > 0. ? (.6-easingTime*.6)*direction : (-easingTime*.6*moveLoop)*direction;\n        }\n        else if (myst.y > g && myst.y <= h) {\n            myst.y += flag > 0. ? (.8-easingTime*.8)*direction : (-easingTime*.8*moveLoop)*direction;\n        }\n        else if (myst.y > h && myst.y <= i) {\n            myst.y += flag > 0. ? (1.2-easingTime*1.2)*direction : (-easingTime*1.2*moveLoop)*direction;\n        }\n        else if (myst.y > i && myst.y <= j) {\n            myst.y += flag > 0. ? (1.2-easingTime*1.2)*direction : (-easingTime*1.2*moveLoop)*direction;\n        }\n        else if (myst.y > j && myst.y <= k) {\n            myst.y += flag > 0. ? (.7-easingTime*.7)*direction : (-easingTime*.7*moveLoop)*direction;\n        }\n\n        myst = fract(myst);\n\n        if (easingTime <= .7) {\n            myst -= .5;\n            myst *= scaleUv(vec2(1.-.5*.1));\n            myst += .5;\n\n            vec3 texelColor = blur(myst, inputImageTexture2, .5-easingTime).rgb;\n            gl_FragColor = vec4(texelColor + leakColor + leakColor2, 1.);\n        } else {\n            vec3 texelColor = blur(myst, inputImageTexture, easingTime).rgb;\n            gl_FragColor = vec4(texelColor + leakColor + leakColor2, 1.);\n        }\n    }\n}");
      localConfigData.mLevelEffectShader = true;
      localConfigData.mDuration = 1800L;
      localConfigData.mID = paramInt;
      localConfigData.mCommonFloat1 = new TransferConfig.ExtendParamFloats(new float[] { 1.0F, 1.0F, 1.0F, -1.0F, -1.0F, -1.0F }, 0, 2, 0);
      return localConfigData;
    case 12: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;  // 必须使用 highp，否则 iOS 中精度判断有错\n\nuniform sampler2D inputImageTexture; \nuniform sampler2D inputImageTexture2;\nvarying vec2 textureCoordinate;\nuniform vec4 commonParamVec4;\nuniform vec3 iResolution;\n\nuniform float time;\nuniform vec2 timeRange;     // start, duration\n\nconst float RotateMaxAngle = 270.0;\nconst float SpeedPowValue = 2.0;\nconst float MotionBlurMaxStrength = .5;\nconst float MaxStretchRatio = 4.;\nconst float StretchSpeedPowValue = 3.0;\n\n\nfloat A(float aA1, float aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfloat B(float aA1, float aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfloat C(float aA1) {\n    return 3.0 * aA1;\n}\n\nfloat GetSlope(float aT, float aA1, float aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfloat CalcBezier(float aT, float aA1, float aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n}\n\nfloat GetTForX(float aX, float mX1, float mX2) {\n    float aGuessT = aX;\n    for (int i = 0; i < 4; ++i) {\n        float currentSlope = GetSlope(aGuessT, mX1, mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        float currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\n\n/*\n * @param aX: 传入时间变量\n * @param mX1/mY1/mX2/mY2: 贝塞尔曲线四个值\n * 说明: 这个函数以上的其他函数都是本函数使用的辅助函数\n */\nfloat KeySpline(float aX, float mX1, float mY1, float mX2, float mY2) {\n    if (mX1 == mY1 && mX2 == mY2) return aX; // linear\n    return CalcBezier(GetTForX(aX, mX1, mX2), mY1, mY2);\n}\n\n/*\n * 说明: 通过 timeRange 和 time 计算得出 0~1 的时间变量\n */\nfloat getAnimationTime() {\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\n/*\n * @param _scale: 缩放程度\n * 说明: 缩放函数\n */\nmat2 scaleUv(vec2 _scale){\n    return mat2(_scale.x, 0., 0., _scale.y);\n}\n\n/*\n * @param _uv: 当前坐标\n * @param rotation: 旋转弧度\n * @param mid: 旋转中心点\n * @param direction: 1顺时针，-1逆时针\n * 说明：旋转函数\n */\nvec2 rotateUv(vec2 _uv, float rotation, vec2 mid, float _direction) {\n    mid.y *= iResolution.y/iResolution.x;\n    rotation *= -_direction;\n    return vec2(\n        cos(rotation) * (_uv.x - mid.x) + sin(rotation) * (_uv.y - mid.y) + mid.x,\n        cos(rotation) * (_uv.y - mid.y) - sin(rotation) * (_uv.x - mid.x) + mid.y\n    );\n}\n\n/*\n * @param _uv: 当前坐标\n * @param texture: 贴图\n * @param _t: 传入当前时间（模糊逐渐消失，若传0则一直模糊）\n * 说明：线性模糊\n */\nvec4 Blur(vec2 _uv, sampler2D texture, float t) {\n    float disp = 0.;\n    float intensity = .1;\n    const int passes = 6;\n    vec4 c1 = vec4(0.0);\n    \n    if (t == 0.) {\n        disp = intensity*(0.5-distance(0.5, .1));\n    } else {\n        disp = intensity*(0.5-distance(0.5, (.1-t*.1)));\n    }\n\n    for (int xi=0; xi<passes; xi++) {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++) {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(texture, _uv + d*v);\n        }\n    }\n    c1 /= float(passes*passes);\n\n    return c1;\n}\n\nfloat rand(vec2 _st) {\n    return fract(sin(dot(_st.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor(sampler2D texture, vec2 _st) {\n    vec2 stUse = _st;\n    stUse.x = fract(_st.x);\n    stUse.y = fract(_st.y);\n    return texture2D(texture, stUse);\n}\n\nvec4 motionBlur(sampler2D texture, vec2 _st, vec2 speed) {\n    vec2 texCoord = _st.xy / vec2(1.0).xy;\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    float offset = rand(_st);\n    for (float t = 0.0; t <= 15.0; t++) {\n        float percent = (t + offset) / 15.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += getColor(texture, texCoord + speed * percent).rgb * weight;\n        total += weight;\n    }\n    return vec4(color / total, 1.0);\n}\n\nvec2 stretchUv(vec2 _st, float t, int direction) {\n    vec2 stUse = _st;\n    float stretchRatio;\n\n    float currentMaxStretchRatio = 1.0;\n    if (t < 0.5)\n        currentMaxStretchRatio = .4*pow(t, StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n    else\n        currentMaxStretchRatio = .4*pow((1.0 - t), StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n\n    // 居左\n    if (direction == 1) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) * (1.-_st.x) + 1.0;\n        stUse.y = (_st.y - 0.5) / stretchRatio + 0.5;\n    }\n    // 居右\n    else if (direction == 2) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) * _st.x+ 1.0;\n        stUse.y = (_st.y - 0.5) / stretchRatio + 0.5;\n    }\n    // 居上\n    else if (direction == 3) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) * _st.y + 1.0;\n        stUse.x = (_st.x - 0.5) / stretchRatio + 0.5;\n    }\n    // 居下\n    else if (direction == 4) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) * (1.-_st.y) + 1.0;\n        stUse.x = (_st.x - 0.5) / stretchRatio + 0.5;\n    }\n    // 垂直\n    else if (direction == 5) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) + 1.0;\n        stUse.y = (_st.y - 0.5) / stretchRatio + 0.5;\n    }\n    // 水平\n    else if (direction == 6) {\n        stretchRatio = (currentMaxStretchRatio - 1.0) + 1.0;\n        stUse.x = (_st.x - 0.5) / stretchRatio + 0.5;\n    }\n\n    return stUse; \n}\n\nfloat normpdf(float x) {\n    return exp(-25.*pow(x-.5, 2.))*.5;\n}\n\nvoid main() {\n    vec2 st = textureCoordinate;                    // 保留原始坐标\n    vec2 myst = textureCoordinate;                  // 用于坐标计算\n    float ratio = iResolution.x / iResolution.y;    // 屏幕比例\n    float direction = commonParamVec4.x;            // 方向：1顺时针、0逆时针\n    vec2 rotateCenter = direction == -1. ? vec2(1., 1.) : vec2(0., 1.);\n    int stretch = direction == -1. ? 1 : 2;\n\n    float animationTime = getAnimationTime();\n    float animationTime2 = smoothstep(.2, 1., animationTime);\n    float easingTime = KeySpline(animationTime2, .45,.01,.12,1.2);    // rotate\n    float easingTime2 = KeySpline(animationTime2, 0.,.45,.9,.56);     // vertical stretch\n    float easingTime3 = KeySpline(animationTime2, 0.,.68,.94,.56);    // side & top stretch\n    float easingTime4 = KeySpline(animationTime2, .44,.44,.46,.99);   // blur\n    \n    float blur = normpdf(easingTime4);\n\n    float currentRotation = 0.;\n    float rotation = RotateMaxAngle/180.*3.14159;\n\n    float size = 1.;\n    float amount = 0.;\n    float darkness = 0.;\n\n    float h = size / iResolution.x;\n    float v = size / iResolution.y;\n\n    if (animationTime < .4) {\n        myst -= .5;\n        myst *= scaleUv(vec2(1.-animationTime*.15));\n        myst += .5;\n    }\n\n    if (animationTime < .2) {\n        gl_FragColor = texture2D(inputImageTexture2, myst);\n    }\n    else {\n        myst = stretchUv(myst, easingTime3, stretch);   // 两侧拉伸\n        myst = stretchUv(myst, easingTime3, 3);         // 顶部拉伸\n        myst = stretchUv(myst, easingTime2, 5);         // 垂直拉伸\n\n        if (easingTime >= .95) {\n            easingTime -= 0.001;\n        }\n\n        if (easingTime <= .3) {\n            currentRotation = rotation * easingTime * direction;\n        } else {\n            currentRotation = (-rotation + rotation * easingTime) * direction;\n        }\n\n        // 当前帧进行旋转\n        vec2 mystCurrent = myst;\n        mystCurrent.y *= 1./ratio;\n        mystCurrent = rotateUv(mystCurrent, currentRotation, rotateCenter, -1.);\n        mystCurrent.y *= ratio;\n\n\n        // 以 fps=60 作为间隔，计算出实际帧速率\n        float timeInterval = 0.001;\n        if (animationTime < 0.5 && animationTime + timeInterval > 0.5)\n            timeInterval = 0.5 - animationTime;\n\n\n        if (easingTime <= .3) {\n            currentRotation = rotation * (easingTime+timeInterval) * direction;\n        } else {\n            currentRotation = (-rotation + rotation * (easingTime+timeInterval)) * direction;\n        }\n\n\n        // 下一帧帧进行旋转\n        vec2 mystNext = myst;\n        mystNext.y *= 1./ratio;\n        mystNext = rotateUv(mystNext, currentRotation, rotateCenter, -1.);\n        mystNext.y *= ratio;\n\n\n        // 得到单位坐标方向\n        vec2 speed  = (mystNext - mystCurrent) / timeInterval * blur * MotionBlurMaxStrength;\n\n\n        if (easingTime <= .5)  {\n            gl_FragColor = motionBlur(inputImageTexture2, mystCurrent, speed);\n        }\n        else {\n            vec4 blurColor = motionBlur(inputImageTexture, mystCurrent, speed);\n            // gl_FragColor = blurColor; \n            if (animationTime >= .4) {\n                vec4 sum = vec4(0.0);\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x - 2.0 * h, mystCurrent.y))- darkness)) * 0.12245;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x - 1.0 * h, mystCurrent.y))- darkness)) * 0.1531;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y))- darkness)) * 0.1633;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x + 1.0 * h, mystCurrent.y))- darkness)) * 0.1531;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x + 2.0 * h, mystCurrent.y))- darkness)) * 0.12245;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y - 2.0 * v))- darkness)) * 0.12245;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y - 1.0 * v))- darkness)) * 0.1531;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y))- darkness)) * 0.1633;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y + 1.0 * v))- darkness)) * 0.1531;\n                sum += (texture2D(inputImageTexture, fract(vec2(mystCurrent.x, mystCurrent.y + 2.0 * v))- darkness)) * 0.12245;\n                \n                if (animationTime <= .7) {\n                    amount = smoothstep(.4, .7, animationTime);\n                } else {\n                    amount = smoothstep(.95, .7, animationTime);\n                }\n\n                vec4 filterColor = blurColor + max(sum, 0.) * amount * 1.5;\n                gl_FragColor = filterColor;\n            }\n        }\n    }\n}");
      localConfigData.mDuration = 1800L;
      localConfigData.mID = paramInt;
      localConfigData.mCommonFloat1 = new TransferConfig.ExtendParamFloats(new float[] { -1.0F, 1.0F }, 0, 2, 0);
      return localConfigData;
    case 11: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision mediump float;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nuniform vec4 commonParamVec4;\nint motionDirection = 1; //1=左,2=右\nconst float scale = 0.04;\n\n//F-滤镜参数\n\nconst mat4 F_FilterColorMapIn =  mat4(0.0, 100.0, 200.0, 250.0,\n                                      0.0, 39.0, 92.0, 184.0,\n                                      0.0, 114.0, 198.0, 254.0,\n                                      0.0, 90.0, 205.0, 254.0);\n\nconst mat4 F_FilterColorMapOut =  mat4(0.0, 100.0, 200.0, 250.0,\n                                       0.0, 40.0, 119.0, 210.0,\n                                       6.0, 118.0, 213.0, 254.0,\n                                       0.0, 120.0, 227.0, 254.0);\n\n//iOS\n//const mat4 F_FilterColorMapIn =  mat4(0.0, 33.0, 111.0, 208.0,\n//                                      0.0, 39.0, 99.0, 182.0,\n//                                      0.0, 123.0, 208.0, 254.0,\n//                                      0.0, 115.0, 205.0, 254.0);\n//\n//const mat4 F_FilterColorMapOut =  mat4(22.0, 33.0, 161.0, 226.0,\n//                                       0.0, 40.0, 113.0, 229.0,\n//                                       4.0, 112.0, 214.0, 254.0,\n//                                       0.0, 135.0, 227.0, 254.0);\n\n//草木绿-滤镜参数\n\nconst mat4 GrassGreen_FilterColorMapIn =  mat4(0.0, 100.0, 200.0, 250.0,\n                                               0.0, 50.0, 200.0, 254.0,\n                                               0.0, 28.0, 103.0, 189.0,\n                                               0.0, 8.0, 54.0, 149.0);\n\nconst mat4 GrassGreen_FilterColorMapOut =  mat4(0.0, 100.0, 200.0, 250.0,\n                                                0.0, 50.0, 200.0, 254.0,\n                                                14.0, 31.0, 128.0, 198.0,\n                                                0.0, 17.0, 54.0, 164.0);\n\n//iOS\n//const mat4 GrassGreen_FilterColorMapIn =  mat4(0.0, 10.0, 37.0, 122.0,\n//                                               0.0, 50.0, 200.0, 254.0,\n//                                               0.0, 28.0, 103.0, 189.0,\n//                                               0.0, 8.0, 54.0, 149.0);\n//\n//const mat4 GrassGreen_FilterColorMapOut =  mat4(19.0, 19.0, 40.0, 141.0,\n//                                                0.0, 50.0, 200.0, 254.0,\n//                                                14.0, 31.0, 128.0, 198.0,\n//                                                0.0, 17.0, 54.0, 164.0);\n\nfloat calculateColor(float colorIn1, float colorOut1, float colorIn2, float colorOut2, float sourceColorIn255)\n{\n    return colorOut1 + (sourceColorIn255 - colorIn1) * (colorOut2 - colorOut1) / (colorIn2 - colorIn1);\n}\n\nfloat replaceColor(vec4 colorMapIn, vec4 colorMapOut, float sourceColorIn255)\n{\n    if (sourceColorIn255 < colorMapIn[1]) {\n        return calculateColor(colorMapIn[0], colorMapOut[0], colorMapIn[1], colorMapOut[1], sourceColorIn255);\n    } else if (sourceColorIn255 < colorMapIn[2]) {\n        return calculateColor(colorMapIn[1], colorMapOut[1], colorMapIn[2], colorMapOut[2], sourceColorIn255);\n    } else if (sourceColorIn255 < colorMapIn[3]) {\n        return calculateColor(colorMapIn[2], colorMapOut[2], colorMapIn[3], colorMapOut[3], sourceColorIn255);\n    } else {\n        return calculateColor(colorMapIn[3], colorMapOut[3], 255.0, 255.0, sourceColorIn255);\n    }\n}\n\n//滤镜F\nvec4 colorFilter1(vec4 sourceColor)\n{\n    vec4 resultColor = sourceColor * 255.0;\n    \n    //R通道\n    resultColor[0] = replaceColor(F_FilterColorMapIn[1], F_FilterColorMapOut[1], resultColor[0]);\n    //resultColor[0] = replaceColor(F_FilterColorMapIn[0], F_FilterColorMapOut[0], resultColor[0]);\n    \n    //G通道\n    resultColor[1] = replaceColor(F_FilterColorMapIn[2], F_FilterColorMapOut[2], resultColor[1]);\n    //resultColor[1] = replaceColor(F_FilterColorMapIn[0], F_FilterColorMapOut[0], resultColor[1]);\n    \n    //B通道\n    resultColor[2] = replaceColor(F_FilterColorMapIn[3], F_FilterColorMapOut[3], resultColor[2]);\n    //resultColor[2] = replaceColor(F_FilterColorMapIn[0], F_FilterColorMapOut[0], resultColor[2]);\n    \n    return resultColor / 255.0;\n}\n\n//滤镜草木绿\nvec4 colorFilter2(vec4 sourceColor)\n{\n    vec4 resultColor = sourceColor * 255.0;\n    \n    //R通道\n    //resultColor[0] = replaceColor(GrassGreen_FilterColorMapIn[0], GrassGreen_FilterColorMapOut[0], resultColor[0]);\n    \n    //G通道\n    resultColor[1] = replaceColor(GrassGreen_FilterColorMapIn[2], GrassGreen_FilterColorMapOut[2], resultColor[1]);\n    //resultColor[1] = replaceColor(GrassGreen_FilterColorMapIn[0], GrassGreen_FilterColorMapOut[0], resultColor[1]);\n    \n    //B通道\n    resultColor[2] = replaceColor(GrassGreen_FilterColorMapIn[3], GrassGreen_FilterColorMapOut[3], resultColor[2]);\n    //resultColor[2] = replaceColor(GrassGreen_FilterColorMapIn[0], GrassGreen_FilterColorMapOut[0], resultColor[2]);\n    \n    return resultColor / 255.0;\n}\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec2 zoom(vec2 uv, float amount, vec2 move) {\n    return 0.5 + ((uv - 0.5) * (1.0-amount)) + move;\n}\n\nvec4 getCutColRev(float time)\n{\n    vec4 col;\n    //line1 y=-6x+b\n    float dis = 28.0 * time;\n    float d = (1.0 - textureCoordinate.y) - (-6.0 * textureCoordinate.x + dis);\n    if (d > 0.0) {\n        vec4 textureColor = texture2D(inputImageTexture2, textureCoordinate);\n        vec4 s = mix(vec4(0.0), textureColor, 0.9);\n        col = mix(s, textureColor, smoothstep(0.0, 0.5, abs(d)));\n    } else {\n        //line2 y=6x+b\n        if(time>0.7){\n            dis=-7.0;\n        }else{\n            float a = time-0.7;\n            dis=28.0*a*a-6.0;\n        }\n        float m = -scale*time;\n        d = (1.0 - textureCoordinate.y) - (6.0 * textureCoordinate.x + dis);\n        if (d < 0.0){\n            vec4 textureColor = texture2D(inputImageTexture, zoom(textureCoordinate, scale, vec2(m, 0.0)));\n            vec4 col2 = colorFilter1(textureColor);\n            vec4 s = mix(vec4(0.0), col2, 0.9);\n            col = mix(s, col2, smoothstep(0.0, 0.5, abs(d)));\n        } else {\n            //line3 y=-6x+b\n            float a = time - 1.0;\n            dis=-14.28*a*a+7.0;\n            d = (1.0 - textureCoordinate.y) - (-6.0 * textureCoordinate.x + dis);\n            vec4 col2;\n            if(d>0.0){\n                vec4 textureColor = texture2D(inputImageTexture, zoom(textureCoordinate, scale, vec2(m, scale/2.0)));\n                col2 = colorFilter2(textureColor);\n                vec4 s = mix(vec4(0.0), col2, 0.9);\n                col = mix(s, col2, smoothstep(0.0, 0.5, abs(d)));\n            }else{\n                float d = -0.05*time+0.05;\n                vec2 t;\n                t.y= textureCoordinate.y;\n                if(textureCoordinate.x > 1.0 - d){\n                    t.x=-textureCoordinate.x+2.0-d;\n                }else{\n                    t.x=textureCoordinate.x+d;\n                }\n                vec4 textureColor2 = texture2D(inputImageTexture, t);\n                col = textureColor2;\n            }\n        }\n    }\n    return col;\n}\n\nvec4 getCutCol(float time)\n{\n    vec4 col;\n    //line1 y=6x+b (0.0~0.25)\n    float dis = 28.0 * time - 6.0;\n    float d = (1.0 - textureCoordinate.y) - (6.0 * textureCoordinate.x + dis);\n    if (d > 0.0) {\n        vec4 textureColor = texture2D(inputImageTexture2, textureCoordinate);\n        vec4 s = mix(vec4(0.0), textureColor, 0.9);\n        col = mix(s, textureColor, smoothstep(0.0, 0.5, abs(d)));\n    } else {\n        //line2 y=-6x+b (0.2~0.7)\n        if(time>0.7){\n            dis = -1.0;\n        } else {\n            float a = time - 0.7;\n            dis = 28.0*a*a;\n        }\n        \n        d = (1.0 - textureCoordinate.y) - (-6.0 * textureCoordinate.x + dis);\n        float m = scale*time;\n        if (d < 0.0){\n            vec4 textureColor = texture2D(inputImageTexture, zoom(textureCoordinate, scale, vec2(m, 0.0)));\n            vec4 col2 = colorFilter1(textureColor);\n            vec4 s = mix(vec4(0.0), col2, 0.9);\n            col = mix(s, col2, smoothstep(0.0, 0.5, abs(d)));\n        } else {\n            //line3 y=6x+b (0.3~1)\n            float a = time-1.0;\n            dis = -14.28*a*a+1.0;\n            d = (1.0 - textureCoordinate.y) - (6.0 * textureCoordinate.x + dis);\n            vec4 col2;\n            if(d>0.0){\n                vec4 textureColor = texture2D(inputImageTexture, zoom(textureCoordinate, scale, vec2(m, -scale/2.0)));\n                col2 = colorFilter2(textureColor);\n                vec4 s = mix(vec4(0.0), col2, 0.9);\n                col = mix(s, col2, smoothstep(0.0, 0.5, abs(d)));\n            }else{\n                float d = -0.05*time+0.05;\n                vec2 t;\n                t.y= textureCoordinate.y;\n                if(textureCoordinate.x < d){\n                    t.x=-textureCoordinate.x+d;\n                }else{\n                    t.x=textureCoordinate.x-d;\n                }\n                vec4 textureColor2 = texture2D(inputImageTexture, t);\n                col = textureColor2;\n            }\n        }\n    }\n    return col;\n}\n\nvoid main()\n{\n    float time = getAnimationTime();\n    if (time > 0.0 && time < 0.99) {\n        motionDirection = int(commonParamVec4.x);\n        if (motionDirection == 1){\n            gl_FragColor = getCutCol(time);\n        }else{\n            gl_FragColor = getCutColRev(time);\n        }\n    }else{\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n");
      localConfigData.mDuration = 1800L;
      localConfigData.mID = paramInt;
      localConfigData.mCommonFloat1 = new TransferConfig.ExtendParamFloats(new float[] { 1.0F, 2.0F }, 0, 2, 0);
      return localConfigData;
    case 10: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;\nuniform vec2 inputImageTextureSize;\n\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTexture2Size;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nuniform vec4 commonParamVec4;\n\nint motionDirection = 1; //1=上,2=下,3=左,4=右,5=上左,6=上右,7=下左,8=下右\n\nconst float SpeedPowValue = 4.0;\nconst float MotionBlurMaxStrength = 0.07;\nconst float TextureChangeTime = 0.4;\nconst float ImageRepeatCount1 = 2.5;\nconst float ImageRepeatCount2 = 1.0;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nfloat adjustTextureCoordinateIfOutOfRange(float coordinateValue)\n{\n    float adjustValue = mod(abs(coordinateValue), 2.0);\n    if (adjustValue > 1.0)\n        adjustValue =  2.0 - adjustValue;\n    return adjustValue;\n}\n\nvoid setMotionDirection(float directionParam)\n{\n    motionDirection = int(directionParam);\n    if (motionDirection < 1 || motionDirection > 8)\n        motionDirection = 3;\n}\n\nfloat motionXWeight()\n{\n    if (motionDirection == 3 || motionDirection == 5 || motionDirection == 7)\n        return 1.0;\n    else if (motionDirection == 4 || motionDirection == 6 || motionDirection == 8)\n        return -1.0;\n    else\n        return 0.0;\n}\n\nfloat motionYWeight()\n{\n    if (motionDirection == 1 || motionDirection == 5 || motionDirection == 6)\n        return 1.0;\n    else if (motionDirection == 2 || motionDirection == 7 || motionDirection == 8)\n        return -1.0;\n    else\n        return 0.0;\n}\n\n//滚动\n\nvec2 getScroll(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 outputTextureCoordinate = inputTextureCoordinate;\n    if (animationTime < TextureChangeTime) {\n        float moveValue = pow(animationTime, SpeedPowValue) * pow(1.0/TextureChangeTime, SpeedPowValue) * ImageRepeatCount1;\n        outputTextureCoordinate.x += moveValue * motionXWeight();\n        outputTextureCoordinate.y += moveValue * motionYWeight();\n    }\n    else {\n        float moveValue = (-1.0) * pow((1.0 - animationTime), SpeedPowValue) * pow(1.0/(1.0-TextureChangeTime), SpeedPowValue) * ImageRepeatCount2;\n        outputTextureCoordinate.x += moveValue * motionXWeight();\n        outputTextureCoordinate.y += moveValue * motionYWeight();\n    }\n    return outputTextureCoordinate;\n}\n\n//运动模糊\n\nfloat rand (vec2 inputTextureCoordinate)\n{\n    return fract(sin(dot(inputTextureCoordinate.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor(sampler2D imageTexture, vec2 inputTextureCoordinate)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    textureCoordinateUse.x = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.x);\n    textureCoordinateUse.y = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.y);\n    return texture2D(imageTexture, textureCoordinateUse);\n}\n\nvec4 motionBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed)\n{\n    vec2 texCoord = inputTextureCoordinate.xy / vec2(1.0).xy;\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= 20.0; t++) {\n        float percent = (t + offset) / 20.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += getColor(imageTexture, texCoord + speed * percent).rgb * weight;\n        total += weight;\n    }\n    return vec4(color / total, 1.0);\n}\n\n//main\n\nvoid main()\n{\n    setMotionDirection(commonParamVec4.x);\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n        vec2 textureCoordinateUse = getScroll(textureCoordinate, animationTime);\n        \n        float timeInterval = 0.0001;\n        if (animationTime < TextureChangeTime && animationTime + timeInterval > TextureChangeTime)\n            timeInterval = TextureChangeTime - animationTime;\n        vec2 textureCoordinateNext = getScroll(textureCoordinate, animationTime + timeInterval);\n        vec2 speed = (textureCoordinateNext - textureCoordinateUse) / timeInterval * MotionBlurMaxStrength;\n        \n        if (animationTime < TextureChangeTime)\n            gl_FragColor = motionBlur(inputImageTexture2, textureCoordinateUse, speed);\n        else\n            gl_FragColor = motionBlur(inputImageTexture, textureCoordinateUse, speed);\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n\n");
      localConfigData.mDuration = 740L;
      localConfigData.mID = paramInt;
      localConfigData.mCommonFloat1 = new TransferConfig.ExtendParamFloats(new float[] { 2.0F, 3.0F, 6.0F, 3.0F }, 0, 2, 0);
      return localConfigData;
    case 9: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvoid main()\n{\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n\tfloat x = animationTime - 1.0;\n\tanimationTime = x * x * x + 1.0;\n        float divide = 1.0 - animationTime;\n\tif (textureCoordinate.x < divide) {\n\t\tgl_FragColor = texture2D(inputImageTexture2, textureCoordinate.xy + vec2(animationTime, 0.0));\n\t} else {\n\t\tfloat dis = 0.2 * (1.0 - animationTime);\n\t\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate.xy - vec2(divide - dis, 0.0));\n  \t}\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}");
      localConfigData.mDuration = 1000L;
      localConfigData.mID = paramInt;
      return localConfigData;
    case 8: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  float phase = time < 0.5 ? time * 2.0 : (time - 0.5) * 2.0;\n  vec4 c = time < 0.5 ? texture2D(inputImageTexture2, textureCoordinate) : texture2D(inputImageTexture, textureCoordinate);\n  vec4 mixCol = vec4(1.0 , 1.0 , 1.0 , 1.0);\n  return c + (time < 0.5 ? mix(vec4(0.0), mixCol, phase) : mix(mixCol, vec4(0.0), phase));\n}\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}");
      localConfigData.mDuration = 1000L;
      localConfigData.mID = paramInt;
      return localConfigData;
    case 7: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nvec2 direction = vec2(1.0, 1.0);\nfloat smoothness = 0.5;\n \nconst vec2 center = vec2(0.5, 0.5);\n \n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, uv);\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  vec2 v = normalize(direction);\n  v /= abs(v.x)+abs(v.y);\n  float d = v.x * center.x + v.y * center.y;\n  float m = (1.0-step(time, 0.0)) * (1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d-0.5+time*(1.+smoothness))));\n  return mix(fromCol, toCol, m);\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}");
      localConfigData.mDuration = 1200L;
      localConfigData.mID = paramInt;
      return localConfigData;
    case 6: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nfloat nQuick = 0.8;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec2 zoom(vec2 uv, float amount) {\n  return 0.5 + ((uv - 0.5) * (1.0-amount));\t\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, zoom(uv, smoothstep(0.0, nQuick, time)));\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  return mix(fromCol,toCol,smoothstep(0.4, 1.0, time));\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}");
      localConfigData.mDuration = 1200L;
      localConfigData.mID = paramInt;
      return localConfigData;
    case 5: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nvec3 color = vec3(0.0);\nfloat colorPhase = 0.4 ; \n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, uv);\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  return mix(\n    mix(vec4(color, 1.0), fromCol, smoothstep(1.0-colorPhase, 0.0, time)),\n    mix(vec4(color, 1.0), toCol, smoothstep(colorPhase, 1.0, time)),\n    time);\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}");
      localConfigData.mDuration = 1200L;
      localConfigData.mID = paramInt;
      return localConfigData;
    case 4: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTextureSize;\nuniform vec2 inputImageTexture2Size;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nvarying vec2 textureCoordinate;\nconst int passes = 6;\nfloat intensity = 0.02;\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getBlur(float time, sampler2D texture, vec2 coordinate){\n   vec4 c1 = vec4(0.0);\n   float disp = intensity*time;\n   for (int xi=0; xi<passes; xi++)\n    {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++)\n        {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D( texture, coordinate + d*v);\n        }\n    }\n   c1 /= float(passes*passes);\n   return c1;\n}void main()\n{\n   float animationTime = getAnimationTime();\n   if (animationTime > 0.0 && animationTime < 0.99) {\n       vec4 c1 = vec4(0.0);\n       vec4 c2 = vec4(0.0);\n       if(animationTime>0.0 && animationTime<=0.4){\n           c2 = getBlur(smoothstep(0.0 , 0.4, animationTime), inputImageTexture2, textureCoordinate);\n           gl_FragColor = c2;\n       }else{\n           c2 = getBlur(smoothstep(0.0 , 0.4, animationTime), inputImageTexture2, textureCoordinate);\n           c1 = getBlur(1.0-smoothstep(0.4 , 0.99, animationTime), inputImageTexture, textureCoordinate);\n           gl_FragColor = vec4(mix(c2.rgb, c1.rgb, smoothstep(0.4 , 0.99, animationTime)),1.0);\n       }    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}");
      localConfigData.mDuration = 1000L;
      localConfigData.mID = paramInt;
      return localConfigData;
    case 3: 
      localConfigData.addShaderToList(null, "\n//输入参数\n// @param: duration：1.0s\n\nprecision highp float;\n\nvarying vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\nuniform vec2 inputImageTextureSize;\n\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTexture2Size;\n\nuniform vec3 iResolution;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nfloat TextureChangeTime = 0.4;\nfloat ImageRepeatCount1 = 0.4;\nfloat ImageRepeatCount2 = 2.0;\nfloat SpeedPowValue = 5.0;\nfloat MinimaxBlurMaxStrength1 = 0.2;\nfloat MinimaxBlurMaxStrength2 = 0.08;\nfloat RGBShiftMaxStrength = 0.005;\nfloat RGBShiftSpeedPowValue = 2.0;\nfloat SampleNumber = 20.0;\n\nmat4 blurStripYBegin1 =  mat4(0.0, 0.0, 0.0, 0.0,\n                              0.3, 0.2, 0.4, 0.35,\n                              0.6, 0.5, 0.6, 0.40,\n                              0.8, 0.7, 0.8, 0.7);\n\nmat4 blurStripYBegin2 =  mat4(0.0, 0.1, 0.0, 0.0,\n                              0.5, 0.15, 0.3, 0.10,\n                              0.6, 0.45, 0.5, 0.50,\n                              0.8, 0.7, 0.8, 0.85);\n\nmat4 blurStripYBegin3 =  mat4(0.2, 0.1, 0.0, 0.0,\n                              0.4, 0.4, 0.4, 0.35,\n                              0.45, 0.55, 0.6, 0.55,\n                              0.7, 0.7, 0.8, 0.8);\n\nmat4 blurStripYLength1 = mat4(0.05, 0.2, 0.2, 0.3,\n                              0.2, 0.3, 0.2, 0.3,\n                              0.3, 0.2, 0.3, 0.4,\n                              0.1, 0.25, 0.2, 0.3);\n\nmat4 blurStripYLength2 = mat4(0.3, 0.2, 0.2, 0.3,\n                              0.2, 0.3, 0.2, 0.3,\n                              0.05, 0.2, 0.3, 0.4,\n                              0.2, 0.3, 0.2, 0.3);\n\nmat4 blurStripYLength3 = mat4(0.1, 0.2, 0.2, 0.3,\n                              0.3, 0.2, 0.2, 0.3,\n                              0.05, 0.2, 0.3, 0.4,\n                              0.3, 0.2, 0.2, 0.3);\n\nmat4 blurStripXBegin =   mat4(0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0);\n\nmat4 blurStripXLength = mat4(1.0, 1.0, 1.0, 1.0,\n                             1.0, 1.0, 1.0, 1.0,\n                             1.0, 1.0, 1.0, 1.0,\n                             1.0, 1.0, 1.0, 1.0);\n\nmat4 blurStripValue1 =   mat4(1.0, -1.0, 1.0, 1.0,\n                             -1.0, -1.0, -1.0, -1.0,\n                              1.0, 1.0, -1.0, 1.0,\n                             -1.0, -1.0, 1.0, 1.0);\n\nmat4 blurStripValue2 =   mat4(1.0, 1.0, -1.0, 1.0,\n                             -1.0, -1.0, 1.0, -1.0,\n                             -1.0, 1.0, -1.0, 1.0,\n                              1.0, 1.0, 1.0, 1.0);\n\nmat4 blurStripValue3 =   mat4(-1.0, -1.0, -1.0, 1.0,\n                              1.0, -1.0, 1.0, -1.0,\n                              -1.0, 1.0, -1.0, 1.0,\n                              1.0, -1.0, 1.0, -1.0);\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nfloat adjustTextureCoordinateIfOutOfRange(float coordinateValue)\n{\n    float adjustValue = mod(abs(coordinateValue), 2.0);\n    if (adjustValue > 1.0)\n        adjustValue =  2.0 - adjustValue;\n    return adjustValue;\n}\n\nvec2 getImageTextureSize(float animationTime)\n{\n    //return iResolution.xy;\n    if (animationTime < TextureChangeTime)\n        return inputImageTexture2Size;\n    else\n        return inputImageTextureSize;\n}\n\nfloat getMinimaxBlurMaxStrength(float animationTime)\n{\n    if (animationTime < TextureChangeTime)\n        return MinimaxBlurMaxStrength1;\n    else\n        return MinimaxBlurMaxStrength2;\n}\n\n//滚动\n\nvec2 getScroll(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 outputTextureCoordinate = inputTextureCoordinate;\n    if (animationTime < TextureChangeTime)\n        outputTextureCoordinate.x += pow(animationTime, SpeedPowValue) * pow(1.0/TextureChangeTime, SpeedPowValue) * ImageRepeatCount1;\n    else\n        outputTextureCoordinate.x += pow((1.0 - animationTime), SpeedPowValue) * pow(1.0/(1.0-TextureChangeTime), SpeedPowValue) * ImageRepeatCount2 * (-1.0);\n    return outputTextureCoordinate;\n}\n\n//Color\n\nvec4 getColor(sampler2D imageTexture, vec2 inputTextureCoordinate)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    textureCoordinateUse.x = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.x);\n    textureCoordinateUse.y = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.y);\n    return texture2D(imageTexture, textureCoordinateUse);\n}\n\nvec4 getColorWithRGBShift(sampler2D imageTexture, vec2 inputTextureCoordinate, float animationTime)\n{\n    float shiftTime = animationTime;\n    if (animationTime > TextureChangeTime)\n        shiftTime = 1.0 - animationTime;\n    vec2 shiftCoord = inputTextureCoordinate;\n    shiftCoord.x += pow(shiftTime, RGBShiftSpeedPowValue) * pow(2.0, RGBShiftSpeedPowValue) * RGBShiftMaxStrength;\n    vec4 colorR = getColor(imageTexture, shiftCoord);\n    vec4 colorGB = getColor(imageTexture, inputTextureCoordinate);\n    return vec4(colorR.r, colorGB.g, colorGB.b, 1.0);\n}\n\n//Minimax模糊\n\nfloat rand(vec2 inputTextureCoordinate)\n{\n    return fract(sin(dot(inputTextureCoordinate.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat brightOfColor(vec4 color)\n{\n    return color.r + color.g + color.b;\n}\n\nvec4 maxBrightColor(vec4 color1, vec4 color2)\n{\n    if (brightOfColor(color1) > brightOfColor(color2))\n        return color1;\n    else\n        return color2;\n}\n\nvec4 minBrightColor(vec4 color1, vec4 color2)\n{\n    if (brightOfColor(color1) > brightOfColor(color2))\n        return color2;\n    else\n        return color1;\n}\n\nvec4 maxValueBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed, float animationTime)\n{\n    float imageSideLength = getImageTextureSize(animationTime).x;\n    vec2 blurStrength = getMinimaxBlurMaxStrength(animationTime) * speed;\n    float sampleRatio = float(ceil((imageSideLength * abs(blurStrength.x)) / SampleNumber));\n    sampleRatio = max(sampleRatio, 1.0);\n    vec4 maxColor = vec4(0.0);\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= SampleNumber; t++) {\n        float percent = (t + offset) / SampleNumber;\n        vec2 sampleCoord = inputTextureCoordinate + blurStrength * percent;\n        sampleCoord.x = floor(sampleCoord.x * imageSideLength / sampleRatio) * sampleRatio / imageSideLength;\n        sampleCoord.y = inputTextureCoordinate.y;\n        maxColor = maxBrightColor(maxColor, getColorWithRGBShift(imageTexture, sampleCoord, animationTime));\n    }\n    return maxColor;\n}\n\nvec4 minValueBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed, float animationTime)\n{\n    float imageSideLength = getImageTextureSize(animationTime).x;\n    vec2 blurStrength = getMinimaxBlurMaxStrength(animationTime) * speed;\n    float sampleRatio = float(ceil((imageSideLength * abs(blurStrength.x)) / SampleNumber));\n    sampleRatio = max(sampleRatio, 1.0);\n    vec4 minColor = vec4(1.0);\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= SampleNumber; t++) {\n    float percent = (t + offset) / SampleNumber;\n        vec2 sampleCoord = inputTextureCoordinate + blurStrength * percent;\n        sampleCoord.x = floor(sampleCoord.x * imageSideLength / sampleRatio) * sampleRatio / imageSideLength;\n        sampleCoord.y = inputTextureCoordinate.y;\n        minColor = minBrightColor(minColor, getColorWithRGBShift(imageTexture, sampleCoord, animationTime));\n    }\n    return minColor;\n}\n\nfloat getMaskValue(vec2 textureCoordinate,  float animationTime)\n{\n    float maskTime = animationTime;\n    if (maskTime > TextureChangeTime)\n        maskTime = 1.0 - maskTime;\n\n    int timeIndex = int(floor(maskTime * 2.0 * 4.0));\n    if (timeIndex > 3)\n        timeIndex = 3;\n\n    int matIndex = int(floor(fract(textureCoordinate.y / 0.5) * 2.0 * 3.0));\n    mat4 blurStripYBegin = blurStripYBegin1;\n    mat4 blurStripValue = blurStripValue1;\n    mat4 blurStripYLength = blurStripYLength1;\n    if (matIndex == 1) {\n        blurStripYBegin = blurStripYBegin2;\n        blurStripYLength = blurStripYLength2;\n        blurStripValue = blurStripValue2;\n    } else if (matIndex == 2) {\n        blurStripYBegin = blurStripYBegin3;\n        blurStripYLength = blurStripYLength3;\n        blurStripValue = blurStripValue3;\n    }\n\n    float yOffset = fract(textureCoordinate.y * 2.0 * 3.0);\n\n    int rowIndex = -1;\n    for (int i = 0; i < 4; i++) {\n    float yBeign = blurStripYBegin[i][timeIndex];\n    if (yOffset < yBeign)\n        break;\n    else\n        rowIndex = i;\n    }\n\n    if (rowIndex < 0)\n        return 0.0;\n\n    float stripEnd = blurStripYBegin[rowIndex][timeIndex] + blurStripYLength[rowIndex][timeIndex];\n    if (yOffset < blurStripYBegin[rowIndex][timeIndex] + blurStripYLength[rowIndex][timeIndex] && textureCoordinate.x > blurStripXBegin[rowIndex][timeIndex] && textureCoordinate.x < blurStripXBegin[rowIndex][timeIndex] + blurStripXLength[rowIndex][timeIndex])\n        return blurStripValue[rowIndex][timeIndex];\n    else\n        return 0.0;\n}\n\nvec4 minimaxBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 originTextureCoordinate, vec2 speed, float animationTime)\n{\n    int maskValue = int(getMaskValue(originTextureCoordinate, animationTime));\n    if (maskValue > 0) {\n        return maxValueBlur(imageTexture, inputTextureCoordinate, speed, animationTime);\n    } else if (maskValue < 0) {\n        return minValueBlur(imageTexture, inputTextureCoordinate, speed * 0.25, animationTime);\n    } else {\n        return maxValueBlur(imageTexture, inputTextureCoordinate, speed * 0.25, animationTime);\n    }\n}\n\n//main\n\nvoid main()\n{\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n        vec2 textureCoordinateUse = textureCoordinate ;\n        textureCoordinateUse = getScroll(textureCoordinateUse, animationTime);\n        \n        float timeInterval = 0.0001;\n        if (animationTime < TextureChangeTime && animationTime + timeInterval > TextureChangeTime)\n            timeInterval = TextureChangeTime - animationTime;\n        \n        vec2 textureCoordinateNext = getScroll(textureCoordinate, animationTime - timeInterval);\n        vec2 speed = (textureCoordinateNext - textureCoordinateUse) / timeInterval;\n        \n        if (animationTime < TextureChangeTime)\n            gl_FragColor = minimaxBlur(inputImageTexture2, textureCoordinateUse, textureCoordinate, speed, animationTime);\n        else\n            gl_FragColor = minimaxBlur(inputImageTexture, textureCoordinateUse, textureCoordinate, speed, animationTime);\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n");
      localConfigData.mDuration = 1000L;
      localConfigData.mID = paramInt;
      return localConfigData;
    case 2: 
      localConfigData.addShaderToList("uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}", "precision highp float;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTextureSize;\nuniform vec2 inputImageTexture2Size;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nvarying vec2 textureCoordinate;\nvoid main()\n{\nhighp vec2 size = inputImageTextureSize - inputImageTexture2Size;\nif (time > timeRange.x && time < timeRange.y + timeRange.x)\n{\nsize.x = 0.5;\nsize.y = 0.5;\n}\nelse\n{\nsize.x = 0.5;\nsize.y = 0.5;\n};\ngl_FragColor = texture2D(inputImageTexture, textureCoordinate) * size.x + texture2D(inputImageTexture2, textureCoordinate) * size.y;\n}");
      localConfigData.mDuration = 1000L;
      localConfigData.mID = paramInt;
      return localConfigData;
    }
    localConfigData.addShaderToList(null, "//输入参数\n// @param: duration：1.2s\n\nprecision highp float;\n\nvarying vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\nuniform vec2 inputImageTextureSize;\n\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTexture2Size;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nuniform vec4 commonParamVec4;\n\nint motionDirection = 1; //1=上左,2=上右,3=下左,4=下右\n\nconst float ImageRepeatCount = 2.0;\nconst float RotateMaxAngle = 45.0;\nconst float SpeedPowValue = 5.0;\nconst float MotionBlurMaxStrength = 0.05;\nconst float MaxStretchRatio = 3.5;\nconst float StretchSpeedPowValue = 3.0;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nfloat adjustTextureCoordinateIfOutOfRange(float coordinateValue)\n{\n    float adjustValue = mod(abs(coordinateValue), 2.0);\n    if (adjustValue > 1.0)\n        adjustValue =  2.0 - adjustValue;\n    return adjustValue;\n}\n\nvoid setMotionDirection(float directionParam)\n{\n    motionDirection = int(directionParam);\n    if (motionDirection != 1 && motionDirection != 2 && motionDirection != 3 && motionDirection != 4)\n        motionDirection = 1;\n}\n\nfloat isMotionUp()\n{\n    if (motionDirection == 1 || motionDirection == 2)\n        return 1.0;\n    else\n        return -1.0;\n}\n\nfloat isMotionLeft()\n{\n    if (motionDirection == 1 || motionDirection == 3)\n        return 1.0;\n    else\n        return -1.0;\n}\n\n//滚动\n\nvec2 getScroll(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 outputTextureCoordinate = inputTextureCoordinate;\n    if (animationTime < 0.5)\n        outputTextureCoordinate.y += pow(animationTime, SpeedPowValue) * pow(2.0, SpeedPowValue) * ImageRepeatCount * isMotionUp();\n    else\n        outputTextureCoordinate.x += pow((1.0 - animationTime), SpeedPowValue) * pow(2.0, SpeedPowValue) * ImageRepeatCount * (-1.0) * isMotionLeft();\n    return outputTextureCoordinate;\n}\n\n//旋转\n\nfloat getRotateAngleFromTime(float animationTime)\n{\n    if (animationTime < 0.5)\n        return pow(animationTime, SpeedPowValue) * pow(2.0, SpeedPowValue) * RotateMaxAngle * isMotionUp() * isMotionLeft();\n    else\n        return pow((1.0 - animationTime), SpeedPowValue) * pow(2.0, SpeedPowValue) * RotateMaxAngle * (-1.0) * isMotionUp() * isMotionLeft();\n}\n\nvec2 getRotate(vec2 inputTextureCoordinate, float angle, vec2 rotateCenter)\n{\n    vec2 textureCoordinateUse;\n    float degree = radians(angle);\n    float c = cos(degree);\n    float s = sin(degree);\n    textureCoordinateUse.x = (inputTextureCoordinate.x - rotateCenter.x) * c - (inputTextureCoordinate.y - rotateCenter.y) * s + rotateCenter.x;\n    textureCoordinateUse.y = (inputTextureCoordinate.x - rotateCenter.x) * s + (inputTextureCoordinate.y - rotateCenter.y) * c + rotateCenter.y;\n    return textureCoordinateUse;\n}\n\n//运动模糊\n\nfloat rand (vec2 inputTextureCoordinate)\n{\n    return fract(sin(dot(inputTextureCoordinate.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor(sampler2D imageTexture, vec2 inputTextureCoordinate)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    textureCoordinateUse.x = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.x);\n    textureCoordinateUse.y = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.y);\n    return texture2D(imageTexture, textureCoordinateUse);\n}\n\nvec4 motionBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed)\n{\n    vec2 texCoord = inputTextureCoordinate.xy / vec2(1.0).xy;\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= 20.0; t++) {\n        float percent = (t + offset) / 20.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += getColor(imageTexture, texCoord + speed * percent).rgb * weight;\n        total += weight;\n    }\n    return vec4(color / total, 1.0);\n}\n\nvec2 getMotionTransition(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 textureCoordinateUse = getScroll(inputTextureCoordinate, animationTime);\n    float angle = getRotateAngleFromTime(animationTime);\n    vec2 rotateCenter = getScroll(vec2(0.5, 0.5), animationTime);\n    textureCoordinateUse = getRotate(textureCoordinateUse, angle, rotateCenter);\n    return textureCoordinateUse;\n}\n\n//拉伸\n\nvec2 getStretchTransition(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    float currentMaxStretchRatio = 1.0;\n    if (animationTime < 0.5)\n        currentMaxStretchRatio = pow(animationTime, StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n    else\n        currentMaxStretchRatio = pow((1.0 - animationTime), StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n    float stretchRatio = (currentMaxStretchRatio - 1.0) * (1.0 - inputTextureCoordinate.y) + 1.0;\n    textureCoordinateUse.x = (inputTextureCoordinate.x - 0.5) / stretchRatio + 0.5;\n    return textureCoordinateUse;\n}\n\n//main\n\nvoid main()\n{\n    setMotionDirection(commonParamVec4.x);\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n        vec2 textureCoordinateUse = getStretchTransition(textureCoordinate, animationTime);\n        textureCoordinateUse = getMotionTransition(textureCoordinateUse, animationTime);\n        \n        float timeInterval = 0.0001;\n        if (animationTime < 0.5 && animationTime + timeInterval > 0.5)\n            timeInterval = 0.5 - animationTime;\n        vec2 textureCoordinateNext = getStretchTransition(textureCoordinate, animationTime + timeInterval);\n        textureCoordinateNext = getMotionTransition(textureCoordinateNext, animationTime + timeInterval);\n        vec2 speed = (textureCoordinateNext - textureCoordinateUse) / timeInterval * MotionBlurMaxStrength;\n        \n        if (animationTime < 0.5)\n            gl_FragColor = motionBlur(inputImageTexture2, textureCoordinateUse, speed);\n        else\n            gl_FragColor = motionBlur(inputImageTexture, textureCoordinateUse, speed);\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n\n");
    localConfigData.mDuration = 1200L;
    localConfigData.mID = paramInt;
    localConfigData.mCommonFloat1 = new TransferConfig.ExtendParamFloats(new float[] { 1.0F, 2.0F, 3.0F, 4.0F }, 0, 2, 0);
    return localConfigData;
  }
  
  public static boolean isConfigValid(int paramInt)
  {
    return paramInt == 0;
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes8.jar
 * Qualified Name:     com.tencent.mobileqq.shortvideo.videotransfer.TransferConfig
 * JD-Core Version:    0.7.0.1
 */