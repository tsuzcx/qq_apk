package com.tencent.mm.plugin.voip.video.c;

import android.opengl.GLES20;
import com.tencent.matrix.trace.core.AppMethodBeat;
import com.tencent.mm.media.j.b.e;
import com.tencent.mm.media.k.c;
import com.tencent.mm.media.k.c.a;
import com.tencent.mm.plugin.voip.b.g;
import com.tencent.mm.plugin.voip.video.render.a;
import java.nio.ByteBuffer;
import kotlin.g.a.r;
import kotlin.g.b.q;
import kotlin.l;
import kotlin.x;

@l(hxD={1, 1, 16}, hxE={""}, hxF={"Lcom/tencent/mm/plugin/voip/video/programv2/VoipMMFaceBeautyRendererProgram;", "", "()V", "attributePosition", "", "attributeTextureCoord", "brightnessUniform", "programId", "renderProc", "Lcom/tencent/mm/media/render/proc/GLTextureRenderProcTexture;", "showCounterUniform", "showModeUniform", "smoothDegreeUniform", "surfaceOut", "Lcom/tencent/mm/plugin/voip/video/render/EncoderSurfaceRender;", "texelHeightUniform", "texelWidthUniform", "uniformMatrix", "uniformTexture", "useGpuConvert", "", "release", "", "renderImpl", "drawWidth", "drawHeight", "cubeBuffer", "Ljava/nio/FloatBuffer;", "textureCoordBuff", "texture", "outputTexture", "Lcom/tencent/mm/media/globject/GLTextureObject;", "encodeRotate", "encodeMirror", "setFaceBeautyDataCallback", "callback", "Lkotlin/Function4;", "Ljava/nio/ByteBuffer;", "Lcom/tencent/mm/plugin/voip/video/program/FaceBeautyDataCallBack;", "updateEncodeResType", "encWidth", "encHeight", "encoderType", "plugin-voip_release"})
public final class b
{
  public int Hle;
  public int Hlf;
  public int Hlg;
  public int Hlh;
  public int Hli;
  public int Hlj;
  public a Hms;
  public final boolean Hmt;
  public int hEA;
  public e hEx;
  public int hEy;
  public int hEz;
  public int programId;
  
  public b()
  {
    AppMethodBeat.i(236169);
    Object localObject = g.HgZ;
    this.Hmt = g.fKi();
    localObject = c.ilt;
    this.programId = c.a.aB("\n        attribute vec4 a_position;\n        attribute vec2 a_texCoord;\n        varying vec2 v_texCoord;\n        void main() {\n            gl_Position = a_position;\n            v_texCoord = a_texCoord;\n        }\n        ", "\n                    #extension GL_OES_EGL_image_external : require\n                    varying highp vec2 v_texCoord;\n                    uniform samplerExternalOES inputImageTexture;\n                    uniform mediump float smoothDegree;\n                    uniform mediump int showCounter;\n                    uniform mediump int showMode;\n                    uniform mediump float brightness;\n                    uniform mediump float texelWidth;\n                    uniform mediump float texelHeight;\n                    precision highp float;\n                    const mat3 RGBtoYUV = mat3(0.299,  0.587, 0.114, 0.5, -0.4187, -0.0813, -0.169, -0.3313,  0.5 );    //full range\\n\" +\n                    const mat3 YUVtoRGB = mat3(1.1643, 1.5958, 0.0, 1.1643, -0.8129, -0.3917, 1.1643, 0.0, 2.017 );\n                    const highp mat3 saturateMatrix = mat3(\n                    1.1102, -0.0598, -0.061,\n                    -0.0774, 1.0826, -0.1186,\n                    -0.0228, -0.0228, 1.1772);\n                    vec3 rgb2hsv(vec3 c) {\n                        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n                        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n                        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n                        float d = q.x - min(q.w, q.y);\n                        float e = 1.0e-10;\n                        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n                    }\n                    vec3 hsv2rgb(vec3 c) {\n                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n                    }\n\n                    vec3 yuv2rgb(vec3 c) {\n                        vec3 rgb = YUVtoRGB*c;\n                        return rgb;\n                    }\n                    vec3 rgb2yuv(vec3 c) {\n                        vec3 yuv = c*RGBtoYUV;\n                        return yuv;\n                    }\n                    mediump float hardLight(mediump float color) {\n                        if (color <= 0.5)\n                        color = color * color * 2.0;\n                        else\n                        color = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n                        return color;\n                    }\n                    float lum(vec3 v) {\n                        return dot(v, vec3(0.299, 0.587, 0.114));\n                    }\n\n                    vec4 getValue(vec4 newValue, vec4 originValue) {\n                        return mix(newValue, originValue, step(lum(newValue.rgb), lum(originValue.rgb)));\n                    }\n                    vec4 Sobel2() {\n                        vec2 samplerSteps = vec2(1.0/texelWidth, 1.0/texelHeight);\n                        vec2 coords[8];\n                        coords[0] = v_texCoord - samplerSteps * 2.0;\n                        coords[1] = v_texCoord + vec2(0.0, -samplerSteps.y) * 2.0;\n                        coords[2] = v_texCoord + vec2(samplerSteps.x, -samplerSteps.y) * 2.0;\n                        coords[3] = v_texCoord - vec2(samplerSteps.x, 0.0) * 2.0;\n                        coords[4] = v_texCoord + vec2(samplerSteps.x, 0.0) * 2.0;\n                        coords[5] = v_texCoord + vec2(-samplerSteps.x, samplerSteps.y) * 2.0;\n                        coords[6] = v_texCoord + vec2(0.0, samplerSteps.y) * 2.0;\n                        coords[7] = v_texCoord + vec2(samplerSteps.x, samplerSteps.y) * 2.0;\n                        vec3 colors[8];\n                        for(int i = 0; i < 8; ++i) {\n                            colors[i] = texture2D(inputImageTexture, coords[i]).rgb;\n                        }\n                        vec4 src = texture2D(inputImageTexture, v_texCoord);\n                        vec3 h = -colors[0] - 2.0 * colors[1] - colors[2] + colors[5] + 2.0 * colors[6] + colors[7];\n                        vec3 v = -colors[0] + colors[2] - 2.0 * colors[3] + 2.0 * colors[4] - colors[5] + colors[7];\n                        return vec4(mix(src.rgb, sqrt(h * h + v * v), 1.0), src.a);\n                    }\n                    vec4 maxFilter() {\n                        vec2 samplerSteps = vec2(1.0/texelWidth, 1.0/texelHeight);\n                        vec2 texCoord[13];\n                        vec4 vMin;\n                        vec2 thisCoord = v_texCoord;\n                        texCoord[0] = thisCoord + vec2(0, -samplerSteps.y * 2.0);\n                        texCoord[1] = thisCoord - samplerSteps;\n                        texCoord[2] = thisCoord + vec2(0, -samplerSteps.y);\n                        texCoord[3] = thisCoord + vec2(samplerSteps.x, -samplerSteps.y);\n                        texCoord[4] = thisCoord + vec2(-samplerSteps.x * 2.0, 0.0);\n                        texCoord[5] = thisCoord + vec2(-samplerSteps.x, 0.0);\n                        texCoord[6] = thisCoord;\n                        texCoord[7] = thisCoord + vec2(samplerSteps.x, 0.0);\n                        texCoord[8] = thisCoord + vec2(samplerSteps.x * 2.0, 0.0);\n                        texCoord[9] = thisCoord + vec2(-samplerSteps.x, samplerSteps.y);\n                        texCoord[10] = thisCoord + vec2(0.0, samplerSteps.y);\n                        texCoord[11] = thisCoord + samplerSteps;\n                        texCoord[12] = thisCoord + vec2(0.0, 2.0* samplerSteps.y);\n                        {\n                            vec4 vTemp;\n                            vMin = texture2D(inputImageTexture, texCoord[0]);\n                            vTemp = texture2D(inputImageTexture, texCoord[1]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[2]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[3]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[4]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[5]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[6]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[7]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[8]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[9]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[10]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[11]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[12]);\n                            vMin = getValue(vTemp, vMin);\n                        }\n                        return vMin;\n                    }\n\n                    void main() {\n                        highp vec3 yuv;\n                        highp vec3 rgb;\n                        vec3 centralColor = texture2D(inputImageTexture,  v_texCoord).rgb;\n                        vec2 blurCoordinates[20];\n                        vec2 imageStep = vec2(1.5/texelWidth, 1.5/texelHeight);\n                        //重新调整了滤波的范围和权重，减少水波纹\n                        blurCoordinates[0] = v_texCoord + vec2(0.0, -4.0) * imageStep;\n                        blurCoordinates[1] = v_texCoord + vec2(2.0, -3.0) * imageStep;\n                        blurCoordinates[2] = v_texCoord + vec2(3.0, -2.0) * imageStep;\n                        blurCoordinates[3] = v_texCoord + vec2(4.0, 0.0) * imageStep;\n                        blurCoordinates[4] = v_texCoord + vec2(3.0, 2.0) * imageStep;\n                        blurCoordinates[5] = v_texCoord + vec2(2.0, 3.0) * imageStep;\n                        blurCoordinates[6] = v_texCoord + vec2(0.0, 4.0) * imageStep;\n                        blurCoordinates[7] = v_texCoord + vec2(-2.0, 3.0) * imageStep;\n                        blurCoordinates[8] = v_texCoord + vec2(-3.0, 2.0) * imageStep;\n                        blurCoordinates[9] = v_texCoord + vec2(-4.0, 0.0) * imageStep;\n                        blurCoordinates[10] = v_texCoord + vec2(-3.0, -2.0) * imageStep;\n                        blurCoordinates[11] = v_texCoord + vec2(-2.0, -3.0) * imageStep;\n                        blurCoordinates[12] = v_texCoord + vec2(0.0, -2.0) * imageStep;\n                        blurCoordinates[13] = v_texCoord + vec2(-1.0, -1.0) * imageStep;\n                        blurCoordinates[14] = v_texCoord + vec2(-2.0, 0.0) * imageStep;\n                        blurCoordinates[15] = v_texCoord + vec2(-1.0, 1.0) * imageStep;\n                        blurCoordinates[16] = v_texCoord + vec2(0.0, 2.0) * imageStep;\n                        blurCoordinates[17] = v_texCoord + vec2(1.0, 1.0) * imageStep;\n                        blurCoordinates[18] = v_texCoord + vec2(2.0, 0.0) * imageStep;\n                        blurCoordinates[19] = v_texCoord + vec2(1.0, -1.0) * imageStep;\n                        vec3 sampleColor = centralColor * 24.0;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[0]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[1]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[2]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[3]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[4]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[5]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[6]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[7]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[8]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[9]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[10]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[11]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[12]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[13]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[14]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[15]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[16]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[17]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[18]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[19]).rgb;\n                        sampleColor = sampleColor/44.0;\n                        float dis = centralColor.g - sampleColor.g + 0.5;\n                        for (int i = 0; i < 5; i++) {\n                            dis = hardLight(dis);\n                        }\n                        // 0.065 -> 1.125, 加大滤波强度\n                        vec3 result = centralColor * 1.125 - dis * 0.125; //central+(central-dis)*0.065\n                        float hue = dot(result, vec3(0.299,0.587,0.114)) - 0.3;   //luminance\n                        hue = pow(clamp(hue, 0.0, 1.0), 0.3);\n                        yuv= rgb2yuv(sampleColor);\n                        float cr=yuv.y-0.094;\n                        float cb=yuv.z+0.0745;\n                        float tx = ((25.59*cr-19.19*cb)*255.0 + 51.0)*0.04;\n                        float ty = ((25.59*cr+19.19*cb)*255.0 + 77.0)*0.07;\n                        float val0 = tx*tx + ty*ty;\n                        float chroma_sum=yuv.y+yuv.z+1.0;\n                        float chroma_diff=yuv.y-yuv.z;\n                        float chroma_diff_th = 0.1-(yuv.x/10.0);\n                        float face = 1.0;\n                        if(yuv.z>-0.1667 && yuv.z<0.0294 && chroma_sum>0.7804 && chroma_sum<1.098 && chroma_diff>chroma_diff_th) {\n                            if(yuv.x<0.3922) {\n                                if(val0<1700.0) {\n                                    face = 0.0;\n                                } else {\n                                    hue = 0.0;\n                                }\n                            } else {\n                                if(val0<3150.0) {\n                                    face = 0.0;\n                                } else {\n                                    hue = 0.0;\n                                }\n                            }\n                        } else {\n                            hue = 0.0;\n                        }\n                        result = centralColor * (1.0 - hue) + result * hue;\n                        result = result+vec3(brightness*0.1);\n                        // 这里可以进一步简化计算\n                        if(showMode == 1 /*|| showMode == 2*/) {\n                             result = vec3(hue);\n                        }\n                        else if(showMode == 0) {\n                            result = centralColor;\n                        }\n                        vec3 smoothNew = mix(centralColor, result, smoothDegree);\n                    //showCounter用于显示mask\n                    if(showCounter == 1) {\n                        smoothNew =vec3(face);\n                    }\n                    //mode3:显示边缘\n                    if(showMode == 3) {\n                        vec3 maxValue = maxFilter().rgb;\n                        float lumOrigin = lum(centralColor);\n                        float lumMax = lum(maxValue) + 0.001;\n                        float blendColor = min(lumOrigin / lumMax, 1.0);\n                        float smoothDegree2 =  0.8 + (smoothDegree/5.0); //约束范围：0.8~1.0\n                        smoothNew =mix(centralColor, vec3(blendColor), smoothDegree2);\n                    }\n                    //mode4:显示轮廓\n                    if(showMode == 4) {\n                        vec4 src  = Sobel2();\n                        // saturation合并到level中\n                        max(src.r, src.g);\n                        float lum = (max(max(src.r, src.g),src.b) + min(min(src.r, src.g), src.b)) / 2.0;\n                        src = vec4(mix(vec3(lum), src.rgb, 0.0), src.a);  //intensity = 0.0\n                        // level filter: colorLevel.x = dark = 0.33, colorLevel.y = light = 0.60\n                        float colorLevelx = 0.3;\n                        float colorLevely = 0.60;\n                        //float gamma = 0.99;\n                        float gamma = smoothDegree;\n                        src.rgb = clamp((src.rgb - colorLevelx) / (colorLevely - colorLevelx), 0.0, 1.0);\n                        src.rgb = clamp(pow(src.rgb, vec3(gamma)), 0.0, 1.0);\n                        smoothNew = src.rgb;\n                    }\n                    gl_FragColor = vec4(smoothNew, 1.0);\n                    } ");
    this.hEy = GLES20.glGetAttribLocation(this.programId, "a_position");
    this.hEz = GLES20.glGetAttribLocation(this.programId, "a_texCoord");
    this.hEA = GLES20.glGetAttribLocation(this.programId, "inputImageTexture");
    this.Hle = GLES20.glGetUniformLocation(this.programId, "smoothDegree");
    this.Hlf = GLES20.glGetUniformLocation(this.programId, "showCounter");
    this.Hlg = GLES20.glGetUniformLocation(this.programId, "showMode");
    this.Hlh = GLES20.glGetUniformLocation(this.programId, "brightness");
    this.Hli = GLES20.glGetUniformLocation(this.programId, "texelWidth");
    this.Hlj = GLES20.glGetUniformLocation(this.programId, "texelHeight");
    if (this.Hmt) {
      this.Hms = new a();
    }
    for (;;)
    {
      GLES20.glTexParameterf(36197, 10241, 9729.0F);
      GLES20.glTexParameterf(36197, 10240, 9729.0F);
      GLES20.glTexParameterf(36197, 10242, 33071.0F);
      GLES20.glTexParameterf(36197, 10243, 33071.0F);
      AppMethodBeat.o(236169);
      return;
      this.hEx = new e(0, 0, 0, 0, 2, 0, 32);
    }
  }
  
  @l(hxD={1, 1, 16}, hxE={""}, hxF={"<anonymous>", "", "it", "Ljava/nio/ByteBuffer;", "invoke", "com/tencent/mm/plugin/voip/video/programv2/VoipMMFaceBeautyRendererProgram$setFaceBeautyDataCallback$1$1"})
  public static final class a
    extends q
    implements kotlin.g.a.b<ByteBuffer, x>
  {
    public a(b paramb, r paramr)
    {
      super();
    }
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mm\classes7.jar
 * Qualified Name:     com.tencent.mm.plugin.voip.video.c.b
 * JD-Core Version:    0.7.0.1
 */