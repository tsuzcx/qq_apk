package com.tencent.mm.plugin.voip.video.c;

import android.opengl.GLES20;
import com.tencent.matrix.trace.core.AppMethodBeat;
import com.tencent.mm.media.util.c;
import com.tencent.mm.media.util.c.a;
import kotlin.Metadata;

@Metadata(d1={""}, d2={"Lcom/tencent/mm/plugin/voip/video/programv2/VoipMMFaceBeautyRendererProgram;", "", "()V", "attributePosition", "", "attributeTextureCoord", "brightnessUniform", "programId", "showCounterUniform", "showModeUniform", "smoothDegreeUniform", "texelHeightUniform", "texelWidthUniform", "uniformTexture", "release", "", "renderImpl", "drawWidth", "drawHeight", "cubeBuffer", "Ljava/nio/FloatBuffer;", "textureCoordBuff", "texture", "plugin-voip_release"}, k=1, mv={1, 5, 1}, xi=48)
public final class f
{
  public int UPT;
  public int UPU;
  public int UPV;
  public int UPW;
  public int UPX;
  public int UPY;
  public int mWv;
  public int mWw;
  public int mWx;
  public int programId;
  
  public f()
  {
    AppMethodBeat.i(293257);
    c.a locala = c.nFs;
    this.programId = c.a.aN("\n        attribute vec4 a_position;\n        attribute vec2 a_texCoord;\n        varying vec2 v_texCoord;\n        void main() {\n            gl_Position = a_position;\n            v_texCoord = a_texCoord;\n        }\n        ", "\n                    #extension GL_OES_EGL_image_external : require\n                    varying highp vec2 v_texCoord;\n                    uniform samplerExternalOES inputImageTexture;\n                    uniform mediump float smoothDegree;\n                    uniform mediump int showCounter;\n                    uniform mediump int showMode;\n                    uniform mediump float brightness;\n                    uniform mediump float texelWidth;\n                    uniform mediump float texelHeight;\n                    precision highp float;\n                    const mat3 RGBtoYUV = mat3(0.299,  0.587, 0.114, 0.5, -0.4187, -0.0813, -0.169, -0.3313,  0.5 );    //full range\\n\" +\n                    const mat3 YUVtoRGB = mat3(1.1643, 1.5958, 0.0, 1.1643, -0.8129, -0.3917, 1.1643, 0.0, 2.017 );\n                    const highp mat3 saturateMatrix = mat3(\n                    1.1102, -0.0598, -0.061,\n                    -0.0774, 1.0826, -0.1186,\n                    -0.0228, -0.0228, 1.1772);\n                    vec3 rgb2hsv(vec3 c) {\n                        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n                        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n                        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n                        float d = q.x - min(q.w, q.y);\n                        float e = 1.0e-10;\n                        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n                    }\n                    vec3 hsv2rgb(vec3 c) {\n                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n                    }\n\n                    vec3 yuv2rgb(vec3 c) {\n                        vec3 rgb = YUVtoRGB*c;\n                        return rgb;\n                    }\n                    vec3 rgb2yuv(vec3 c) {\n                        vec3 yuv = c*RGBtoYUV;\n                        return yuv;\n                    }\n                    mediump float hardLight(mediump float color) {\n                        if (color <= 0.5)\n                        color = color * color * 2.0;\n                        else\n                        color = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n                        return color;\n                    }\n                    float lum(vec3 v) {\n                        return dot(v, vec3(0.299, 0.587, 0.114));\n                    }\n\n                    vec4 getValue(vec4 newValue, vec4 originValue) {\n                        return mix(newValue, originValue, step(lum(newValue.rgb), lum(originValue.rgb)));\n                    }\n                    vec4 Sobel2() {\n                        vec2 samplerSteps = vec2(1.0/texelWidth, 1.0/texelHeight);\n                        vec2 coords[8];\n                        coords[0] = v_texCoord - samplerSteps * 2.0;\n                        coords[1] = v_texCoord + vec2(0.0, -samplerSteps.y) * 2.0;\n                        coords[2] = v_texCoord + vec2(samplerSteps.x, -samplerSteps.y) * 2.0;\n                        coords[3] = v_texCoord - vec2(samplerSteps.x, 0.0) * 2.0;\n                        coords[4] = v_texCoord + vec2(samplerSteps.x, 0.0) * 2.0;\n                        coords[5] = v_texCoord + vec2(-samplerSteps.x, samplerSteps.y) * 2.0;\n                        coords[6] = v_texCoord + vec2(0.0, samplerSteps.y) * 2.0;\n                        coords[7] = v_texCoord + vec2(samplerSteps.x, samplerSteps.y) * 2.0;\n                        vec3 colors[8];\n                        for(int i = 0; i < 8; ++i) {\n                            colors[i] = texture2D(inputImageTexture, coords[i]).rgb;\n                        }\n                        vec4 src = texture2D(inputImageTexture, v_texCoord);\n                        vec3 h = -colors[0] - 2.0 * colors[1] - colors[2] + colors[5] + 2.0 * colors[6] + colors[7];\n                        vec3 v = -colors[0] + colors[2] - 2.0 * colors[3] + 2.0 * colors[4] - colors[5] + colors[7];\n                        return vec4(mix(src.rgb, sqrt(h * h + v * v), 1.0), src.a);\n                    }\n                    vec4 maxFilter() {\n                        vec2 samplerSteps = vec2(1.0/texelWidth, 1.0/texelHeight);\n                        vec2 texCoord[13];\n                        vec4 vMin;\n                        vec2 thisCoord = v_texCoord;\n                        texCoord[0] = thisCoord + vec2(0, -samplerSteps.y * 2.0);\n                        texCoord[1] = thisCoord - samplerSteps;\n                        texCoord[2] = thisCoord + vec2(0, -samplerSteps.y);\n                        texCoord[3] = thisCoord + vec2(samplerSteps.x, -samplerSteps.y);\n                        texCoord[4] = thisCoord + vec2(-samplerSteps.x * 2.0, 0.0);\n                        texCoord[5] = thisCoord + vec2(-samplerSteps.x, 0.0);\n                        texCoord[6] = thisCoord;\n                        texCoord[7] = thisCoord + vec2(samplerSteps.x, 0.0);\n                        texCoord[8] = thisCoord + vec2(samplerSteps.x * 2.0, 0.0);\n                        texCoord[9] = thisCoord + vec2(-samplerSteps.x, samplerSteps.y);\n                        texCoord[10] = thisCoord + vec2(0.0, samplerSteps.y);\n                        texCoord[11] = thisCoord + samplerSteps;\n                        texCoord[12] = thisCoord + vec2(0.0, 2.0* samplerSteps.y);\n                        {\n                            vec4 vTemp;\n                            vMin = texture2D(inputImageTexture, texCoord[0]);\n                            vTemp = texture2D(inputImageTexture, texCoord[1]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[2]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[3]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[4]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[5]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[6]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[7]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[8]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[9]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[10]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[11]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[12]);\n                            vMin = getValue(vTemp, vMin);\n                        }\n                        return vMin;\n                    }\n\n                    void main() {\n                        highp vec3 yuv;\n                        highp vec3 rgb;\n                        vec3 centralColor = texture2D(inputImageTexture,  v_texCoord).rgb;\n                        vec2 blurCoordinates[20];\n                        vec2 imageStep = vec2(1.5/texelWidth, 1.5/texelHeight);\n                        //重新调整了滤波的范围和权重，减少水波纹\n                        blurCoordinates[0] = v_texCoord + vec2(0.0, -4.0) * imageStep;\n                        blurCoordinates[1] = v_texCoord + vec2(2.0, -3.0) * imageStep;\n                        blurCoordinates[2] = v_texCoord + vec2(3.0, -2.0) * imageStep;\n                        blurCoordinates[3] = v_texCoord + vec2(4.0, 0.0) * imageStep;\n                        blurCoordinates[4] = v_texCoord + vec2(3.0, 2.0) * imageStep;\n                        blurCoordinates[5] = v_texCoord + vec2(2.0, 3.0) * imageStep;\n                        blurCoordinates[6] = v_texCoord + vec2(0.0, 4.0) * imageStep;\n                        blurCoordinates[7] = v_texCoord + vec2(-2.0, 3.0) * imageStep;\n                        blurCoordinates[8] = v_texCoord + vec2(-3.0, 2.0) * imageStep;\n                        blurCoordinates[9] = v_texCoord + vec2(-4.0, 0.0) * imageStep;\n                        blurCoordinates[10] = v_texCoord + vec2(-3.0, -2.0) * imageStep;\n                        blurCoordinates[11] = v_texCoord + vec2(-2.0, -3.0) * imageStep;\n                        blurCoordinates[12] = v_texCoord + vec2(0.0, -2.0) * imageStep;\n                        blurCoordinates[13] = v_texCoord + vec2(-1.0, -1.0) * imageStep;\n                        blurCoordinates[14] = v_texCoord + vec2(-2.0, 0.0) * imageStep;\n                        blurCoordinates[15] = v_texCoord + vec2(-1.0, 1.0) * imageStep;\n                        blurCoordinates[16] = v_texCoord + vec2(0.0, 2.0) * imageStep;\n                        blurCoordinates[17] = v_texCoord + vec2(1.0, 1.0) * imageStep;\n                        blurCoordinates[18] = v_texCoord + vec2(2.0, 0.0) * imageStep;\n                        blurCoordinates[19] = v_texCoord + vec2(1.0, -1.0) * imageStep;\n                        vec3 sampleColor = centralColor * 24.0;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[0]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[1]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[2]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[3]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[4]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[5]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[6]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[7]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[8]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[9]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[10]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[11]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[12]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[13]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[14]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[15]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[16]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[17]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[18]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[19]).rgb;\n                        sampleColor = sampleColor/44.0;\n                        float dis = centralColor.g - sampleColor.g + 0.5;\n                        for (int i = 0; i < 5; i++) {\n                            dis = hardLight(dis);\n                        }\n                        // 0.065 -> 1.125, 加大滤波强度\n                        vec3 result = centralColor * 1.125 - dis * 0.125; //central+(central-dis)*0.065\n                        float hue = dot(result, vec3(0.299,0.587,0.114)) - 0.3;   //luminance\n                        hue = pow(clamp(hue, 0.0, 1.0), 0.3);\n                        yuv= rgb2yuv(sampleColor);\n                        float cr=yuv.y-0.094;\n                        float cb=yuv.z+0.0745;\n                        float tx = ((25.59*cr-19.19*cb)*255.0 + 51.0)*0.04;\n                        float ty = ((25.59*cr+19.19*cb)*255.0 + 77.0)*0.07;\n                        float val0 = tx*tx + ty*ty;\n                        float chroma_sum=yuv.y+yuv.z+1.0;\n                        float chroma_diff=yuv.y-yuv.z;\n                        float chroma_diff_th = 0.1-(yuv.x/10.0);\n                        float face = 1.0;\n                        if(yuv.z>-0.1667 && yuv.z<0.0294 && chroma_sum>0.7804 && chroma_sum<1.098 && chroma_diff>chroma_diff_th) {\n                            if(yuv.x<0.3922) {\n                                if(val0<1700.0) {\n                                    face = 0.0;\n                                } else {\n                                    hue = 0.0;\n                                }\n                            } else {\n                                if(val0<3150.0) {\n                                    face = 0.0;\n                                } else {\n                                    hue = 0.0;\n                                }\n                            }\n                        } else {\n                            hue = 0.0;\n                        }\n                        result = centralColor * (1.0 - hue) + result * hue;\n                        result = result+vec3(brightness*0.1);\n                        // 这里可以进一步简化计算\n                        if(showMode == 1 /*|| showMode == 2*/) {\n                             result = vec3(hue);\n                        }\n                        else if(showMode == 0) {\n                            result = centralColor;\n                        }\n                        vec3 smoothNew = mix(centralColor, result, smoothDegree);\n                    //showCounter用于显示mask\n                    if(showCounter == 1) {\n                        smoothNew =vec3(face);\n                    }\n                    //mode3:显示边缘\n                    if(showMode == 3) {\n                        vec3 maxValue = maxFilter().rgb;\n                        float lumOrigin = lum(centralColor);\n                        float lumMax = lum(maxValue) + 0.001;\n                        float blendColor = min(lumOrigin / lumMax, 1.0);\n                        float smoothDegree2 =  0.8 + (smoothDegree/5.0); //约束范围：0.8~1.0\n                        smoothNew =mix(centralColor, vec3(blendColor), smoothDegree2);\n                    }\n                    //mode4:显示轮廓\n                    if(showMode == 4) {\n                        vec4 src  = Sobel2();\n                        // saturation合并到level中\n                        max(src.r, src.g);\n                        float lum = (max(max(src.r, src.g),src.b) + min(min(src.r, src.g), src.b)) / 2.0;\n                        src = vec4(mix(vec3(lum), src.rgb, 0.0), src.a);  //intensity = 0.0\n                        // level filter: colorLevel.x = dark = 0.33, colorLevel.y = light = 0.60\n                        float colorLevelx = 0.3;\n                        float colorLevely = 0.60;\n                        //float gamma = 0.99;\n                        float gamma = smoothDegree;\n                        src.rgb = clamp((src.rgb - colorLevelx) / (colorLevely - colorLevelx), 0.0, 1.0);\n                        src.rgb = clamp(pow(src.rgb, vec3(gamma)), 0.0, 1.0);\n                        smoothNew = src.rgb;\n                    }\n                    gl_FragColor = vec4(smoothNew, 1.0);\n                    } ");
    this.mWv = GLES20.glGetAttribLocation(this.programId, "a_position");
    this.mWw = GLES20.glGetAttribLocation(this.programId, "a_texCoord");
    this.mWx = GLES20.glGetAttribLocation(this.programId, "inputImageTexture");
    this.UPT = GLES20.glGetUniformLocation(this.programId, "smoothDegree");
    this.UPU = GLES20.glGetUniformLocation(this.programId, "showCounter");
    this.UPV = GLES20.glGetUniformLocation(this.programId, "showMode");
    this.UPW = GLES20.glGetUniformLocation(this.programId, "brightness");
    this.UPX = GLES20.glGetUniformLocation(this.programId, "texelWidth");
    this.UPY = GLES20.glGetUniformLocation(this.programId, "texelHeight");
    GLES20.glTexParameterf(36197, 10241, 9729.0F);
    GLES20.glTexParameterf(36197, 10240, 9729.0F);
    GLES20.glTexParameterf(36197, 10242, 33071.0F);
    GLES20.glTexParameterf(36197, 10243, 33071.0F);
    AppMethodBeat.o(293257);
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mm\classes9.jar
 * Qualified Name:     com.tencent.mm.plugin.voip.video.c.f
 * JD-Core Version:    0.7.0.1
 */